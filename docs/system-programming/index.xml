<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Linux 网络编程 on Leon' Blog</title><link>https://ileonli.github.io/docs/system-programming/</link><description>Recent content in Linux 网络编程 on Leon' Blog</description><generator>Hugo</generator><language>en</language><atom:link href="https://ileonli.github.io/docs/system-programming/index.xml" rel="self" type="application/rss+xml"/><item><title>网络字节序</title><link>https://ileonli.github.io/docs/system-programming/network-byte-order/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/system-programming/network-byte-order/</guid><description>&lt;h1 id="网络字节序">
 网络字节序
 &lt;a class="anchor" href="#%e7%bd%91%e7%bb%9c%e5%ad%97%e8%8a%82%e5%ba%8f">#&lt;/a>
&lt;/h1>
&lt;h2 id="大小端">
 大小端
 &lt;a class="anchor" href="#%e5%a4%a7%e5%b0%8f%e7%ab%af">#&lt;/a>
&lt;/h2>
&lt;p>不同架构的 CPU 中，4 字节整数 1 在内存中存储的方式是不同的。&lt;/p>
&lt;ul>
&lt;li>大端序（big endian）：&lt;strong>最高位&lt;/strong>有效字节存储在&lt;strong>低内存地址&lt;/strong>，而&lt;strong>最低位&lt;/strong>有效字节存储在&lt;strong>高内存地址&lt;/strong>。&lt;/li>
&lt;li>小端序（little endian）：&lt;strong>最高位&lt;/strong>有效字节存储在&lt;strong>高内存地址&lt;/strong>，而&lt;strong>最低位&lt;/strong>有效字节存储在&lt;strong>低内存地址&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>对于一个 4 字节整数 &lt;code>0x01020304&lt;/code>，大小端序存储方式分别如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>地址: 0 1 2 3 （大端序保存）
 01 02 03 04
&lt;/code>&lt;/pr</description></item><item><title>网络地址族</title><link>https://ileonli.github.io/docs/system-programming/address-families/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/system-programming/address-families/</guid><description>&lt;h1 id="网络地址族">
 网络地址族
 &lt;a class="anchor" href="#%e7%bd%91%e7%bb%9c%e5%9c%b0%e5%9d%80%e6%97%8f">#&lt;/a>
&lt;/h1>
&lt;h2 id="网络地址">
 网络地址
 &lt;a class="anchor" href="#%e7%bd%91%e7%bb%9c%e5%9c%b0%e5%9d%80">#&lt;/a>
&lt;/h2>
&lt;p>网络地址分为 IPv4 和 IPv6，分别使用 &lt;code>sockaddr_in&lt;/code> 和 &lt;code>sockaddr_in6&lt;/code> 结构体表示。&lt;/p>
&lt;h3 id="sockaddr_in">
 sockaddr_in
 &lt;a class="anchor" href="#sockaddr_in">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> sockaddr_in {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">sa_family_t&lt;/span> sin_family; &lt;span style="color:#75715e">/* address family: AF_INET */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">in_port_t&lt;/span> sin_port; &lt;span style="color:#75715e">/* port in network byte order */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> in_addr sin_addr; &lt;span style="color:#75715e">/* internet address */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* Pad to size of `struct sockaddr&amp;#39;. */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> sin_zero[&lt;span style="color:#ae81ff">8&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* Internet address */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> in_addr {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint32_t&lt;/span> s_addr; &lt;span style="color:#75715e">/* address in network byte order */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pr</description></item><item><title>listen 中的 backlog 参数</title><link>https://ileonli.github.io/docs/system-programming/backlog/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/system-programming/backlog/</guid><description/></item><item><title>（非）阻塞 I/O</title><link>https://ileonli.github.io/docs/system-programming/block-and-nonblock-io/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/system-programming/block-and-nonblock-io/</guid><description>&lt;h1 id="非阻塞-io-和-epoll翻译">
 （非）阻塞 I/O 和 epoll（翻译）
 &lt;a class="anchor" href="#%e9%9d%9e%e9%98%bb%e5%a1%9e-io-%e5%92%8c-epoll%e7%bf%bb%e8%af%91">#&lt;/a>
&lt;/h1>
&lt;blockquote>
&lt;p>原文：https://eklitzke.org/blocking-io-nonblocking-io-and-epoll&lt;/p>
&lt;/blockquote>
&lt;p>在这篇文章中，我想解释使用非阻塞 I/O 时会发生什么。我特别想说明的是:&lt;/p>
&lt;ol>
&lt;li>使用 &lt;code>fcntl&lt;/code> 函数设置文件描述符的 &lt;code>O_NONBLOCK&lt;/code> 时的语义。&lt;/li>
&lt;li>非阻塞（nonblocking） I/O 与异步（asynchronous） I/O 的区别。&lt;/li>
&lt;li>为什么非阻塞 I/O 经常与诸如 &lt;code>select&lt;/code>、&lt;code>epoll&lt;/code> 和 &lt;code>kqueue&lt;/code> 等 I/O 多路复用器一起使用。&lt;/li>
&lt;li>非阻塞模式如何与 &lt;code>epoll&lt;/code> 中的边缘触发轮询交互。&lt;/li>
&lt;/ol>
&lt;h2 id="阻塞模式">
 阻塞模式
 &lt;a class="anchor" href="#%e9%98%bb%e5%a1%9e%e6%a8%a1%e5%bc%8f">#&lt;/a>
&lt;/h2>
&lt;p>默认情况下，Unix 系统所有的文件描述符都以“阻塞模式”启动。这意味着像 &lt;code>read&lt;/code>、&lt;code>write&lt;/code> 或 &lt;code>connect&lt;/code> 这样的 I/O 系统调用可能会阻塞。一个很容易理解的方法是当你从一个普通的基于 TTY 的程序中的 &lt;code>stdin&lt;/code> 读取数据时会发生什么。如果你在 &lt;code>stdin&lt;/code>上调用 &lt;code>read&lt;/code>，那么你的程序将会阻塞，直到数据实际上可用，比如当用户实际上在键盘上键入字符时。具体来说，内核会将进程置于“睡眠”状态，直到 &lt;code>stdin&lt;/code> 上的数据可用。其他类型的文件描述符也是如此。例如，如果你尝试从 TCP 套接字中读取数据，那么 &lt;code>read&lt;/code> 调用将会阻塞，直到连接的另一端实际上发送数据。&lt;/p></description></item><item><title>I/O 多路复用</title><link>https://ileonli.github.io/docs/system-programming/multiplexing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/system-programming/multiplexing/</guid><description>&lt;h1 id="io-多路复用">
 I/O 多路复用
 &lt;a class="anchor" href="#io-%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8">#&lt;/a>
&lt;/h1>
&lt;p>I/O 复用可以使程序同时监听多个文件描述符。&lt;/p>
&lt;h2 id="select">
 select
 &lt;a class="anchor" href="#select">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>select&lt;/code> 函数允许程序监视多个文件描述符，直到一个或多个文件描述符“准备好”进行某类 I/O 操作。&lt;/p>
&lt;p>&lt;code>select&lt;/code> 成功时返回就绪文件描述符的总数，如果超时时间内没有任何文件描述符就绪，则返回 0。失败时返回 -1 并设置 &lt;code>errno&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/select.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">select&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> nfds, fd_set&lt;span style="color:#f92672">*&lt;/span> readfds,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fd_set&lt;span style="color:#f92672">*&lt;/span> writefds,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fd_set&lt;span style="color:#f92672">*&lt;/span> exceptfds,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> timeval &lt;span style="color:#f92672">*&lt;/span> timeout);
&lt;/span>&lt;/span>&lt;/code>&lt;/pr</description></item><item><title>Reactor 模型</title><link>https://ileonli.github.io/docs/system-programming/reactor-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/system-programming/reactor-pattern/</guid><description>&lt;h1 id="reactor-模型">
 Reactor 模型
 &lt;a class="anchor" href="#reactor-%e6%a8%a1%e5%9e%8b">#&lt;/a>
&lt;/h1>
&lt;p>Reactor 模型中定义的三种角色：&lt;/p>
&lt;ul>
&lt;li>Reactor：负责监听和分配事件，将I/O事件分派给对应的 Handler。新的事件包含连接建立就绪、读就绪、写就绪等。&lt;/li>
&lt;li>Acceptor：处理客户端新连接，并分派请求到处理器链中。&lt;/li>
&lt;li>Handler：将自身与事件绑定，执行非阻塞读/写任务，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel。可用资源池来管理。&lt;/li>
&lt;/ul>
&lt;h2 id="one-loop-per-thread">
 One Loop Per Thread
 &lt;a class="anchor" href="#one-loop-per-thread">#&lt;/a>
&lt;/h2>
&lt;h2 id="参考文献">
 参考文献
 &lt;a class="anchor" href="#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae">#&lt;/a>
&lt;/h2>
&lt;ol>
&lt;li>
 &lt;a href="https://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf">https://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf&lt;/a>&lt;/li>
&lt;li>
 &lt;a href="https://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">https://gee.cs.oswego.edu/dl/cpjslides/nio.pdf&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>套接字（socket）</title><link>https://ileonli.github.io/docs/system-programming/sockets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/system-programming/sockets/</guid><description>&lt;h1 id="套接字socket">
 套接字（socket）
 &lt;a class="anchor" href="#%e5%a5%97%e6%8e%a5%e5%ad%97socket">#&lt;/a>
&lt;/h1>
&lt;p>&lt;strong>网络编程&lt;/strong>即编写程序使两台联网的计算机相互交换数据。计算机之间会通过网线、路由器和交换机等设备连接在一起，我们无需直接操控硬件，而使用操作系统提供的&lt;strong>套接字（socket）&lt;/strong>。&lt;/p>
&lt;h2 id="基本函数">
 基本函数
 &lt;a class="anchor" href="#%e5%9f%ba%e6%9c%ac%e5%87%bd%e6%95%b0">#&lt;/a>
&lt;/h2>
&lt;h3 id="socket">
 socket
 &lt;a class="anchor" href="#socket">#&lt;/a>
&lt;/h3>
&lt;p>为了使用套接字，可以使用 &lt;code>socket&lt;/code> 函数，创建用于通信的端点（endpoint）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/socket.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">socket&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> domain, &lt;span style="color:#66d9ef">int&lt;/span> type, &lt;span style="color:#66d9ef">int&lt;/span> protocol);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>成功时&lt;/strong>会返回文件描述符，&lt;strong>失败时&lt;/strong>会返回 -1。&lt;/p>
&lt;blockquote>
&lt;p>
 &lt;a href="https://man7.org/linux/man-pages/man2/socket.2.html">https://man7.org/linux/man-pages/man2/socket.2.html&lt;/a>&lt;/p></description></item><item><title>echo 服务器</title><link>https://ileonli.github.io/docs/system-programming/echo-server/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/system-programming/echo-server/</guid><description>&lt;h1 id="echo-服务器">
 echo 服务器
 &lt;a class="anchor" href="#echo-%e6%9c%8d%e5%8a%a1%e5%99%a8">#&lt;/a>
&lt;/h1>
&lt;h2 id="辅助函数">
 辅助函数
 &lt;a class="anchor" href="#%e8%be%85%e5%8a%a9%e5%87%bd%e6%95%b0">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>panic&lt;/code> 函数用于错误处理，当发生错误时，调用 &lt;code>exit&lt;/code> 函数直接退出程序。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">panic&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>format, ...) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> va_list args;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">va_start&lt;/span>(args, format);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vfprintf&lt;/span>(stderr, format, args);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">va_end&lt;/span>(args);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">exit&lt;/span>(EXIT_FAILURE);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pr</description></item></channel></rss>