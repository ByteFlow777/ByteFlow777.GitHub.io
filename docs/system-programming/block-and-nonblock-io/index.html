<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="（非）阻塞 I/O 和 epoll（翻译） # 原文：https://eklitzke.org/blocking-io-nonblocking-io-and-epoll
在这篇文章中，我想解释使用非阻塞 I/O 时会发生什么。我特别想说明的是:
使用 fcntl 函数设置文件描述符的 O_NONBLOCK 时的语义。 非阻塞（nonblocking） I/O 与异步（asynchronous） I/O 的区别。 为什么非阻塞 I/O 经常与诸如 select、epoll 和 kqueue 等 I/O 多路复用器一起使用。 非阻塞模式如何与 epoll 中的边缘触发轮询交互。 阻塞模式 # 默认情况下，Unix 系统所有的文件描述符都以“阻塞模式”启动。这意味着像 read、write 或 connect 这样的 I/O 系统调用可能会阻塞。一个很容易理解的方法是当你从一个普通的基于 TTY 的程序中的 stdin 读取数据时会发生什么。如果你在 stdin上调用 read，那么你的程序将会阻塞，直到数据实际上可用，比如当用户实际上在键盘上键入字符时。具体来说，内核会将进程置于“睡眠”状态，直到 stdin 上的数据可用。其他类型的文件描述符也是如此。例如，如果你尝试从 TCP 套接字中读取数据，那么 read 调用将会阻塞，直到连接的另一端实际上发送数据。
阻塞对于应该并发运行的程序来说是一个问题，因为被阻塞的进程会被挂起。解决这个问题有两种不同但互补的方式：
非阻塞模式。 I/O 多路复用系统调用，例如 select 和 epoll。 这两种解决方案经常一起使用，但它们是解决这个问题的独立策略，通常两者都会被使用。接下来我们将会看到它们之间的区别以及为什么它们通常都会被同时使用。
非阻塞模式 # 通过 fcntl 函数在文件描述符的标志集中添加 O_NONBLOCK，可以将文件描述符设置为“非阻塞模式”：
/* set O_NONBLOCK on fd */ int flags = fcntl(fd, F_GETFL, 0); fcntl(fd, F_SETFL, flags | O_NONBLOCK); 从这一点开始，文件描述符被视为非阻塞的。当发生这种情况时，像 read 和 write 这样的 I/O 系统调用将返回 -1，并且 errno 将被设置为 EWOULDBLOCK。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://ileonli.github.io/docs/system-programming/block-and-nonblock-io/"><meta property="og:site_name" content="Leon' Blog"><meta property="og:title" content="（非）阻塞 I/O"><meta property="og:description" content="（非）阻塞 I/O 和 epoll（翻译） # 原文：https://eklitzke.org/blocking-io-nonblocking-io-and-epoll
在这篇文章中，我想解释使用非阻塞 I/O 时会发生什么。我特别想说明的是:
使用 fcntl 函数设置文件描述符的 O_NONBLOCK 时的语义。 非阻塞（nonblocking） I/O 与异步（asynchronous） I/O 的区别。 为什么非阻塞 I/O 经常与诸如 select、epoll 和 kqueue 等 I/O 多路复用器一起使用。 非阻塞模式如何与 epoll 中的边缘触发轮询交互。 阻塞模式 # 默认情况下，Unix 系统所有的文件描述符都以“阻塞模式”启动。这意味着像 read、write 或 connect 这样的 I/O 系统调用可能会阻塞。一个很容易理解的方法是当你从一个普通的基于 TTY 的程序中的 stdin 读取数据时会发生什么。如果你在 stdin上调用 read，那么你的程序将会阻塞，直到数据实际上可用，比如当用户实际上在键盘上键入字符时。具体来说，内核会将进程置于“睡眠”状态，直到 stdin 上的数据可用。其他类型的文件描述符也是如此。例如，如果你尝试从 TCP 套接字中读取数据，那么 read 调用将会阻塞，直到连接的另一端实际上发送数据。
阻塞对于应该并发运行的程序来说是一个问题，因为被阻塞的进程会被挂起。解决这个问题有两种不同但互补的方式：
非阻塞模式。 I/O 多路复用系统调用，例如 select 和 epoll。 这两种解决方案经常一起使用，但它们是解决这个问题的独立策略，通常两者都会被使用。接下来我们将会看到它们之间的区别以及为什么它们通常都会被同时使用。
非阻塞模式 # 通过 fcntl 函数在文件描述符的标志集中添加 O_NONBLOCK，可以将文件描述符设置为“非阻塞模式”：
/* set O_NONBLOCK on fd */ int flags = fcntl(fd, F_GETFL, 0); fcntl(fd, F_SETFL, flags | O_NONBLOCK); 从这一点开始，文件描述符被视为非阻塞的。当发生这种情况时，像 read 和 write 这样的 I/O 系统调用将返回 -1，并且 errno 将被设置为 EWOULDBLOCK。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2024-07-25T22:58:20+08:00"><title>（非）阻塞 I/O | Leon' Blog</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.c4648f90e7f239143d6b1f74326dc2ce1794185b23b8cbbf3f813cfdf5d576ca.css integrity="sha256-xGSPkOfyORQ9ax90Mm3CzheUGFsjuMu/P4E8/fXVdso=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.069d1591c3f51e76b3c5e11745bc780bb29cdd68716f2075012420d68991cc4c.js integrity="sha256-Bp0VkcP1HnazxeEXRbx4C7Kc3WhxbyB1ASQg1omRzEw=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-EL04QEY330"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EL04QEY330")}</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Leon' Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-dfc62bc51fd10e15afc9a11c29a21438 class=toggle>
<label for=section-dfc62bc51fd10e15afc9a11c29a21438 class="flex justify-between"><a role=button>Java</a></label><ul><li><a href=/docs/Java/Agent/>Agent</a></li><li><a href=/docs/Java/Cleaner/>Cleaner 类</a></li><li><a href=/docs/Java/JDBC/>JDBC</a></li><li><a href=/docs/Java/MethodHandles/>MethodHandles</a></li><li><a href=/docs/Java/DynamicProxy/>动态代理</a></li></ul></li><li><input type=checkbox id=section-068f5864eab5429f74d44490ac7dda4f class=toggle>
<label for=section-068f5864eab5429f74d44490ac7dda4f class="flex justify-between"><a role=button>boltdb</a></label><ul><li><a href=/docs/boltdb/introduction/>boltdb 介绍</a></li><li><a href=/docs/boltdb/node/>boltdb node</a></li><li><a href=/docs/boltdb/transaction/>boltdb 事务</a></li><li><a href=/docs/boltdb/bucket/>boltdb 介绍</a></li><li><a href=/docs/boltdb/storage/>boltdb 存储</a></li><li><a href=/docs/boltdb/page/>boltdb 页结构</a></li></ul></li><li><input type=checkbox id=section-6a1b1f139889384d884552bee56583cd class=toggle>
<label for=section-6a1b1f139889384d884552bee56583cd class="flex justify-between"><a role=button>15-445</a></label><ul><li><a href=/docs/15-445/storage/>Database Storage</a></li></ul></li><li><input type=checkbox id=section-dd174040a908659982d53d695ff59f6c class=toggle>
<label for=section-dd174040a908659982d53d695ff59f6c class="flex justify-between"><a role=button>JVM</a></label><ul><li><a href=/docs/JVM/AsmTools/>AsmTools</a></li><li><a href=/docs/JVM/loading-linking-initializing/>JVM 加载-链接-初始化</a></li><li><input type=checkbox id=section-8116e10cba9ea1a7d22332ccf696967c class=toggle>
<label for=section-8116e10cba9ea1a7d22332ccf696967c class="flex justify-between"><a role=button>字节码</a></label><ul><li><a href=/docs/JVM/ByteCode/ClassFile/>Class 文件结构</a></li><li><a href=/docs/JVM/ByteCode/constant_pool/>常量池</a></li></ul></li></ul></li><li><input type=checkbox id=section-322adad93406759f98a33491e2ecc8af class=toggle checked>
<label for=section-322adad93406759f98a33491e2ecc8af class="flex justify-between"><a role=button>Linux 网络编程</a></label><ul><li><a href=/docs/system-programming/network-byte-order/>网络字节序</a></li><li><a href=/docs/system-programming/address-families/>网络地址族</a></li><li><a href=/docs/system-programming/block-and-nonblock-io/ class=active>（非）阻塞 I/O</a></li><li><a href=/docs/system-programming/multiplexing/>I/O 多路复用</a></li><li><a href=/docs/system-programming/reactor-pattern/>Reactor 模型</a></li><li><a href=/docs/system-programming/sockets/>套接字（socket）</a></li><li><a href=/docs/system-programming/echo-server/>echo 服务器</a></li></ul></li><li><input type=checkbox id=section-bcab9cce661800a90eaf0ba45525a392 class=toggle>
<label for=section-bcab9cce661800a90eaf0ba45525a392 class="flex justify-between"><a role=button>MapDB</a></label><ul><li><a href=/docs/MapDB/BTree/>BTree</a></li></ul></li><li><input type=checkbox id=section-be784f006af4b056e801791bd4131884 class=toggle>
<label for=section-be784f006af4b056e801791bd4131884 class="flex justify-between"><a role=button>MyBatis</a></label><ul><li><a href=/docs/MyBatis/SqlSession/>SqlSession</a></li><li><a href=/docs/MyBatis/Mapper/>Mapper</a></li><li><a href=/docs/MyBatis/ResultSetHandler/>ResultSetHandler</a></li><li><a href=/docs/MyBatis/StatementHandler/>StatementHandler</a></li><li><a href=/docs/MyBatis/Executor/>Executor</a></li><li><a href=/docs/MyBatis/Cache/>Cache</a></li></ul></li><li><input type=checkbox id=section-8e8ae3b760618e1158c1946d2d023ca5 class=toggle>
<label for=section-8e8ae3b760618e1158c1946d2d023ca5 class="flex justify-between"><a role=button>Netty</a></label><ul><li><a href=/docs/Netty/ByteBuf/>ByteBuf</a></li><li><a href=/docs/Netty/EventLoop/>EventLoop</a></li><li><a href=/docs/Netty/EventLoopGroup/>EventLoopGroup</a></li><li><a href=/docs/Netty/Channel/>Channel</a></li><li><a href=/docs/Netty/ChannelHandler/>ChannelHandler</a></li><li><a href=/docs/Netty/encoder-and-decoder/>编码器和解码器</a></li></ul></li><li><input type=checkbox id=section-bccb031e3769927ed8f05e90efe74959 class=toggle>
<label for=section-bccb031e3769927ed8f05e90efe74959 class="flex justify-between"><a role=button>Pro Git</a></label><ul><li><a href=/docs/ProGit/Git-%E5%9F%BA%E7%A1%80/>Git 基础</a></li><li><a href=/docs/ProGit/Git-%E5%88%86%E6%94%AF/>Git 分支</a></li></ul></li><li><span>计算机网络</span><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>（非）阻塞 I/O</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#非阻塞-io-和-epoll翻译>（非）阻塞 I/O 和 epoll（翻译）</a><ul><li><a href=#阻塞模式>阻塞模式</a></li><li><a href=#非阻塞模式>非阻塞模式</a></li><li><a href=#io-多路复用select-epoll-kqueue>I/O 多路复用（select, epoll, kqueue）</a></li><li><a href=#o_nonblock-与-io-多路复用的交互方式>O_NONBLOCK 与 I/O 多路复用的交互方式</a></li><li><a href=#边缘触发轮询edge-triggered-polling>边缘触发轮询（Edge-Triggered Polling）</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=非阻塞-io-和-epoll翻译>（非）阻塞 I/O 和 epoll（翻译）
<a class=anchor href=#%e9%9d%9e%e9%98%bb%e5%a1%9e-io-%e5%92%8c-epoll%e7%bf%bb%e8%af%91>#</a></h1><blockquote><p>原文：https://eklitzke.org/blocking-io-nonblocking-io-and-epoll</p></blockquote><p>在这篇文章中，我想解释使用非阻塞 I/O 时会发生什么。我特别想说明的是:</p><ol><li>使用 <code>fcntl</code> 函数设置文件描述符的 <code>O_NONBLOCK</code> 时的语义。</li><li>非阻塞（nonblocking） I/O 与异步（asynchronous） I/O 的区别。</li><li>为什么非阻塞 I/O 经常与诸如 <code>select</code>、<code>epoll</code> 和 <code>kqueue</code> 等 I/O 多路复用器一起使用。</li><li>非阻塞模式如何与 <code>epoll</code> 中的边缘触发轮询交互。</li></ol><h2 id=阻塞模式>阻塞模式
<a class=anchor href=#%e9%98%bb%e5%a1%9e%e6%a8%a1%e5%bc%8f>#</a></h2><p>默认情况下，Unix 系统所有的文件描述符都以“阻塞模式”启动。这意味着像 <code>read</code>、<code>write</code> 或 <code>connect</code> 这样的 I/O 系统调用可能会阻塞。一个很容易理解的方法是当你从一个普通的基于 TTY 的程序中的 <code>stdin</code> 读取数据时会发生什么。如果你在 <code>stdin</code>上调用 <code>read</code>，那么你的程序将会阻塞，直到数据实际上可用，比如当用户实际上在键盘上键入字符时。具体来说，内核会将进程置于“睡眠”状态，直到 <code>stdin</code> 上的数据可用。其他类型的文件描述符也是如此。例如，如果你尝试从 TCP 套接字中读取数据，那么 <code>read</code> 调用将会阻塞，直到连接的另一端实际上发送数据。</p><p>阻塞对于应该并发运行的程序来说是一个问题，因为被阻塞的进程会被挂起。解决这个问题有两种不同但互补的方式：</p><ol><li>非阻塞模式。</li><li>I/O 多路复用系统调用，例如 <code>select</code> 和 <code>epoll</code>。</li></ol><p>这两种解决方案经常一起使用，但它们是解决这个问题的独立策略，通常两者都会被使用。接下来我们将会看到它们之间的区别以及为什么它们通常都会被同时使用。</p><h2 id=非阻塞模式>非阻塞模式
<a class=anchor href=#%e9%9d%9e%e9%98%bb%e5%a1%9e%e6%a8%a1%e5%bc%8f>#</a></h2><p>通过 <code>fcntl</code> 函数在文件描述符的标志集中添加 <code>O_NONBLOCK</code>，可以将文件描述符设置为“非阻塞模式”：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>/* set O_NONBLOCK on fd */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> flags <span style=color:#f92672>=</span> <span style=color:#a6e22e>fcntl</span>(fd, F_GETFL, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span><span style=color:#a6e22e>fcntl</span>(fd, F_SETFL, flags <span style=color:#f92672>|</span> O_NONBLOCK);
</span></span></code></pre></div><p>从这一点开始，文件描述符被视为非阻塞的。当发生这种情况时，像 <code>read</code> 和 <code>write</code> 这样的 I/O 系统调用将返回 -1，并且 <code>errno</code> 将被设置为 <code>EWOULDBLOCK</code>。</p><p>这很有趣，但单独使用实际上并不是那么有用。仅仅使用这种基本方法是没有有效方式同时在多个文件描述符上进行 I/O 的。例如，假设我们有两个文件描述符，并希望同时读取它们。这可以通过循环检查每个文件描述符是否有数据，然后在再次检查之前短暂休眠来实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>struct</span> timespec sleep_interval{.tv_sec <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, .tv_nsec <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000</span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>ssize_t</span> nbytes;
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* try fd1 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((nbytes <span style=color:#f92672>=</span> <span style=color:#a6e22e>read</span>(fd1, buf, <span style=color:#66d9ef>sizeof</span>(buf))) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (errno <span style=color:#f92672>!=</span> EWOULDBLOCK) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;read/fd1&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>handle_data</span>(buf, nbytes);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* try fd2 */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ((nbytes <span style=color:#f92672>=</span> <span style=color:#a6e22e>read</span>(fd2, buf, <span style=color:#66d9ef>sizeof</span>(buf))) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (errno <span style=color:#f92672>!=</span> EWOULDBLOCK) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;read/fd2&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>handle_data</span>(buf, nbytes);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* sleep for a bit; real version needs error checking! */</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>nanosleep</span>(sleep_interval, NULL);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这种方法确实有效，但存在很多缺点：</p><ol><li>当数据传入速度很慢时，程序会频繁而不必要地唤醒，这会浪费 CPU 资源。</li><li>当数据到达时，如果程序正在睡眠，可能不会立即读取数据，因此程序的延迟会很高。</li><li>使用这种模式处理大量文件描述符会变得繁琐。</li></ol><p>为了解决这些问题，我们需要 I/O 多路复用。</p><h2 id=io-多路复用select-epoll-kqueue>I/O 多路复用（select, epoll, kqueue）
<a class=anchor href=#io-%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8select-epoll-kqueue>#</a></h2><p>有几种I/O多路复用系统调用。例如，POSIX 定义的 <code>select</code>，Linux 上的 <code>epoll</code> 系列，以及 BSD 上的 <code>kqueue</code> 系列都是 I/O 多路复用的例子。它们在基本原理上都是相同的：它们让内核知道一组文件描述符上感兴趣的事件（通常是读事件和写事件），然后它们会阻塞，直到发生感兴趣的事件。例如，你可以告诉内核你只对文件描述符 <code>X</code> 上的读事件感兴趣，对文件描述符 <code>Y</code> 上的读和写事件都感兴趣，以及对文件描述符 <code>Z</code> 上的写事件感兴趣。</p><p>这些 I/O 多路复用系统调用通常不关心文件描述符是处于阻塞模式还是非阻塞模式。你可以将所有的文件描述符都保留在阻塞模式下，它们仍然可以与 <code>select</code> 或 <code>epoll</code> 一起正常工作。如果你只对 <code>select</code> 或 <code>epoll</code> 返回的文件描述符调用 <code>read</code> 和 <code>write</code>，那么即使这些文件描述符处于阻塞模式，这些调用也不会阻塞。但有一个重要的例外，文件描述符的阻塞或非阻塞状态对于边缘触发轮询是重要的，下面会进一步解释。</p><p>并发的多路复用方法是我所谓的“异步 I/O”。有时人们也会将这种方法称为“非阻塞 I/O”，我认为这是对系统编程层面中“非阻塞”含义的混淆。我建议将术语“非阻塞”保留用于指代文件描述符是否实际处于非阻塞模式。</p><h2 id=o_nonblock-与-io-多路复用的交互方式>O_NONBLOCK 与 I/O 多路复用的交互方式
<a class=anchor href=#o_nonblock-%e4%b8%8e-io-%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8%e7%9a%84%e4%ba%a4%e4%ba%92%e6%96%b9%e5%bc%8f>#</a></h2><p>假设我们正在使用带有阻塞文件描述符的 <code>select</code> 编写一个简单的套接字服务器。为简单起见，在此示例中，我们只有要从中读取的文件描述符，这些文件描述符存储在 <code>read_fds</code> 中。事件循环的核心部分将调用 <code>select</code>，然后针对每个具有数据的文件描述符调用一次 <code>read</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>ssize_t</span> nbytes;
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* select call happens here */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>select</span>(FD_SETSIZE, <span style=color:#f92672>&amp;</span>read_fds, NULL, NULL, NULL) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;select&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(EXIT_FAILURE);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> FD_SETSIZE; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>FD_ISSET</span>(i, <span style=color:#f92672>&amp;</span>read_fds)) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>/* read call happens here */</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> ((nbytes <span style=color:#f92672>=</span> <span style=color:#a6e22e>read</span>(i, buf, <span style=color:#66d9ef>sizeof</span>(buf))) <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>handle_read</span>(nbytes, buf);
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#75715e>/* real version needs to handle EINTR correctly */</span>
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;read&#34;</span>);
</span></span><span style=display:flex><span>                <span style=color:#a6e22e>exit</span>(EXIT_FAILURE);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样做是有效的，而且完全没问题。但是，如果 <code>buf</code> 很小，而且有大量数据同时传输会发生什么？具体来说，假设 <code>buf</code> 是一个 1024 字节的缓冲区，但一次传输了 64KB 的数据。为了处理这个请求，我们将调用 <code>select</code>，然后调用 64 次 <code>read</code>。总共需要 128 次系统调用，这是相当多的。</p><p>如果缓冲区大小太小，就必须调用很多次 <code>read</code>，这是无法避免的。但也许我们可以减少调用 <code>select</code> 的次数？在这个例子中，理想情况下我们只会调用一次 <code>select</code>。</p><p>事实上，这是可能的，而且可以通过将文件描述符设置为非阻塞模式来实现。基本思想是你可以在一个循环中不断调用 <code>read</code>，直到它返回 <code>EWOULDBLOCK</code> 为止。实现如下所示：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>ssize_t</span> nbytes;
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* select call happens here */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>select</span>(FD_SETSIZE, <span style=color:#f92672>&amp;</span>read_fds, NULL, NULL, NULL) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;select&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(EXIT_FAILURE);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> FD_SETSIZE; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>FD_ISSET</span>(i, <span style=color:#f92672>&amp;</span>read_fds)) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>/* NEW: loop until EWOULDBLOCK is encountered */</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>/* read call happens here */</span>
</span></span><span style=display:flex><span>                nbytes <span style=color:#f92672>=</span> <span style=color:#a6e22e>read</span>(i, buf, <span style=color:#66d9ef>sizeof</span>(buf));
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (nbytes <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                    <span style=color:#a6e22e>handle_read</span>(nbytes, buf);
</span></span><span style=display:flex><span>                } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (errno <span style=color:#f92672>!=</span> EWOULDBLOCK) {
</span></span><span style=display:flex><span>                        <span style=color:#75715e>/* real version needs to handle EINTR correctly */</span>
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>perror</span>(<span style=color:#e6db74>&#34;read&#34;</span>);
</span></span><span style=display:flex><span>                        <span style=color:#a6e22e>exit</span>(EXIT_FAILURE);
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个例子中（1024 字节缓冲区，传入 64KB 的数据），我们将进行 66 次系统调用：<code>select</code> 将被调用一次，<code>read</code> 将被调用 64 次而不会出错，<code>read</code> 将被调用并返回 <code>EWOULDBLOCK</code> 一次。这要比之前的例子好得多！这几乎是前一个例子的一半，这将显著提高性能和可伸缩性。</p><p>这种方法的缺点是由于新的循环，至少会有一次额外的 <code>read</code> 调用，因为它被调用直到返回 <code>EWOULDBLOCK</code>。假设通常情况下读取缓冲区足够大，可以在一个 <code>read</code> 调用中读取所有传入的数据。那么在循环中，通常情况下会有三次系统调用而不是只有两次：<code>select</code> 等待数据，<code>read</code> 实际读取数据，然后再次调用 <code>read</code> 以获取 <code>EWOULDBLOCK</code>。</p><h2 id=边缘触发轮询edge-triggered-polling>边缘触发轮询（Edge-Triggered Polling）
<a class=anchor href=#%e8%be%b9%e7%bc%98%e8%a7%a6%e5%8f%91%e8%bd%ae%e8%af%a2edge-triggered-polling>#</a></h2><p>边缘触发轮询是非阻塞 I/O 的另一个重要用途，特别是在 <code>epoll</code> 系统调用中。这个系统调用有两种模式：水平触发和边缘触发。水平触发是一种更简单的编程模型，类似于经典的 <code>select</code> 系统调用。为了解释它们之间的区别，我们需要了解 <code>epoll</code> 在内核中的工作方式。</p><p>假设你告诉内核你有兴趣使用 <code>epoll</code> 来监视某个文件描述符上的读事件。内核为每个文件描述符维护这些兴趣的列表。当数据到达文件描述符时，内核遍历兴趣列表，并唤醒每个在 <code>epoll_wait</code> 中被阻塞的进程，其中包含了该文件描述符在事件列表中。</p><p>上述内容无论 <code>epoll</code> 处于哪种触发模式都会发生。水平触发和边缘触发轮询的区别在于调用 <code>epoll_wait</code> 时内核的行为。在水平触发模式中，内核将遍历兴趣列表中的每个文件描述符，以查看它是否已满足兴趣条件。例如，如果你在文件描述符 8 上注册了一个读事件，调用 <code>epoll_wait</code> 时内核将首先检查：文件描述符 8 是否已经有数据准备好读取？如果任何文件描述符匹配兴趣条件，则 <code>epoll_wait</code> 可以立即返回而不阻塞。</p><p>相比之下，在边缘触发模式中，内核跳过这个检查，并在调用 <code>epoll_wait</code> 时立即将进程置于睡眠状态。这使得程序员必须完全负责，需要完全读取和写入每个文件描述符的所有数据，然后才能等待。</p><p>边缘触发模式使得 <code>epoll</code> 成为时间复杂度为 O(1) 的 I/O 多路复用器：<code>epoll_wait</code> 调用会立即挂起，由于事先为每个文件描述符维护了一个列表，当新数据到达时，内核会在 O(1) 时间知道必须要唤醒的进程。</p><p>以下是边缘触发和水平触发模式之间差异的更详细示例。假设你的读取缓冲区是 100 字节，而文件描述符上传入了 200 字节的数据。然后假设你只调用了一次 <code>read</code>，然后再次调用了 <code>epoll_wait</code>。仍然有 100 字节的数据准备好读取。在水平触发模式中，内核会注意到这一点，并通知进程应该再次调用 <code>read</code>。相比之下，在边缘触发模式中，内核将立即进入睡眠状态。如果另一侧正在期待响应（例如，发送的数据是某种 RPC），那么两侧将会“死锁”，因为服务器将等待客户端发送更多数据，但客户端将等待服务器发送响应。</p><p>要使用边缘触发轮询，你必须将文件描述符设置为非阻塞模式。然后你必须每次调用 <code>read</code> 或 <code>write</code> 直到它们返回 <code>EWOULDBLOCK</code> 为止。如果你未能满足这些条件，你将错过内核的通知。但这样做有一个很大的好处：每次调用 <code>epoll_wait</code> 都会更有效率，这对于具有极高并发性的程序来说非常重要。如果你想了解更多细节，我强烈建议你阅读
<a href=https://man7.org/linux/man-pages/man7/epoll.7.html>epoll(7)</a> 手册页。</p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#非阻塞-io-和-epoll翻译>（非）阻塞 I/O 和 epoll（翻译）</a><ul><li><a href=#阻塞模式>阻塞模式</a></li><li><a href=#非阻塞模式>非阻塞模式</a></li><li><a href=#io-多路复用select-epoll-kqueue>I/O 多路复用（select, epoll, kqueue）</a></li><li><a href=#o_nonblock-与-io-多路复用的交互方式>O_NONBLOCK 与 I/O 多路复用的交互方式</a></li><li><a href=#边缘触发轮询edge-triggered-polling>边缘触发轮询（Edge-Triggered Polling）</a></li></ul></li></ul></nav></div></aside></main></body></html>