<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="I/O 多路复用 # I/O 复用可以使程序同时监听多个文件描述符。
select # select 函数允许程序监视多个文件描述符，直到一个或多个文件描述符“准备好”进行某类 I/O 操作。
select 成功时返回就绪文件描述符的总数，如果超时时间内没有任何文件描述符就绪，则返回 0。失败时返回 -1 并设置 errno。
#include <sys/select.h> int select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval * timeout); 函数参数 # nfds：指定被监听的文件描述符的总数。这个参数应该被设置为三个集合中编号最高的文件描述符，再加 1，因为文件描述符是从 0 开始的。
readfds、writefds 和 exceptfds：分别指向可读、可写和异常事件对应的文件描述符集合。如果没有文件描述符要监听，则可以将对应的 fd_set 参数设为 NULL。
fd_set 结构体仅包含一个数组，数组每一位标记一个文件描述符，最大容纳长度由 FD_SETSIZE 指定。
/* fd_set for select and pselect. */ typedef struct { /* XPG4.2 requires this member name. Otherwise avoid the name from the global namespace."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="I/O 多路复用"><meta property="og:description" content="I/O 多路复用 # I/O 复用可以使程序同时监听多个文件描述符。
select # select 函数允许程序监视多个文件描述符，直到一个或多个文件描述符“准备好”进行某类 I/O 操作。
select 成功时返回就绪文件描述符的总数，如果超时时间内没有任何文件描述符就绪，则返回 0。失败时返回 -1 并设置 errno。
#include <sys/select.h> int select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval * timeout); 函数参数 # nfds：指定被监听的文件描述符的总数。这个参数应该被设置为三个集合中编号最高的文件描述符，再加 1，因为文件描述符是从 0 开始的。
readfds、writefds 和 exceptfds：分别指向可读、可写和异常事件对应的文件描述符集合。如果没有文件描述符要监听，则可以将对应的 fd_set 参数设为 NULL。
fd_set 结构体仅包含一个数组，数组每一位标记一个文件描述符，最大容纳长度由 FD_SETSIZE 指定。
/* fd_set for select and pselect. */ typedef struct { /* XPG4.2 requires this member name. Otherwise avoid the name from the global namespace."><meta property="og:type" content="article"><meta property="og:url" content="https://ileonli.github.io/docs/system-programming/multiplexing/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2024-02-10T22:24:18+08:00"><title>I/O 多路复用 | Leon' Blog</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.c4648f90e7f239143d6b1f74326dc2ce1794185b23b8cbbf3f813cfdf5d576ca.css integrity="sha256-xGSPkOfyORQ9ax90Mm3CzheUGFsjuMu/P4E8/fXVdso=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.ae14cca37495da28e3b779ff47ef8dfb0abd6c0fbd2f7d78b7e2ca3379e51cb7.js integrity="sha256-rhTMo3SV2ijjt3n/R++N+wq9bA+9L314t+LKM3nlHLc=" crossorigin=anonymous></script><script defer src=/sw.min.88f1afdaf4798d7d3520420dcfe201f928c3d371fdedfc3ae28cd9b6b79544f8.js integrity="sha256-iPGv2vR5jX01IEINz+IB+SjD03H97fw64ozZtreVRPg=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-EL04QEY330"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EL04QEY330",{anonymize_ip:!1})}</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Leon' Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><span>Java</span><ul><li><a href=/docs/Java/Cleaner/>Cleaner 类</a></li></ul></li><li><span>Linux 网络编程</span><ul><li><a href=/docs/system-programming/network-byte-order/>网络字节序</a></li><li><a href=/docs/system-programming/address-families/>网络地址族</a></li><li><a href=/docs/system-programming/block-and-nonblock-io/>（非）阻塞 I/O</a></li><li><a href=/docs/system-programming/multiplexing/ class=active>I/O 多路复用</a></li><li><a href=/docs/system-programming/reactor-pattern/>Reactor 模型</a></li><li><a href=/docs/system-programming/sockets/>套接字（socket）</a></li><li><a href=/docs/system-programming/echo-server/>echo 服务器</a></li></ul></li><li><span>Netty</span><ul><li><a href=/docs/Netty/component/>Netty 中的核心组件</a></li><li><a href=/docs/Netty/ByteBuf/>ByteBuf</a></li><li><a href=/docs/Netty/Pooled-and-Unpooled-ByteBuf/>Pooled 和 Unpooled 的 ByteBuf</a></li></ul></li><li><span>计算机网络</span><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>I/O 多路复用</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#io-多路复用>I/O 多路复用</a><ul><li><a href=#select>select</a><ul><li><a href=#函数参数>函数参数</a></li><li><a href=#就绪条件>就绪条件</a></li><li><a href=#循环中使用>循环中使用</a></li></ul></li><li><a href=#poll>poll</a><ul><li><a href=#函数参数-1>函数参数</a></li></ul></li><li><a href=#epoll>epoll</a><ul><li><a href=#epoll_ctl>epoll_ctl</a></li><li><a href=#epoll_wait>epoll_wait</a></li><li><a href=#水平触发和边缘触发>水平触发和边缘触发</a></li></ul></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=io-多路复用>I/O 多路复用
<a class=anchor href=#io-%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8>#</a></h1><p>I/O 复用可以使程序同时监听多个文件描述符。</p><h2 id=select>select
<a class=anchor href=#select>#</a></h2><p><code>select</code> 函数允许程序监视多个文件描述符，直到一个或多个文件描述符“准备好”进行某类 I/O 操作。</p><p><code>select</code> 成功时返回就绪文件描述符的总数，如果超时时间内没有任何文件描述符就绪，则返回 0。失败时返回 -1 并设置 <code>errno</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/select.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>select</span>(<span style=color:#66d9ef>int</span> nfds, fd_set<span style=color:#f92672>*</span> readfds,
</span></span><span style=display:flex><span>            fd_set<span style=color:#f92672>*</span> writefds,
</span></span><span style=display:flex><span>            fd_set<span style=color:#f92672>*</span> exceptfds,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>struct</span> timeval <span style=color:#f92672>*</span> timeout);
</span></span></code></pre></div><h3 id=函数参数>函数参数
<a class=anchor href=#%e5%87%bd%e6%95%b0%e5%8f%82%e6%95%b0>#</a></h3><p><code>nfds</code>：指定被监听的文件描述符的总数。这个参数应该被设置为三个集合中编号最高的文件描述符，再加 1，因为文件描述符是从 0 开始的。</p><hr><p><code>readfds</code>、<code>writefds</code> 和 <code>exceptfds</code>：分别指向可读、可写和异常事件对应的文件描述符集合。如果没有文件描述符要监听，则可以将对应的 <code>fd_set</code> 参数设为 <code>NULL</code>。</p><p><code>fd_set</code> 结构体仅包含一个数组，数组每一位标记一个文件描述符，最大容纳长度由 <code>FD_SETSIZE</code> 指定。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>/* fd_set for select and pselect.  */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* XPG4.2 requires this member name.  Otherwise avoid the name
</span></span></span><span style=display:flex><span><span style=color:#75715e>       from the global namespace.  */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef __USE_XOPEN
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    __fd_mask fds_bits[__FD_SETSIZE <span style=color:#f92672>/</span> __NFDBITS];
</span></span><span style=display:flex><span><span style=color:#75715e># define __FDS_BITS(set) ((set)-&gt;fds_bits)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#else
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    __fd_mask __fds_bits[__FD_SETSIZE <span style=color:#f92672>/</span> __NFDBITS];
</span></span><span style=display:flex><span><span style=color:#75715e># define __FDS_BITS(set) ((set)-&gt;__fds_bits)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  } fd_set;
</span></span></code></pre></div><p>为方便对此结构体进行操作，提供了以下几个宏函数对其进行操作，宏函数如下：</p><blockquote><p>为方便展示，对宏函数中的所有参数加上了类型</p></blockquote><ul><li><code>FD_SET(fd, fdsetp)</code>：将文件描述符 <code>fd</code> 添加到 <code>fdset</code> 指向的集合中。</li><li><code>FD_CLR(fd, fdsetp)</code>：将文件描述符 <code>fd</code> 从 <code>fdset</code> 指向的集合中移除。</li><li><code>FD_ISSET(fd, fdsetp)</code>：如果文件描述符 <code>fd</code> 是 <code>fdset</code> 指向的集合中的成员，则返回 <code>true</code>。</li><li><code>FD_ZERO(fdsetp)</code>：将 <code>fdset</code> 指向的集合初始化为空。</li></ul><hr><p><code>timeval</code>：用来设置 <code>select</code> 函数的超时时间，采用指针作为参数是因为内核将修改以告诉应用程序 select 等待了多久。</p><p>如果 <code>timeval</code> 结构体中的 <code>tv_sec</code> 和 <code>tv_usec</code> 成员都传递 0，则 <code>select</code> 函数立即返回。如果传递 <code>NULL</code>，则一直阻塞，直到某个文件描述符就绪。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>/* A time value that is accurate to the nearest
</span></span></span><span style=display:flex><span><span style=color:#75715e>   microsecond but also has a range of years.  */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> timeval
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef __USE_TIME_BITS64
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  __time64_t tv_sec;		<span style=color:#75715e>/* Seconds.  */</span>
</span></span><span style=display:flex><span>  __suseconds64_t tv_usec;	<span style=color:#75715e>/* Microseconds.  */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#else
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  __time_t tv_sec;		<span style=color:#75715e>/* Seconds.  */</span>
</span></span><span style=display:flex><span>  __suseconds_t tv_usec;	<span style=color:#75715e>/* Microseconds.  */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><h3 id=就绪条件>就绪条件
<a class=anchor href=#%e5%b0%b1%e7%bb%aa%e6%9d%a1%e4%bb%b6>#</a></h3><p>在网络编程中，下边情况下 <code>socket</code> 可读：</p><p>在网络编程中，下边情况下 <code>socket</code> 可写：</p><p><code>select</code> 函数能处理的异常情况只有一种：<code>socket</code> 上接收到带外数据。</p><h3 id=循环中使用>循环中使用
<a class=anchor href=#%e5%be%aa%e7%8e%af%e4%b8%ad%e4%bd%bf%e7%94%a8>#</a></h3><p>由于这些结构体会在调用中被修改，如果要在循环中重复调用 <code>select</code> 函数，我们必须保证每次都要重新初始化它们。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C></code></pre></div><h2 id=poll>poll
<a class=anchor href=#poll>#</a></h2><p><code>poll</code> 函数和 <code>select</code> 函数调用返回值一致。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;poll.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>poll</span>(<span style=color:#66d9ef>struct</span> pollfd <span style=color:#f92672>*</span>fds, <span style=color:#66d9ef>nfds_t</span> nfds, <span style=color:#66d9ef>int</span> timeout);
</span></span></code></pre></div><h3 id=函数参数-1>函数参数
<a class=anchor href=#%e5%87%bd%e6%95%b0%e5%8f%82%e6%95%b0-1>#</a></h3><p><code>fds</code>：需要 <code>poll</code> 函数检查的文件描述符，该参数为 <code>pollfd</code> 结构体数组。</p><p><code>pollfd</code> 结构体中 <code>fd</code> 指定文件描述符；<code>events</code> 告诉 <code>poll</code> 函数需要监听哪些事件；<code>revents</code> 由内核对其进行修改，以通知应用程序 <code>fd</code> 上实际发生了哪些事件。</p><table><thead><tr><th>位掩码</th><th>events</th><th>返回到revents</th><th>描述</th></tr></thead><tbody><tr><td>POLLIN</td><td>●</td><td>●</td><td>可读取非高优先级的数据</td></tr><tr><td>POLLRDNORM</td><td>●</td><td>●</td><td>等同于POLLIN</td></tr><tr><td>POLLRDBAND</td><td>●</td><td>●</td><td>可读取优先级数据（Linux 中不使用）</td></tr><tr><td>POLLPRI</td><td>●</td><td>●</td><td>可读取高优先级数据</td></tr><tr><td>POLLRDHUP</td><td>●</td><td>●</td><td>对端套接字关闭</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>POLLOUT</td><td>●</td><td>●</td><td>普通数据可写</td></tr><tr><td>POLLWRNORM</td><td>●</td><td>●</td><td>等同于POLLOUT</td></tr><tr><td>POLLWRBAND</td><td>●</td><td>●</td><td>优先级数据可写入</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>POLLERR</td><td></td><td>●</td><td>有错误发生</td></tr><tr><td>POLLHUP</td><td></td><td>●</td><td>出现挂断</td></tr><tr><td>POLLNVAL</td><td></td><td>●</td><td>文件描述符未打开</td></tr><tr><td>POLLMSG</td><td></td><td></td><td>Linux 中不使用</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>struct</span> pollfd {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span>   fd;         <span style=color:#75715e>/* file descriptor */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>short</span> events;     <span style=color:#75715e>/* requested events */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>short</span> revents;    <span style=color:#75715e>/* returned events */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><hr><p><code>nfds</code>：用于指定数组 <code>fds</code> 中元素的个数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>/* Type used for the number of file descriptors.  */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span> <span style=color:#66d9ef>nfds_t</span>;
</span></span></code></pre></div><hr><p><code>timeout</code>：指定 <code>poll</code> 的超时值，单位为毫秒。</p><ul><li>当 <code>timeout</code> 为 -1 时，<code>poll</code> 调用将一直阻塞，直到某个事件发生；</li><li>当 <code>timeout</code> 为 0 时，<code>poll</code> 调用将立即返回。</li></ul><h2 id=epoll>epoll
<a class=anchor href=#epoll>#</a></h2><p><code>epoll</code> 是 Linux 特有的 I/O 复用函数。<code>epoll</code> 需要使用额外的文件描述符，标识内核中的这个事件表，需要使用 <code>epoll_create</code> 函数创建，返回文件描述符。</p><p><code>size</code> 是想要通过 <code>epoll</code> 来检查的文件描述符个数。该参数并不是一个上限，而是告诉内核应该如何为内部数据结构划分初始大小（从 Linux 2.6.8 版以来，<code>size</code> 参数被忽略不用，因为内核实现做了修改意味着该参数提供的信息已经不再需要了）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/epoll.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_create</span> (<span style=color:#66d9ef>int</span> size);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_create1</span> (<span style=color:#66d9ef>int</span> flags);
</span></span></code></pre></div><h3 id=epoll_ctl>epoll_ctl
<a class=anchor href=#epoll_ctl>#</a></h3><p><code>epoll_ctl</code> 函数能够修改由文件描述符 <code>epfd</code> 所代表的兴趣列表。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_ctl</span> (<span style=color:#66d9ef>int</span> epfd, <span style=color:#66d9ef>int</span> op, <span style=color:#66d9ef>int</span> fd,
</span></span><span style=display:flex><span>		      <span style=color:#66d9ef>struct</span> epoll_event <span style=color:#f92672>*</span>event);
</span></span></code></pre></div><hr><p><code>epfd</code> 是调用 <code>epoll_create</code> 函数的返回值。</p><hr><p><code>op</code> 用于操作操作类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>/* Valid opcodes ( &#34;op&#34; parameter ) to issue to epoll_ctl().  */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define EPOLL_CTL_ADD 1	</span><span style=color:#75715e>/* Add a file descriptor to the interface.  */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define EPOLL_CTL_DEL 2	</span><span style=color:#75715e>/* Remove a file descriptor from the interface.  */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define EPOLL_CTL_MOD 3	</span><span style=color:#75715e>/* Change file descriptor epoll_event structure.  */</span><span style=color:#75715e>
</span></span></span></code></pre></div><hr><p><code>events</code> 是一个位掩码，指定了待检查描述符 <code>fd</code> 上感兴趣的事件集合。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>struct</span> epoll_event
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint32_t</span> events;	 <span style=color:#75715e>/* Epoll events */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>epoll_data_t</span> data; <span style=color:#75715e>/* User data variable */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>data</code> 当描述符 <code>fd</code> 就绪时，传递给调用者的信息。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>union</span> epoll_data
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> fd;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint32_t</span> u32;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint64_t</span> u64;
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>epoll_data_t</span>;
</span></span></code></pre></div><h3 id=epoll_wait>epoll_wait
<a class=anchor href=#epoll_wait>#</a></h3><p>返回 <code>epoll</code> 实例中处于就绪态的文件描述符信息。单个 <code>epoll_wait</code> 函数调用能返回多个就绪态文件描述符的信息。</p><p>调用成功后，<code>epoll_wait</code> 函数返回数组 <code>events</code> 元素个数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_wait</span> (<span style=color:#66d9ef>int</span> epfd, <span style=color:#66d9ef>struct</span> epoll_event <span style=color:#f92672>*</span>events,
</span></span><span style=display:flex><span>		       <span style=color:#66d9ef>int</span> maxevents, <span style=color:#66d9ef>int</span> timeout);
</span></span></code></pre></div><hr><p><code>events</code> 所指向的结构体数组中返回的是有关就绪态文件描述符的信息。</p><p>数组 <code>events</code> 的空间由调用者负责申请，所包含的元素个数由参数 <code>maxevents</code> 指定。</p><hr><p><code>timeout</code>：指定 <code>epoll</code> 的超时值，单位为毫秒。</p><ul><li>当 <code>timeout</code> 为 -1 时，<code>epoll</code> 调用将一直阻塞，直到某个事件发生；</li><li>当 <code>timeout</code> 为 0 时，<code>epoll</code> 执行一次非阻塞式的检查，看兴趣列表中的文件描述符上产生了哪个事件。</li><li>当 <code>timeout</code> 大于 0 时，<code>epoll</code> 阻塞至多 <code>timeout</code> 毫秒，直到文件描述符上有事件发生，或者直到捕获到一个信号为止。</li></ul><h3 id=水平触发和边缘触发>水平触发和边缘触发
<a class=anchor href=#%e6%b0%b4%e5%b9%b3%e8%a7%a6%e5%8f%91%e5%92%8c%e8%be%b9%e7%bc%98%e8%a7%a6%e5%8f%91>#</a></h3><p><code>epoll</code> 默认工作模式为<strong>水平触发</strong>，当往 <code>epoll</code> 内核事件表中注册一个文件描述符上的 <code>EPOLLET</code> 事件时，将以<strong>边缘触发</strong>模式工作。</p><ul><li><p>LT 模式（水平）：缓冲区剩余未读尽的数据<strong>会</strong>导致 <code>epoll_wait</code> 返回。直到新的事件满足才会触发。支持阻塞和非阻塞。</p></li><li><p>ET 模式（边缘）：缓冲区剩余未读尽的数据<strong>不会</strong>导致 <code>epoll_wait</code> 返回。必须设置为非阻塞。</p></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#io-多路复用>I/O 多路复用</a><ul><li><a href=#select>select</a><ul><li><a href=#函数参数>函数参数</a></li><li><a href=#就绪条件>就绪条件</a></li><li><a href=#循环中使用>循环中使用</a></li></ul></li><li><a href=#poll>poll</a><ul><li><a href=#函数参数-1>函数参数</a></li></ul></li><li><a href=#epoll>epoll</a><ul><li><a href=#epoll_ctl>epoll_ctl</a></li><li><a href=#epoll_wait>epoll_wait</a></li><li><a href=#水平触发和边缘触发>水平触发和边缘触发</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>