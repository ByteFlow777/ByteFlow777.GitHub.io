<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="boltdb 页结构 # page # type page struct { id pgid flags uint16 count uint16 overflow uint32 ptr uintptr } id：是页面的标识符，每个页面在数据库文件中都有一个唯一的 ID，用于在数据库中定位和引用该页面。 flags：用来表示页面的类型或其他特性。 count：表示页面中存储的元素数量（通常是键值对的数量或子页面的引用数量）。 overflow：表示页面溢出的数量。如果一个页面装不下所有的数据，它可能会使用多个连续的页面来存储，这些连续的页面被称为溢出页面。 ptr：用于指向页面的数据部分。在内存中指向实际存储键值对或其他数据的区域。这个指针使得可以通过内存地址快速访问页面中的数据。 一个 page 页的结构如下所示：
根据 flags 的设置，ptr 会指向 4 种结构体之一。
const ( branchPageFlag = 0x01 leafPageFlag = 0x02 metaPageFlag = 0x04 freelistPageFlag = 0x10 ) branchPageFlag：ptr 指向 branchPageElement[] 数组。 leafPageFlag：ptr 指向 leafPageElement[] 数组。 metaPageFlag：ptr 指向 meta 结构体。 freelistPageFlag：ptr 指向 freelist 结构体。 branchPageElement # // branchPageElement represents a node on a branch page."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://ileonli.github.io/docs/boltdb/page/"><meta property="og:site_name" content="Leon' Blog"><meta property="og:title" content="boltdb 页结构"><meta property="og:description" content="boltdb 页结构 # page # type page struct { id pgid flags uint16 count uint16 overflow uint32 ptr uintptr } id：是页面的标识符，每个页面在数据库文件中都有一个唯一的 ID，用于在数据库中定位和引用该页面。 flags：用来表示页面的类型或其他特性。 count：表示页面中存储的元素数量（通常是键值对的数量或子页面的引用数量）。 overflow：表示页面溢出的数量。如果一个页面装不下所有的数据，它可能会使用多个连续的页面来存储，这些连续的页面被称为溢出页面。 ptr：用于指向页面的数据部分。在内存中指向实际存储键值对或其他数据的区域。这个指针使得可以通过内存地址快速访问页面中的数据。 一个 page 页的结构如下所示：
根据 flags 的设置，ptr 会指向 4 种结构体之一。
const ( branchPageFlag = 0x01 leafPageFlag = 0x02 metaPageFlag = 0x04 freelistPageFlag = 0x10 ) branchPageFlag：ptr 指向 branchPageElement[] 数组。 leafPageFlag：ptr 指向 leafPageElement[] 数组。 metaPageFlag：ptr 指向 meta 结构体。 freelistPageFlag：ptr 指向 freelist 结构体。 branchPageElement # // branchPageElement represents a node on a branch page."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2024-08-23T22:42:38+08:00"><title>boltdb 页结构 | Leon' Blog</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.c4648f90e7f239143d6b1f74326dc2ce1794185b23b8cbbf3f813cfdf5d576ca.css integrity="sha256-xGSPkOfyORQ9ax90Mm3CzheUGFsjuMu/P4E8/fXVdso=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.d8fea3fcc8b5bb58b1ff9055fd6218bc5e5bd5ee6c6fbf6eb6605a4df0251845.js integrity="sha256-2P6j/Mi1u1ix/5BV/WIYvF5b1e5sb79utmBaTfAlGEU=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-EL04QEY330"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EL04QEY330")}</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Leon' Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-dfc62bc51fd10e15afc9a11c29a21438 class=toggle>
<label for=section-dfc62bc51fd10e15afc9a11c29a21438 class="flex justify-between"><a role=button>Java</a></label><ul><li><a href=/docs/Java/Agent/>Agent</a></li><li><a href=/docs/Java/Cleaner/>Cleaner 类</a></li><li><a href=/docs/Java/JDBC/>JDBC</a></li><li><a href=/docs/Java/MethodHandles/>MethodHandles</a></li><li><a href=/docs/Java/DynamicProxy/>动态代理</a></li></ul></li><li><input type=checkbox id=section-068f5864eab5429f74d44490ac7dda4f class=toggle checked>
<label for=section-068f5864eab5429f74d44490ac7dda4f class="flex justify-between"><a role=button>boltdb</a></label><ul><li><a href=/docs/boltdb/introduction/>boltdb 介绍</a></li><li><a href=/docs/boltdb/node/>boltdb node</a></li><li><a href=/docs/boltdb/transaction/>boltdb 事务</a></li><li><a href=/docs/boltdb/bucket/>boltdb 介绍</a></li><li><a href=/docs/boltdb/storage/>boltdb 存储</a></li><li><a href=/docs/boltdb/page/ class=active>boltdb 页结构</a></li></ul></li><li><input type=checkbox id=section-6a1b1f139889384d884552bee56583cd class=toggle>
<label for=section-6a1b1f139889384d884552bee56583cd class="flex justify-between"><a role=button>15-445</a></label><ul><li><a href=/docs/15-445/storage/>Database Storage</a></li></ul></li><li><input type=checkbox id=section-dd174040a908659982d53d695ff59f6c class=toggle>
<label for=section-dd174040a908659982d53d695ff59f6c class="flex justify-between"><a role=button>JVM</a></label><ul><li><a href=/docs/JVM/AsmTools/>AsmTools</a></li><li><a href=/docs/JVM/loading-linking-initializing/>JVM 加载-链接-初始化</a></li><li><input type=checkbox id=section-8116e10cba9ea1a7d22332ccf696967c class=toggle>
<label for=section-8116e10cba9ea1a7d22332ccf696967c class="flex justify-between"><a role=button>字节码</a></label><ul><li><a href=/docs/JVM/ByteCode/ClassFile/>Class 文件结构</a></li><li><a href=/docs/JVM/ByteCode/constant_pool/>常量池</a></li></ul></li></ul></li><li><input type=checkbox id=section-322adad93406759f98a33491e2ecc8af class=toggle>
<label for=section-322adad93406759f98a33491e2ecc8af class="flex justify-between"><a role=button>Linux 网络编程</a></label><ul><li><a href=/docs/system-programming/network-byte-order/>网络字节序</a></li><li><a href=/docs/system-programming/address-families/>网络地址族</a></li><li><a href=/docs/system-programming/block-and-nonblock-io/>（非）阻塞 I/O</a></li><li><a href=/docs/system-programming/multiplexing/>I/O 多路复用</a></li><li><a href=/docs/system-programming/reactor-pattern/>Reactor 模型</a></li><li><a href=/docs/system-programming/sockets/>套接字（socket）</a></li><li><a href=/docs/system-programming/echo-server/>echo 服务器</a></li></ul></li><li><input type=checkbox id=section-bcab9cce661800a90eaf0ba45525a392 class=toggle>
<label for=section-bcab9cce661800a90eaf0ba45525a392 class="flex justify-between"><a role=button>MapDB</a></label><ul><li><a href=/docs/MapDB/BTree/>BTree</a></li></ul></li><li><input type=checkbox id=section-be784f006af4b056e801791bd4131884 class=toggle>
<label for=section-be784f006af4b056e801791bd4131884 class="flex justify-between"><a role=button>MyBatis</a></label><ul><li><a href=/docs/MyBatis/SqlSession/>SqlSession</a></li><li><a href=/docs/MyBatis/Mapper/>Mapper</a></li><li><a href=/docs/MyBatis/ResultSetHandler/>ResultSetHandler</a></li><li><a href=/docs/MyBatis/StatementHandler/>StatementHandler</a></li><li><a href=/docs/MyBatis/Executor/>Executor</a></li><li><a href=/docs/MyBatis/Cache/>Cache</a></li></ul></li><li><input type=checkbox id=section-8e8ae3b760618e1158c1946d2d023ca5 class=toggle>
<label for=section-8e8ae3b760618e1158c1946d2d023ca5 class="flex justify-between"><a role=button>Netty</a></label><ul><li><a href=/docs/Netty/ByteBuf/>ByteBuf</a></li><li><a href=/docs/Netty/EventLoop/>EventLoop</a></li><li><a href=/docs/Netty/EventLoopGroup/>EventLoopGroup</a></li><li><a href=/docs/Netty/Channel/>Channel</a></li><li><a href=/docs/Netty/ChannelHandler/>ChannelHandler</a></li><li><a href=/docs/Netty/encoder-and-decoder/>编码器和解码器</a></li></ul></li><li><input type=checkbox id=section-bccb031e3769927ed8f05e90efe74959 class=toggle>
<label for=section-bccb031e3769927ed8f05e90efe74959 class="flex justify-between"><a role=button>Pro Git</a></label><ul><li><a href=/docs/ProGit/Git-%E5%9F%BA%E7%A1%80/>Git 基础</a></li><li><a href=/docs/ProGit/Git-%E5%88%86%E6%94%AF/>Git 分支</a></li></ul></li><li><span>计算机网络</span><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>boltdb 页结构</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#boltdb-页结构>boltdb 页结构</a><ul><li><a href=#page>page</a><ul><li><a href=#branchpageelement>branchPageElement</a></li><li><a href=#leafpageelement>leafPageElement</a></li><li><a href=#pos-的作用>pos 的作用</a></li><li><a href=#meta>meta</a></li><li><a href=#freelist>freelist</a></li></ul></li><li><a href=#node>node</a><ul><li><a href=#inode>inode</a></li><li><a href=#page---node>page -> node</a></li><li><a href=#node---page>node -> page</a></li></ul></li><li><a href=#bucket>bucket</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=boltdb-页结构>boltdb 页结构
<a class=anchor href=#boltdb-%e9%a1%b5%e7%bb%93%e6%9e%84>#</a></h1><h2 id=page>page
<a class=anchor href=#page>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>page</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>id</span>       <span style=color:#a6e22e>pgid</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>flags</span>    <span style=color:#66d9ef>uint16</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>count</span>    <span style=color:#66d9ef>uint16</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>overflow</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ptr</span>      <span style=color:#66d9ef>uintptr</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>id</code>：是页面的标识符，每个页面在数据库文件中都有一个唯一的 ID，用于在数据库中定位和引用该页面。</li><li><code>flags</code>：用来表示页面的类型或其他特性。</li><li><code>count</code>：表示页面中存储的元素数量（通常是键值对的数量或子页面的引用数量）。</li><li><code>overflow</code>：表示页面溢出的数量。如果一个页面装不下所有的数据，它可能会使用多个连续的页面来存储，这些连续的页面被称为<strong>溢出页面</strong>。</li><li><code>ptr</code>：用于指向页面的数据部分。在内存中指向实际存储键值对或其他数据的区域。这个指针使得可以通过内存地址快速访问页面中的数据。</li></ul><p>一个 <code>page</code> 页的结构如下所示：</p><p><img src=/img/boltdb/point-to-element.png alt></p><p>根据 <code>flags</code> 的设置，<code>ptr</code> 会指向 4 种结构体之一。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>const</span> (
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>branchPageFlag</span>   = <span style=color:#ae81ff>0x01</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>leafPageFlag</span>     = <span style=color:#ae81ff>0x02</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>metaPageFlag</span>     = <span style=color:#ae81ff>0x04</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>freelistPageFlag</span> = <span style=color:#ae81ff>0x10</span>
</span></span><span style=display:flex><span>)
</span></span></code></pre></div><ul><li><code>branchPageFlag</code>：<code>ptr</code> 指向 <code>branchPageElement[]</code> 数组。</li><li><code>leafPageFlag</code>：<code>ptr</code> 指向 <code>leafPageElement[]</code> 数组。</li><li><code>metaPageFlag</code>：<code>ptr</code> 指向 <code>meta</code> 结构体。</li><li><code>freelistPageFlag</code>：<code>ptr</code> 指向 <code>freelist</code> 结构体。</li></ul><h3 id=branchpageelement>branchPageElement
<a class=anchor href=#branchpageelement>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#75715e>// branchPageElement represents a node on a branch page.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>branchPageElement</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pos</span>   <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ksize</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pgid</span>  <span style=color:#a6e22e>pgid</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>branchPageElement(index)</code> 会返回 <code>index</code> 位置的 <code>branchPageElement</code>。</p><p><code>branchPageElements()</code> 会返回页面中所有分支节点的切片。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#75715e>// branchPageElement retrieves the branch node by index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>page</span>) <span style=color:#a6e22e>branchPageElement</span>(<span style=color:#a6e22e>index</span> <span style=color:#66d9ef>uint16</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>branchPageElement</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span>((<span style=color:#f92672>*</span>[<span style=color:#ae81ff>0x7FFFFFF</span>]<span style=color:#a6e22e>branchPageElement</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>)))[<span style=color:#a6e22e>index</span>]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// branchPageElements retrieves a list of branch nodes.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>page</span>) <span style=color:#a6e22e>branchPageElements</span>() []<span style=color:#a6e22e>branchPageElement</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>count</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> ((<span style=color:#f92672>*</span>[<span style=color:#ae81ff>0x7FFFFFF</span>]<span style=color:#a6e22e>branchPageElement</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>)))[:]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用 <code>pos</code> 可以定位到 <code>key</code> 所在的位置，通过保存的 <code>ksize</code> 获取值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#75715e>// key returns a byte slice of the node key.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>branchPageElement</span>) <span style=color:#a6e22e>key</span>() []<span style=color:#66d9ef>byte</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>buf</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span>[<span style=color:#a6e22e>maxAllocSize</span>]<span style=color:#66d9ef>byte</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>n</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> (<span style=color:#f92672>*</span>[<span style=color:#a6e22e>maxAllocSize</span>]<span style=color:#66d9ef>byte</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>pos</span>]))[:<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>ksize</span>]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=leafpageelement>leafPageElement
<a class=anchor href=#leafpageelement>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#75715e>// leafPageElement represents a node on a leaf page.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>leafPageElement</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>flags</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pos</span>   <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>ksize</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>vsize</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>和 <code>branchPageElement</code> 一样的步骤。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#75715e>// leafPageElement retrieves the leaf node by index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>page</span>) <span style=color:#a6e22e>leafPageElement</span>(<span style=color:#a6e22e>index</span> <span style=color:#66d9ef>uint16</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>leafPageElement</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span>((<span style=color:#f92672>*</span>[<span style=color:#ae81ff>0x7FFFFFF</span>]<span style=color:#a6e22e>leafPageElement</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>)))[<span style=color:#a6e22e>index</span>]
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>n</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// leafPageElements retrieves a list of leaf nodes.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>page</span>) <span style=color:#a6e22e>leafPageElements</span>() []<span style=color:#a6e22e>leafPageElement</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>count</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> ((<span style=color:#f92672>*</span>[<span style=color:#ae81ff>0x7FFFFFF</span>]<span style=color:#a6e22e>leafPageElement</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>)))[:]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通过 <code>pos</code> 获取 KV 在的起始索引，再使用 <code>ksize</code> 和 <code>vsize</code> 分别获取 key 和 value。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#75715e>// key returns a byte slice of the node key.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>leafPageElement</span>) <span style=color:#a6e22e>key</span>() []<span style=color:#66d9ef>byte</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>buf</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span>[<span style=color:#a6e22e>maxAllocSize</span>]<span style=color:#66d9ef>byte</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>n</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> (<span style=color:#f92672>*</span>[<span style=color:#a6e22e>maxAllocSize</span>]<span style=color:#66d9ef>byte</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>pos</span>]))[:<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>ksize</span>:<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>ksize</span>]
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// value returns a byte slice of the node value.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>leafPageElement</span>) <span style=color:#a6e22e>value</span>() []<span style=color:#66d9ef>byte</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>buf</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span>[<span style=color:#a6e22e>maxAllocSize</span>]<span style=color:#66d9ef>byte</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>n</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> (<span style=color:#f92672>*</span>[<span style=color:#a6e22e>maxAllocSize</span>]<span style=color:#66d9ef>byte</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>buf</span>[<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>pos</span><span style=color:#f92672>+</span><span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>ksize</span>]))[:<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>vsize</span>:<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>vsize</span>]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img src=/img/boltdb/page-point-to-leafPage.png alt></p><h3 id=pos-的作用>pos 的作用
<a class=anchor href=#pos-%e7%9a%84%e4%bd%9c%e7%94%a8>#</a></h3><p>为什么要使用 <code>pos</code> 指向 <code>key</code> 所在位置的索引，而不直接将 <code>key</code> 和 <code>value</code> 数组保存在 <code>leafPageElement</code> 结构体中呢？</p><p><img src=/img/boltdb/leafPageElements.png alt></p><p>这样可以直接把字节数组直接转为内存中 <code>[]leafPageElement</code> 结构，而不需要额外的处理。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#75715e>// leafPageElements retrieves a list of leaf nodes.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>page</span>) <span style=color:#a6e22e>leafPageElements</span>() []<span style=color:#a6e22e>leafPageElement</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>count</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> ((<span style=color:#f92672>*</span>[<span style=color:#ae81ff>0x7FFFFFF</span>]<span style=color:#a6e22e>leafPageElement</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>)))[:]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>如果 <code>leafPageElement</code> 结构体设计为下边，就不能直接把 <code>p.ptr</code> 转为 <code>[]leafPageElement</code> 了，因为 <code>bytes</code> 不是定长的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#75715e>// leafPageElement represents a node on a leaf page.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>leafPageElement</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>flags</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ksize</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>vsize</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>bytes</span> []<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>更改后的结构体需要使用循环对每个 <code>leafPageElement</code> 进行解析，这样会损失部分性能。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>page</span>) <span style=color:#a6e22e>leafPageElements</span>() []<span style=color:#a6e22e>leafPageElement</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>count</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>es</span> <span style=color:#f92672>:=</span> make([]<span style=color:#a6e22e>leafPageElement</span>, <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>count</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; int(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>count</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>es</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>parseLeafPageElement</span>()
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>es</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><p><code>branchPageElement</code> 设计和 <code>leafPageElement</code> 是一致的。区别在于，<code>branchPageElement</code> 只有 <code>key</code>，而没有 <code>value</code>。</p><p><img src=/img/boltdb/branchPageElemenst.png alt></p><h3 id=meta>meta
<a class=anchor href=#meta>#</a></h3><p><code>meta</code> 是 boltdb 数据库的元数据，关于数据库信息都保存在此结构体中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>meta</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>magic</span>    <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>version</span>  <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pageSize</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>flags</span>    <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>root</span>     <span style=color:#a6e22e>bucket</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>freelist</span> <span style=color:#a6e22e>pgid</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pgid</span>     <span style=color:#a6e22e>pgid</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>txid</span>     <span style=color:#a6e22e>txid</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>checksum</span> <span style=color:#66d9ef>uint64</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>magix</code>：魔法数字，为：<code>0xED0CDAED</code>。</li><li><code>version</code>：数据库文件保存的格式，目前为 <code>2</code>。</li><li><code>pageSize</code>：页大小，从操作系统中获取。</li><li><code>flags</code>：目前没有被使用。</li><li><code>root</code>：根 <code>bucket</code>。</li><li><code>freelist</code>：保存 <code>freelist</code> 的 <code>pgid</code>。</li><li><code>pgid</code>：保存当前总的页面数量，即最大页面号加一。</li><li><code>txid</code>：上一次写数据库的事务序号，可以看作是当前 boltdb 的修改版本号，每次写数据库时加 1，只读事务不会改变。</li><li><code>checksum</code>：校验码，用于校验元数据页面是否出错的。</li></ul><h3 id=freelist>freelist
<a class=anchor href=#freelist>#</a></h3><p>boltdb 磁盘分配的单位为页，<code>freelist</code> 只用于记录可用和闲置的页 ID。</p><p>当 boltdb 删除数据后，并不会将页占用的空间还给操作系统</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#75715e>// allocate returns a contiguous block of memory starting at a given page.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>db</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>DB</span>) <span style=color:#a6e22e>allocate</span>(<span style=color:#a6e22e>count</span> <span style=color:#66d9ef>int</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>page</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Allocate a temporary buffer for the page.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>buf</span> []<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>count</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>buf</span> = <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>pagePool</span>.<span style=color:#a6e22e>Get</span>().([]<span style=color:#66d9ef>byte</span>)
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>buf</span> = make([]<span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>count</span><span style=color:#f92672>*</span><span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>pageSize</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>page</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>buf</span>[<span style=color:#ae81ff>0</span>]))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>overflow</span> = uint32(<span style=color:#a6e22e>count</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Use pages from the freelist if they are available.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>id</span> = <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>freelist</span>.<span style=color:#a6e22e>allocate</span>(<span style=color:#a6e22e>count</span>); <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>id</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>p</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Resize mmap() if we&#39;re at the end.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>id</span> = <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>rwtx</span>.<span style=color:#a6e22e>meta</span>.<span style=color:#a6e22e>pgid</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>minsz</span> = int((<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>id</span><span style=color:#f92672>+</span><span style=color:#a6e22e>pgid</span>(<span style=color:#a6e22e>count</span>))<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>pageSize</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>minsz</span> <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>datasz</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>mmap</span>(<span style=color:#a6e22e>minsz</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>			<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;mmap allocate error: %s&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Move the page id high water mark.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>rwtx</span>.<span style=color:#a6e22e>meta</span>.<span style=color:#a6e22e>pgid</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>pgid</span>(<span style=color:#a6e22e>count</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>p</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=node>node
<a class=anchor href=#node>#</a></h2><p><code>node</code> 代表 B+ 树在内存中的一个节点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#75715e>// node represents an in-memory, deserialized page.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>node</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>bucket</span>     <span style=color:#f92672>*</span><span style=color:#a6e22e>Bucket</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>isLeaf</span>     <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>unbalanced</span> <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>spilled</span>    <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>key</span>        []<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pgid</span>       <span style=color:#a6e22e>pgid</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>parent</span>     <span style=color:#f92672>*</span><span style=color:#a6e22e>node</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>children</span>   <span style=color:#a6e22e>nodes</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>inodes</span>     <span style=color:#a6e22e>inodes</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=inode>inode
<a class=anchor href=#inode>#</a></h3><p><code>inode</code> 用于保存 <code>node</code> 节点中保存的一条 K/V 数据，使用 <code>inodes</code> 保存所有 K/V 数据。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#75715e>// inode represents an internal node inside of a node.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// It can be used to point to elements in a page or point
</span></span></span><span style=display:flex><span><span style=color:#75715e>// to an element which hasn&#39;t been added to a page yet.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>inode</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>flags</span> <span style=color:#66d9ef>uint32</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>pgid</span>  <span style=color:#a6e22e>pgid</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>key</span>   []<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>value</span> []<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>inodes</span> []<span style=color:#a6e22e>inode</span>
</span></span></code></pre></div><h3 id=page---node>page -> node
<a class=anchor href=#page---node>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#75715e>// read initializes the node from a page.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>node</span>) <span style=color:#a6e22e>read</span>(<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>page</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>pgid</span> = <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>id</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>isLeaf</span> = ((<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>flags</span> <span style=color:#f92672>&amp;</span> <span style=color:#a6e22e>leafPageFlag</span>) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>inodes</span> = make(<span style=color:#a6e22e>inodes</span>, int(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>count</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; int(<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>count</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>inode</span> <span style=color:#f92672>:=</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>inodes</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>isLeaf</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>elem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>leafPageElement</span>(uint16(<span style=color:#a6e22e>i</span>))
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>inode</span>.<span style=color:#a6e22e>flags</span> = <span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>flags</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>inode</span>.<span style=color:#a6e22e>key</span> = <span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>key</span>()
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>inode</span>.<span style=color:#a6e22e>value</span> = <span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>value</span>()
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>elem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>branchPageElement</span>(uint16(<span style=color:#a6e22e>i</span>))
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>inode</span>.<span style=color:#a6e22e>pgid</span> = <span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>pgid</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>inode</span>.<span style=color:#a6e22e>key</span> = <span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>key</span>()
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>_assert</span>(len(<span style=color:#a6e22e>inode</span>.<span style=color:#a6e22e>key</span>) &gt; <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;read: zero-length inode key&#34;</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Save first key so we can find the node in the parent when we spill.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>inodes</span>) &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>key</span> = <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>inodes</span>[<span style=color:#ae81ff>0</span>].<span style=color:#a6e22e>key</span>
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>_assert</span>(len(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>key</span>) &gt; <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;read: zero-length node key&#34;</span>)
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>key</span> = <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=node---page>node -> page
<a class=anchor href=#node---page>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#75715e>// write writes the items onto one or more pages.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>n</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>node</span>) <span style=color:#a6e22e>write</span>(<span style=color:#a6e22e>p</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>page</span>) {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Initialize page.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>isLeaf</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>flags</span> <span style=color:#f92672>|=</span> <span style=color:#a6e22e>leafPageFlag</span>
</span></span><span style=display:flex><span>	} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>flags</span> <span style=color:#f92672>|=</span> <span style=color:#a6e22e>branchPageFlag</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>inodes</span>) <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>0xFFFF</span> {
</span></span><span style=display:flex><span>		panic(<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;inode overflow: %d (pgid=%d)&#34;</span>, len(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>inodes</span>), <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>id</span>))
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>count</span> = uint16(len(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>inodes</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Stop here if there are no items to write.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>count</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Loop over each item and write it to the page.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span>[<span style=color:#a6e22e>maxAllocSize</span>]<span style=color:#66d9ef>byte</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>ptr</span>))[<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>pageElementSize</span>()<span style=color:#f92672>*</span>len(<span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>inodes</span>):]
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>item</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>inodes</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>_assert</span>(len(<span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>key</span>) &gt; <span style=color:#ae81ff>0</span>, <span style=color:#e6db74>&#34;write: zero-length inode key&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Write the page element.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>n</span>.<span style=color:#a6e22e>isLeaf</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>elem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>leafPageElement</span>(uint16(<span style=color:#a6e22e>i</span>))
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>pos</span> = uint32(uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>[<span style=color:#ae81ff>0</span>])) <span style=color:#f92672>-</span> uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>elem</span>)))
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>flags</span> = <span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>flags</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>ksize</span> = uint32(len(<span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>key</span>))
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>vsize</span> = uint32(len(<span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>value</span>))
</span></span><span style=display:flex><span>		} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>elem</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>branchPageElement</span>(uint16(<span style=color:#a6e22e>i</span>))
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>pos</span> = uint32(uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>[<span style=color:#ae81ff>0</span>])) <span style=color:#f92672>-</span> uintptr(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#a6e22e>elem</span>)))
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>ksize</span> = uint32(len(<span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>key</span>))
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>pgid</span> = <span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>pgid</span>
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>_assert</span>(<span style=color:#a6e22e>elem</span>.<span style=color:#a6e22e>pgid</span> <span style=color:#f92672>!=</span> <span style=color:#a6e22e>p</span>.<span style=color:#a6e22e>id</span>, <span style=color:#e6db74>&#34;write: circular dependency occurred&#34;</span>)
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// If the length of key+value is larger than the max allocation size
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// then we need to reallocate the byte array pointer.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#75715e>// See: https://github.com/boltdb/bolt/pull/335
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>klen</span>, <span style=color:#a6e22e>vlen</span> <span style=color:#f92672>:=</span> len(<span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>key</span>), len(<span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>value</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>b</span>) &lt; <span style=color:#a6e22e>klen</span><span style=color:#f92672>+</span><span style=color:#a6e22e>vlen</span> {
</span></span><span style=display:flex><span>			<span style=color:#a6e22e>b</span> = (<span style=color:#f92672>*</span>[<span style=color:#a6e22e>maxAllocSize</span>]<span style=color:#66d9ef>byte</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>[<span style=color:#ae81ff>0</span>]))[:]
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Write data for the element to the end of the page.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		copy(<span style=color:#a6e22e>b</span>[<span style=color:#ae81ff>0</span>:], <span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>key</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>b</span>[<span style=color:#a6e22e>klen</span>:]
</span></span><span style=display:flex><span>		copy(<span style=color:#a6e22e>b</span>[<span style=color:#ae81ff>0</span>:], <span style=color:#a6e22e>item</span>.<span style=color:#a6e22e>value</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>b</span> = <span style=color:#a6e22e>b</span>[<span style=color:#a6e22e>vlen</span>:]
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// DEBUG ONLY: n.dump()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=bucket>bucket
<a class=anchor href=#bucket>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#75715e>// Bucket represents a collection of key/value pairs inside the database.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Bucket</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#f92672>*</span><span style=color:#a6e22e>bucket</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>tx</span>       <span style=color:#f92672>*</span><span style=color:#a6e22e>Tx</span>                <span style=color:#75715e>// the associated transaction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>buckets</span>  <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>Bucket</span> <span style=color:#75715e>// subbucket cache
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>page</span>     <span style=color:#f92672>*</span><span style=color:#a6e22e>page</span>              <span style=color:#75715e>// inline page reference
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>rootNode</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>node</span>              <span style=color:#75715e>// materialized node for the root page.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>nodes</span>    <span style=color:#66d9ef>map</span>[<span style=color:#a6e22e>pgid</span>]<span style=color:#f92672>*</span><span style=color:#a6e22e>node</span>     <span style=color:#75715e>// node cache
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Sets the threshold for filling nodes when they split. By default,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// the bucket will fill to 50% but it can be useful to increase this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// amount if you know that your write workloads are mostly append-only.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// This is non-persisted across transactions so it must be set in every Tx.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>FillPercent</span> <span style=color:#66d9ef>float64</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// bucket represents the on-file representation of a bucket.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// This is stored as the &#34;value&#34; of a bucket key. If the bucket is small enough,
</span></span></span><span style=display:flex><span><span style=color:#75715e>// then its root page can be stored inline in the &#34;value&#34;, after the bucket
</span></span></span><span style=display:flex><span><span style=color:#75715e>// header. In the case of inline buckets, the &#34;root&#34; will be 0.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>bucket</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>root</span>     <span style=color:#a6e22e>pgid</span>   <span style=color:#75715e>// page id of the bucket&#39;s root-level page
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>sequence</span> <span style=color:#66d9ef>uint64</span> <span style=color:#75715e>// monotonically incrementing, used by NextSequence()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#boltdb-页结构>boltdb 页结构</a><ul><li><a href=#page>page</a><ul><li><a href=#branchpageelement>branchPageElement</a></li><li><a href=#leafpageelement>leafPageElement</a></li><li><a href=#pos-的作用>pos 的作用</a></li><li><a href=#meta>meta</a></li><li><a href=#freelist>freelist</a></li></ul></li><li><a href=#node>node</a><ul><li><a href=#inode>inode</a></li><li><a href=#page---node>page -> node</a></li><li><a href=#node---page>node -> page</a></li></ul></li><li><a href=#bucket>bucket</a></li></ul></li></ul></nav></div></aside></main></body></html>