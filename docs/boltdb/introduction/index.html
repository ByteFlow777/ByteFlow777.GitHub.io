<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content='boltdb 介绍 # https://github.com/boltdb/bolt
boltdb 是一个使用 Go 语言开发的 KV 存储库。该项目的目标是为那些不需要完整数据库服务器（如：Postgres或MySQL）的项目提供一个简单、快速且可靠的数据库。
boltdb 目前已不再维护，CoreOS fork 了该项目，并继续维护 bbolt。
打开数据库 # boltdb 中的顶层对象是 DB。它在磁盘上表示为一个单一文件，并且代表了数据的一个一致性快照。
要打开数据库，只需使用 bolt.Open() 函数：
package main import ( "log" "github.com/boltdb/bolt" ) func main() { // Open the my.db data file in your current directory. // It will be created if it doesn&#39;t exist. db, err := bolt.Open("my.db", 0600, nil) if err != nil { log.Fatal(err) } defer db.Close() ... } 请注意，boltdb 会对数据文件加锁，因此多个进程不能同时打开同一个数据库。尝试打开一个已经被打开的 boltdb 数据库将导致程序挂起，直到其他进程关闭该数据库。为了防止无限期等待，可以为 Open() 函数传递一个超时选项：'><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://ileonli.github.io/docs/boltdb/introduction/"><meta property="og:site_name" content="Leon' Blog"><meta property="og:title" content="boltdb 介绍"><meta property="og:description" content='boltdb 介绍 # https://github.com/boltdb/bolt
boltdb 是一个使用 Go 语言开发的 KV 存储库。该项目的目标是为那些不需要完整数据库服务器（如：Postgres或MySQL）的项目提供一个简单、快速且可靠的数据库。
boltdb 目前已不再维护，CoreOS fork 了该项目，并继续维护 bbolt。
打开数据库 # boltdb 中的顶层对象是 DB。它在磁盘上表示为一个单一文件，并且代表了数据的一个一致性快照。
要打开数据库，只需使用 bolt.Open() 函数：
package main import ( "log" "github.com/boltdb/bolt" ) func main() { // Open the my.db data file in your current directory. // It will be created if it doesn&#39;t exist. db, err := bolt.Open("my.db", 0600, nil) if err != nil { log.Fatal(err) } defer db.Close() ... } 请注意，boltdb 会对数据文件加锁，因此多个进程不能同时打开同一个数据库。尝试打开一个已经被打开的 boltdb 数据库将导致程序挂起，直到其他进程关闭该数据库。为了防止无限期等待，可以为 Open() 函数传递一个超时选项：'><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2024-08-23T22:42:38+08:00"><title>boltdb 介绍 | Leon' Blog</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.c4648f90e7f239143d6b1f74326dc2ce1794185b23b8cbbf3f813cfdf5d576ca.css integrity="sha256-xGSPkOfyORQ9ax90Mm3CzheUGFsjuMu/P4E8/fXVdso=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.fc35cc05fd1e755d3e6ca2629dc31f2e0e2436e6ea22195062812bb6eadc6cc5.js integrity="sha256-/DXMBf0edV0+bKJincMfLg4kNubqIhlQYoErturcbMU=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-EL04QEY330"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EL04QEY330")}</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Leon' Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-dfc62bc51fd10e15afc9a11c29a21438 class=toggle>
<label for=section-dfc62bc51fd10e15afc9a11c29a21438 class="flex justify-between"><a role=button>Java</a></label><ul><li><a href=/docs/Java/Agent/>Agent</a></li><li><a href=/docs/Java/Cleaner/>Cleaner 类</a></li><li><a href=/docs/Java/JDBC/>JDBC</a></li><li><a href=/docs/Java/MethodHandles/>MethodHandles</a></li><li><a href=/docs/Java/DynamicProxy/>动态代理</a></li></ul></li><li><input type=checkbox id=section-068f5864eab5429f74d44490ac7dda4f class=toggle checked>
<label for=section-068f5864eab5429f74d44490ac7dda4f class="flex justify-between"><a role=button>boltdb</a></label><ul><li><a href=/docs/boltdb/introduction/ class=active>boltdb 介绍</a></li><li><a href=/docs/boltdb/transaction/>boltdb 事务</a></li><li><a href=/docs/boltdb/bucket/>boltdb 介绍</a></li><li><a href=/docs/boltdb/storage/>boltdb 存储</a></li><li><a href=/docs/boltdb/page/>boltdb 页结构</a></li></ul></li><li><input type=checkbox id=section-dd174040a908659982d53d695ff59f6c class=toggle>
<label for=section-dd174040a908659982d53d695ff59f6c class="flex justify-between"><a role=button>JVM</a></label><ul><li><a href=/docs/JVM/AsmTools/>AsmTools</a></li><li><a href=/docs/JVM/loading-linking-initializing/>JVM 加载-链接-初始化</a></li><li><input type=checkbox id=section-8116e10cba9ea1a7d22332ccf696967c class=toggle>
<label for=section-8116e10cba9ea1a7d22332ccf696967c class="flex justify-between"><a role=button>字节码</a></label><ul><li><a href=/docs/JVM/ByteCode/ClassFile/>Class 文件结构</a></li><li><a href=/docs/JVM/ByteCode/constant_pool/>常量池</a></li></ul></li></ul></li><li><input type=checkbox id=section-322adad93406759f98a33491e2ecc8af class=toggle>
<label for=section-322adad93406759f98a33491e2ecc8af class="flex justify-between"><a role=button>Linux 网络编程</a></label><ul><li><a href=/docs/system-programming/network-byte-order/>网络字节序</a></li><li><a href=/docs/system-programming/address-families/>网络地址族</a></li><li><a href=/docs/system-programming/block-and-nonblock-io/>（非）阻塞 I/O</a></li><li><a href=/docs/system-programming/multiplexing/>I/O 多路复用</a></li><li><a href=/docs/system-programming/reactor-pattern/>Reactor 模型</a></li><li><a href=/docs/system-programming/sockets/>套接字（socket）</a></li><li><a href=/docs/system-programming/echo-server/>echo 服务器</a></li></ul></li><li><input type=checkbox id=section-bcab9cce661800a90eaf0ba45525a392 class=toggle>
<label for=section-bcab9cce661800a90eaf0ba45525a392 class="flex justify-between"><a role=button>MapDB</a></label><ul><li><a href=/docs/MapDB/BTree/>BTree</a></li></ul></li><li><input type=checkbox id=section-be784f006af4b056e801791bd4131884 class=toggle>
<label for=section-be784f006af4b056e801791bd4131884 class="flex justify-between"><a role=button>MyBatis</a></label><ul><li><a href=/docs/MyBatis/SqlSession/>SqlSession</a></li><li><a href=/docs/MyBatis/Mapper/>Mapper</a></li><li><a href=/docs/MyBatis/ResultSetHandler/>ResultSetHandler</a></li><li><a href=/docs/MyBatis/StatementHandler/>StatementHandler</a></li><li><a href=/docs/MyBatis/Executor/>Executor</a></li><li><a href=/docs/MyBatis/Cache/>Cache</a></li></ul></li><li><input type=checkbox id=section-8e8ae3b760618e1158c1946d2d023ca5 class=toggle>
<label for=section-8e8ae3b760618e1158c1946d2d023ca5 class="flex justify-between"><a role=button>Netty</a></label><ul><li><a href=/docs/Netty/ByteBuf/>ByteBuf</a></li><li><a href=/docs/Netty/EventLoop/>EventLoop</a></li><li><a href=/docs/Netty/EventLoopGroup/>EventLoopGroup</a></li><li><a href=/docs/Netty/Channel/>Channel</a></li><li><a href=/docs/Netty/ChannelHandler/>ChannelHandler</a></li><li><a href=/docs/Netty/encoder-and-decoder/>编码器和解码器</a></li></ul></li><li><input type=checkbox id=section-bccb031e3769927ed8f05e90efe74959 class=toggle>
<label for=section-bccb031e3769927ed8f05e90efe74959 class="flex justify-between"><a role=button>Pro Git</a></label><ul><li><a href=/docs/ProGit/Git-%E5%9F%BA%E7%A1%80/>Git 基础</a></li><li><a href=/docs/ProGit/Git-%E5%88%86%E6%94%AF/>Git 分支</a></li></ul></li><li><span>计算机网络</span><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>boltdb 介绍</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#boltdb-介绍>boltdb 介绍</a><ul><li><a href=#打开数据库>打开数据库</a></li><li><a href=#事务>事务</a><ul><li><a href=#读写事务>读写事务</a></li><li><a href=#只读事务>只读事务</a></li><li><a href=#批量读写事务>批量读写事务</a></li><li><a href=#手动管理事务>手动管理事务</a></li></ul></li><li><a href=#使用桶>使用桶</a></li><li><a href=#使用-kv-对>使用 KV 对</a></li><li><a href=#桶的自增整数>桶的自增整数</a></li><li><a href=#迭代-key>迭代 key</a><ul><li><a href=#前缀扫描>前缀扫描</a></li><li><a href=#范围扫描>范围扫描</a></li><li><a href=#foreach>ForEach()</a></li></ul></li><li><a href=#嵌套桶>嵌套桶</a></li><li><a href=#数据库备份>数据库备份</a></li><li><a href=#统计>统计</a></li><li><a href=#只读模式>只读模式</a></li><li><a href=#注意事项>注意事项</a></li><li><a href=#阅读源代码>阅读源代码</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=boltdb-介绍>boltdb 介绍
<a class=anchor href=#boltdb-%e4%bb%8b%e7%bb%8d>#</a></h1><blockquote><p><a href=https://github.com/boltdb/bolt>https://github.com/boltdb/bolt</a></p></blockquote><p>boltdb 是一个使用 Go 语言开发的 KV 存储库。该项目的目标是为那些不需要完整数据库服务器（如：Postgres或MySQL）的项目提供一个简单、快速且可靠的数据库。</p><blockquote><p>boltdb 目前已不再维护，CoreOS fork 了该项目，并继续维护
<a href=https://github.com/etcd-io/bbolt>bbolt</a>。</p></blockquote><h2 id=打开数据库>打开数据库
<a class=anchor href=#%e6%89%93%e5%bc%80%e6%95%b0%e6%8d%ae%e5%ba%93>#</a></h2><p>boltdb 中的顶层对象是 <code>DB</code>。它在磁盘上表示为一个单一文件，并且代表了数据的一个一致性快照。</p><p>要打开数据库，只需使用 <code>bolt.Open()</code> 函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;log&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;github.com/boltdb/bolt&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Open the my.db data file in your current directory.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// It will be created if it doesn&#39;t exist.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>db</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bolt</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#e6db74>&#34;my.db&#34;</span>, <span style=color:#ae81ff>0600</span>, <span style=color:#66d9ef>nil</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Close</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>请注意，boltdb 会对数据文件加锁，因此多个进程不能同时打开同一个数据库。尝试打开一个已经被打开的 boltdb 数据库将导致程序挂起，直到其他进程关闭该数据库。为了防止无限期等待，可以为 <code>Open()</code> 函数传递一个超时选项：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#a6e22e>db</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bolt</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#e6db74>&#34;my.db&#34;</span>, <span style=color:#ae81ff>0600</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>bolt</span>.<span style=color:#a6e22e>Options</span>{<span style=color:#a6e22e>Timeout</span>: <span style=color:#ae81ff>1</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>})
</span></span></code></pre></div><h2 id=事务>事务
<a class=anchor href=#%e4%ba%8b%e5%8a%a1>#</a></h2><p>boltdb 一次只允许一个读写事务（transaction），同时允许任意数量的只读事务。每个事务在开始时都有一个一致的数据视图，即该事务开始时的数据状态。</p><p>单个事务以及从它们创建的所有对象（例如：桶、键）都不是线程安全的。如果要在多个 goroutine 中处理数据，必须为每个 goroutine 启动一个事务，或者使用锁机制以确保同一时刻内只有一个 goroutine 访问事务。从 <code>DB</code> 创建事务是线程安全的。</p><p>只读事务和读写事务不应相互依赖，通常也不应在同一个 goroutine 中同时打开。这可能会导致死锁，因为读写事务需要定期重新映射数据文件，但在有只读事务打开时无法进行此操作。</p><h3 id=读写事务>读写事务
<a class=anchor href=#%e8%af%bb%e5%86%99%e4%ba%8b%e5%8a%a1>#</a></h3><p>为开启一个读写事务，可以使用 <code>DB.Update()</code> 方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Update</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>tx</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bolt</span>.<span style=color:#a6e22e>Tx</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>在闭包内部，将拥有数据库的一致性视图。通过在函数结尾处返回 <code>nil</code> 来提交事务。也可以在任何时候通过返回一个错误来回滚事务。在读写事务中，所有数据库操作都是允许的。</p><p>始终检查返回的错误，因为它会报告任何可能导致事务未完成的磁盘故障。如果在闭包中返回一个错误，该错误将会被传递出去。</p><h3 id=只读事务>只读事务
<a class=anchor href=#%e5%8f%aa%e8%af%bb%e4%ba%8b%e5%8a%a1>#</a></h3><p>为开启一个只读事务，可以使用 <code>DB.View()</code> 方法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>View</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>tx</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bolt</span>.<span style=color:#a6e22e>Tx</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>在这个闭包中，同样会获得数据库的一致性视图，但在只读事务中不允许进行任何修改操作。只能在只读事务中检索桶（bucket）、检索值以及复制数据库。</p><h3 id=批量读写事务>批量读写事务
<a class=anchor href=#%e6%89%b9%e9%87%8f%e8%af%bb%e5%86%99%e4%ba%8b%e5%8a%a1>#</a></h3><p>每次调用 <code>DB.Update()</code> 都会等待磁盘提交写入操作。这种开销可以通过使用 <code>DB.Batch()</code> 函数将多个更新操作组合在一起来提升写入性能。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Batch</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>tx</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bolt</span>.<span style=color:#a6e22e>Tx</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>并发的 Batch 调用会被机会性地（opportunistically）组合成更大的事务。Batch 只有在多个 goroutine 调用时才有用。</p><blockquote><p>当有多个 Batch 同时调用时，系统会尝试将这些并发的 Batch 调用合并成一个更大的事务，以减少磁盘写入的开销。</p><p>Batch 功能主要在存在多个 goroutine 并发调用时才发挥作用，如果只有一个 goroutine 调用 Batch，则合并的效果不明显。</p></blockquote><p>代价是，如果事务的某些部分失败，Batch 可能会多次调用给定的函数。因此，该函数必须是幂等的，并且副作用只能在 <code>DB.Batch()</code> 成功返回后生效。</p><p>例如：不要在函数内部显示消息，而应在外层作用域中设置变量。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>id</span> <span style=color:#66d9ef>uint64</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Batch</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>tx</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bolt</span>.<span style=color:#a6e22e>Tx</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Find last key in bucket, decode as bigendian uint64, increment
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#75715e>// by one, encode back to []byte, and add new key.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>id</span> = <span style=color:#a6e22e>newValue</span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>})
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;Allocated ID %d&#34;</span>, <span style=color:#a6e22e>id</span>)
</span></span></code></pre></div><h3 id=手动管理事务>手动管理事务
<a class=anchor href=#%e6%89%8b%e5%8a%a8%e7%ae%a1%e7%90%86%e4%ba%8b%e5%8a%a1>#</a></h3><p><code>DB.View()</code> 和 <code>DB.Update()</code> 函数是 <code>DB.Begin()</code> 函数的包装器。这些辅助函数会启动事务，执行一个函数，然后如果返回了错误，安全地关闭事务。这是推荐使用 boltdb 事务的方式。</p><p>不过，有时可能希望手动启动和结束事务。可以直接使用 <code>DB.Begin()</code> 函数，但请务必确保关闭事务。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#75715e>// Start a writable transaction.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>tx</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Begin</span>(<span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>Rollback</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Use the transaction...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>CreateBucket</span>([]byte(<span style=color:#e6db74>&#34;MyBucket&#34;</span>))
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Commit the transaction and check for error.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>Commit</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>DB.Begin()</code> 的第一个参数是一个布尔值，用于指示事务是否应该是可写的。</p><ul><li>如果传递 <code>true</code>，则表示要创建一个可写事务（读写事务），允许对数据库进行修改。</li><li>如果传递 <code>false</code>，则表示要创建一个只读事务，只能读取数据而不能修改数据。</li></ul><h2 id=使用桶>使用桶
<a class=anchor href=#%e4%bd%bf%e7%94%a8%e6%a1%b6>#</a></h2><p>桶（Buckets）是数据库中键值对的集合。桶中的所有键必须是唯一的。可以使用 <code>DB.CreateBucket()</code> 函数来创建一个桶：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Update</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>tx</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bolt</span>.<span style=color:#a6e22e>Tx</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>CreateBucket</span>([]byte(<span style=color:#e6db74>&#34;MyBucket&#34;</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;create bucket: %s&#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>可以使用 <code>Tx.CreateBucketIfNotExists()</code> 函数在桶不存在时创建它。这是一个常见的模式，即在打开数据库后，为所有顶级桶调用此函数，以确保它们在未来的事务中存在。</p><p>要删除一个桶，只需调用 <code>Tx.DeleteBucket()</code> 函数。</p><h2 id=使用-kv-对>使用 KV 对
<a class=anchor href=#%e4%bd%bf%e7%94%a8-kv-%e5%af%b9>#</a></h2><p>要将键值对保存到一个桶中，请使用 <code>Bucket.Put()</code> 函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Update</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>tx</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bolt</span>.<span style=color:#a6e22e>Tx</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>Bucket</span>([]byte(<span style=color:#e6db74>&#34;MyBucket&#34;</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Put</span>([]byte(<span style=color:#e6db74>&#34;answer&#34;</span>), []byte(<span style=color:#e6db74>&#34;42&#34;</span>))
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>这将把 <code>answer</code> 键的值设置为 <code>42</code> 在 <code>MyBucket</code> 桶中。要检索这个值，可以使用 <code>Bucket.Get()</code> 函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>View</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>tx</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bolt</span>.<span style=color:#a6e22e>Tx</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>Bucket</span>([]byte(<span style=color:#e6db74>&#34;MyBucket&#34;</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Get</span>([]byte(<span style=color:#e6db74>&#34;answer&#34;</span>))
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;The answer is: %s\n&#34;</span>, <span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p><code>Get()</code> 函数不会返回错误，因为其操作是保证有效的（除非发生系统故障）。如果键存在，它将返回其字节切片值。如果键不存在，它将返回 <code>nil</code>。需要注意的是，可以将零长度的值设置到一个键上，这与键不存在是不同的。</p><p>要从桶中删除一个键，请使用 <code>Bucket.Delete()</code> 函数。</p><p>请注意，从 <code>Get()</code> 返回的值仅在事务打开时有效。如果需要在事务外使用该值，则必须使用 <code>copy()</code> 将其复制到另一个字节切片中。</p><h2 id=桶的自增整数>桶的自增整数
<a class=anchor href=#%e6%a1%b6%e7%9a%84%e8%87%aa%e5%a2%9e%e6%95%b4%e6%95%b0>#</a></h2><p>通过使用 <code>NextSequence()</code> 函数，可以让 boltdb 确定一个序列，用作 KV 对的唯一标识符。请参见下面的示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#75715e>// CreateUser saves u to the store. The new user ID is set on u once the data is persisted.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>s</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Store</span>) <span style=color:#a6e22e>CreateUser</span>(<span style=color:#a6e22e>u</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>User</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>s</span>.<span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Update</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>tx</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bolt</span>.<span style=color:#a6e22e>Tx</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Retrieve the users bucket.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// This should be created when the DB is first opened.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>Bucket</span>([]byte(<span style=color:#e6db74>&#34;users&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Generate ID for the user.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// This returns an error only if the Tx is closed or not writeable.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// That can&#39;t happen in an Update() call so I ignore the error check.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>id</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>NextSequence</span>()
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>ID</span> = int(<span style=color:#a6e22e>id</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Marshal user data into bytes.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>buf</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>u</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Persist bytes to users bucket.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Put</span>(<span style=color:#a6e22e>itob</span>(<span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>ID</span>), <span style=color:#a6e22e>buf</span>)
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// itob returns an 8-byte big endian representation of v.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>itob</span>(<span style=color:#a6e22e>v</span> <span style=color:#66d9ef>int</span>) []<span style=color:#66d9ef>byte</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>byte</span>, <span style=color:#ae81ff>8</span>)
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>binary</span>.<span style=color:#a6e22e>BigEndian</span>.<span style=color:#a6e22e>PutUint64</span>(<span style=color:#a6e22e>b</span>, uint64(<span style=color:#a6e22e>v</span>))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>User</span> <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ID</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=迭代-key>迭代 key
<a class=anchor href=#%e8%bf%ad%e4%bb%a3-key>#</a></h2><p>boltdb 将其键按字节排序存储在桶内。这使得对这些键的顺序遍历非常快速。要遍历键，我们将使用 <code>Cursor</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>View</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>tx</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bolt</span>.<span style=color:#a6e22e>Tx</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Assume bucket exists and has keys
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>Bucket</span>([]byte(<span style=color:#e6db74>&#34;MyBucket&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>Cursor</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>First</span>(); <span style=color:#a6e22e>k</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span>; <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Next</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;key=%s, value=%s\n&#34;</span>, <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>游标允许你移动到键列表中的特定位置，并一次一个地向前或向后遍历这些键。</p><p>游标上提供了以下函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#a6e22e>First</span>()  <span style=color:#a6e22e>Move</span> <span style=color:#a6e22e>to</span> <span style=color:#a6e22e>the</span> <span style=color:#a6e22e>first</span> <span style=color:#a6e22e>key</span>.
</span></span><span style=display:flex><span><span style=color:#a6e22e>Last</span>()   <span style=color:#a6e22e>Move</span> <span style=color:#a6e22e>to</span> <span style=color:#a6e22e>the</span> <span style=color:#a6e22e>last</span> <span style=color:#a6e22e>key</span>.
</span></span><span style=display:flex><span><span style=color:#a6e22e>Seek</span>()   <span style=color:#a6e22e>Move</span> <span style=color:#a6e22e>to</span> <span style=color:#a6e22e>a</span> <span style=color:#a6e22e>specific</span> <span style=color:#a6e22e>key</span>.
</span></span><span style=display:flex><span><span style=color:#a6e22e>Next</span>()   <span style=color:#a6e22e>Move</span> <span style=color:#a6e22e>to</span> <span style=color:#a6e22e>the</span> <span style=color:#a6e22e>next</span> <span style=color:#a6e22e>key</span>.
</span></span><span style=display:flex><span><span style=color:#a6e22e>Prev</span>()   <span style=color:#a6e22e>Move</span> <span style=color:#a6e22e>to</span> <span style=color:#a6e22e>the</span> <span style=color:#a6e22e>previous</span> <span style=color:#a6e22e>key</span>.
</span></span></code></pre></div><p>每个函数的返回签名为 <code>(key []byte, value []byte)</code>。当你遍历到游标的末尾时，<code>Next()</code> 将返回一个 <code>nil</code> 键。你必须使用 <code>First()</code>、<code>Last()</code> 或 <code>Seek()</code> 来定位一个位置，然后再调用 <code>Next()</code> 或 <code>Prev()</code>。如果不进行定位，这些函数将返回 <code>nil</code> 键。</p><p>在迭代过程中，如果键是非 <code>nil</code> 但值是 <code>nil</code>，这意味着该键指向的是一个桶而不是值。可以使用 <code>Bucket.Bucket()</code> 来访问子桶。</p><h3 id=前缀扫描>前缀扫描
<a class=anchor href=#%e5%89%8d%e7%bc%80%e6%89%ab%e6%8f%8f>#</a></h3><p>要遍历一个键前缀，你可以结合使用 <code>Seek()</code> 和 <code>bytes.HasPrefix()</code>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>View</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>tx</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bolt</span>.<span style=color:#a6e22e>Tx</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Assume bucket exists and has keys
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>Bucket</span>([]byte(<span style=color:#e6db74>&#34;MyBucket&#34;</span>)).<span style=color:#a6e22e>Cursor</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>prefix</span> <span style=color:#f92672>:=</span> []byte(<span style=color:#e6db74>&#34;1234&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Seek</span>(<span style=color:#a6e22e>prefix</span>); <span style=color:#a6e22e>k</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>HasPrefix</span>(<span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>prefix</span>); <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Next</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;key=%s, value=%s\n&#34;</span>, <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><h3 id=范围扫描>范围扫描
<a class=anchor href=#%e8%8c%83%e5%9b%b4%e6%89%ab%e6%8f%8f>#</a></h3><p>另一个常见的用例是扫描一个范围，比如时间范围。如果你使用可排序的时间编码，例如 RFC3339，你可以这样查询特定的日期范围：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>View</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>tx</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bolt</span>.<span style=color:#a6e22e>Tx</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Assume our events bucket exists and has RFC3339 encoded time keys.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>Bucket</span>([]byte(<span style=color:#e6db74>&#34;Events&#34;</span>)).<span style=color:#a6e22e>Cursor</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Our time range spans the 90&#39;s decade.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>min</span> <span style=color:#f92672>:=</span> []byte(<span style=color:#e6db74>&#34;1990-01-01T00:00:00Z&#34;</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>max</span> <span style=color:#f92672>:=</span> []byte(<span style=color:#e6db74>&#34;2000-01-01T00:00:00Z&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Iterate over the 90&#39;s.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>for</span> <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Seek</span>(<span style=color:#a6e22e>min</span>); <span style=color:#a6e22e>k</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>bytes</span>.<span style=color:#a6e22e>Compare</span>(<span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>max</span>) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span> = <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Next</span>() {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%s: %s\n&#34;</span>, <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><p>请注意，虽然 RFC3339 是可排序的，但 Go 对 RFC3339Nano 的实现并不使用固定的十进制点后数字位数，因此不可排序。</p><h3 id=foreach>ForEach()
<a class=anchor href=#foreach>#</a></h3><p>如果你需要遍历桶中的所有键，也可以使用 <code>ForEach()</code> 函数：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>View</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>tx</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bolt</span>.<span style=color:#a6e22e>Tx</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Assume bucket exists and has keys
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>Bucket</span>([]byte(<span style=color:#e6db74>&#34;MyBucket&#34;</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>ForEach</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span> []<span style=color:#66d9ef>byte</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;key=%s, value=%s\n&#34;</span>, <span style=color:#a6e22e>k</span>, <span style=color:#a6e22e>v</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>})
</span></span></code></pre></div><h2 id=嵌套桶>嵌套桶
<a class=anchor href=#%e5%b5%8c%e5%a5%97%e6%a1%b6>#</a></h2><p>你也可以将一个桶存储在一个键中，以创建嵌套桶。其 API 与 <code>DB</code> 对象上的桶管理 API 相同：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>Bucket</span>) <span style=color:#a6e22e>CreateBucket</span>(<span style=color:#a6e22e>key</span> []<span style=color:#66d9ef>byte</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Bucket</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>Bucket</span>) <span style=color:#a6e22e>CreateBucketIfNotExists</span>(<span style=color:#a6e22e>key</span> []<span style=color:#66d9ef>byte</span>) (<span style=color:#f92672>*</span><span style=color:#a6e22e>Bucket</span>, <span style=color:#66d9ef>error</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>Bucket</span>) <span style=color:#a6e22e>DeleteBucket</span>(<span style=color:#a6e22e>key</span> []<span style=color:#66d9ef>byte</span>) <span style=color:#66d9ef>error</span>
</span></span></code></pre></div><p>假设你有一个多租户应用程序，其中根级别的桶是账户桶。在这个桶内部有一个账户序列，这些账户本身是桶。在这个序列桶内部，你可以有许多与账户本身相关的桶（如用户、笔记等），将信息隔离成逻辑上的分组。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#75715e>// createUser creates a new user in the given account.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>createUser</span>(<span style=color:#a6e22e>accountID</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>u</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>User</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Start the transaction.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>tx</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Begin</span>(<span style=color:#66d9ef>true</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>Rollback</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Retrieve the root bucket for the account.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Assume this has already been created when the account was set up.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>root</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>Bucket</span>([]byte(<span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>FormatUint</span>(<span style=color:#a6e22e>accountID</span>, <span style=color:#ae81ff>10</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Setup the users bucket.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>bkt</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>root</span>.<span style=color:#a6e22e>CreateBucketIfNotExists</span>([]byte(<span style=color:#e6db74>&#34;USERS&#34;</span>))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Generate an ID for the new user.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>userID</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bkt</span>.<span style=color:#a6e22e>NextSequence</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>ID</span> = <span style=color:#a6e22e>userID</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Marshal and save the encoded user.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>buf</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>u</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bkt</span>.<span style=color:#a6e22e>Put</span>([]byte(<span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>FormatUint</span>(<span style=color:#a6e22e>u</span>.<span style=color:#a6e22e>ID</span>, <span style=color:#ae81ff>10</span>)), <span style=color:#a6e22e>buf</span>); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Commit the transaction.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>Commit</span>(); <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=数据库备份>数据库备份
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e5%a4%87%e4%bb%bd>#</a></h2><p>boltdb 是一个单文件，因此易于备份。你可以使用 <code>Tx.WriteTo()</code> 函数将数据库的一致视图写入到 <code>Writer</code> 中。如果在只读事务中调用它，它将执行热备份，而不会阻塞其他数据库的读取和写入操作。</p><p>默认情况下，它将使用常规文件句柄，这将利用操作系统的页面缓存。有关优化大于 RAM 数据集的信息，请参阅 <code>Tx</code> 文档。</p><p>一个常见的用例是通过 HTTP 进行备份，这样你可以使用像 <code>cURL</code> 这样的工具来进行数据库备份。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>BackupHandleFunc</span>(<span style=color:#a6e22e>w</span> <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>ResponseWriter</span>, <span style=color:#a6e22e>req</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Request</span>) {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>View</span>(<span style=color:#66d9ef>func</span>(<span style=color:#a6e22e>tx</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>bolt</span>.<span style=color:#a6e22e>Tx</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Header</span>().<span style=color:#a6e22e>Set</span>(<span style=color:#e6db74>&#34;Content-Type&#34;</span>, <span style=color:#e6db74>&#34;application/octet-stream&#34;</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Header</span>().<span style=color:#a6e22e>Set</span>(<span style=color:#e6db74>&#34;Content-Disposition&#34;</span>, <span style=color:#e6db74>`attachment; filename=&#34;my.db&#34;`</span>)
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>w</span>.<span style=color:#a6e22e>Header</span>().<span style=color:#a6e22e>Set</span>(<span style=color:#e6db74>&#34;Content-Length&#34;</span>, <span style=color:#a6e22e>strconv</span>.<span style=color:#a6e22e>Itoa</span>(int(<span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>Size</span>())))
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>tx</span>.<span style=color:#a6e22e>WriteTo</span>(<span style=color:#a6e22e>w</span>)
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>	})
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>Error</span>(<span style=color:#a6e22e>w</span>, <span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>Error</span>(), <span style=color:#a6e22e>http</span>.<span style=color:#a6e22e>StatusInternalServerError</span>)
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>可以使用下边的命令进行备份：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>$</span> <span style=color:#a6e22e>curl</span> <span style=color:#a6e22e>http</span>:<span style=color:#75715e>//localhost/backup &gt; my.db
</span></span></span></code></pre></div><p>或者你可以打开浏览器访问 <code>http://localhost/backup</code>，它将自动下载。</p><p>如果你想备份到另一个文件，可以使用 <code>Tx.CopyFile()</code> 辅助函数。</p><h2 id=统计>统计
<a class=anchor href=#%e7%bb%9f%e8%ae%a1>#</a></h2><p>数据库会持续跟踪许多内部操作的计数，以便你更好地了解发生了什么。通过在两个时间点捕获这些统计信息的快照，我们可以看到在这段时间范围内执行了哪些操作。</p><p>例如，我们可以启动一个 goroutine，每 10 秒记录一次统计信息：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#66d9ef>go</span> <span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>	<span style=color:#75715e>// Grab the initial stats.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>prev</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Stats</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>for</span> {
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Wait for 10s.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Sleep</span>(<span style=color:#ae81ff>10</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Second</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Grab the current stats and diff them.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>stats</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>Stats</span>()
</span></span><span style=display:flex><span>		<span style=color:#a6e22e>diff</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>stats</span>.<span style=color:#a6e22e>Sub</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>prev</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Encode stats to JSON and print to STDERR.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>NewEncoder</span>(<span style=color:#a6e22e>os</span>.<span style=color:#a6e22e>Stderr</span>).<span style=color:#a6e22e>Encode</span>(<span style=color:#a6e22e>diff</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>		<span style=color:#75715e>// Save stats for the next loop.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		<span style=color:#a6e22e>prev</span> = <span style=color:#a6e22e>stats</span>
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}()
</span></span></code></pre></div><p>将这些统计信息传送到像 statsd 这样的服务进行监控，或者提供一个 HTTP 端点以执行固定长度的采样，也是非常有用的。</p><h2 id=只读模式>只读模式
<a class=anchor href=#%e5%8f%aa%e8%af%bb%e6%a8%a1%e5%bc%8f>#</a></h2><p>有时候创建一个共享的只读 boltdb 数据库是很有用的。为此，在打开数据库时设置 <code>Options.ReadOnly</code> 标志。只读模式使用共享锁来允许多个进程从数据库中读取，但会阻止任何进程以读写模式打开数据库。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Go data-lang=Go><span style=display:flex><span><span style=color:#a6e22e>db</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bolt</span>.<span style=color:#a6e22e>Open</span>(<span style=color:#e6db74>&#34;my.db&#34;</span>, <span style=color:#ae81ff>0666</span>, <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>bolt</span>.<span style=color:#a6e22e>Options</span>{<span style=color:#a6e22e>ReadOnly</span>: <span style=color:#66d9ef>true</span>})
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>log</span>.<span style=color:#a6e22e>Fatal</span>(<span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=注意事项>注意事项
<a class=anchor href=#%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9>#</a></h2><p>选择合适的工具非常重要，boltdb 也不例外。在评估和使用 boltdb 时，请注意以下几点：</p><ul><li><p><strong>boltdb 适合读取密集型工作负载</strong>。顺序写入性能也很快，但随机写入可能会很慢。你可以使用 <code>DB.Batch()</code> 或添加写前日志来帮助缓解这个问题。</p></li><li><p><strong>boltdb 内部使用 B+ 树</strong>，所以可能会有很多随机页面访问。相比旋转磁盘，SSD 能显著提高性能。</p></li><li><p><strong>尽量避免长时间运行的读取事务</strong>。boltdb 使用写时复制，所以在旧事务使用旧页面时，旧页面无法被回收。</p></li><li><p><strong>从 boltdb 返回的字节切片</strong> 只在事务期间有效。一旦事务已提交或回滚，它们指向的内存可能会被新页面重用或从虚拟内存中取消映射，当访问时可能会出现意外的地址错误。</p></li><li><p><strong>boltdb 在数据库文件上使用独占写锁</strong>，因此无法被多个进程共享。</p></li><li><p><strong>使用 <code>Bucket.FillPercent</code> 时要小心</strong>。对具有随机插入的桶设置较高的填充百分比会导致数据库的页面利用率很差。</p></li><li><p><strong>通常使用较大的桶</strong>。较小的桶在超过页面大小（通常为 4KB）后会导致页面利用率差。</p></li><li><p><strong>向新桶中批量加载大量随机写入</strong> 可能很慢，因为页面在事务提交之前不会拆分。在单个事务中随机插入超过 100,000 个键/值对到单个新桶是不建议的。</p></li><li><p><strong>boltdb 使用内存映射文件</strong>，因此底层操作系统处理数据的缓存。通常，操作系统会尽可能将文件缓存到内存中，并根据需要将内存释放给其他进程。这意味着，当处理大数据库时，boltdb 可能显示出非常高的内存使用量。然而，这是预期的，操作系统会根据需要释放内存。只要内存映射适合进程的虚拟地址空间，boltdb 可以处理比可用物理 RAM 大得多的数据库。在 32 位系统上可能会有问题。</p></li><li><p><strong>boltdb 数据库中的数据结构是内存映射的</strong>，所以数据文件将是特定字节序的。这意味着你不能将 boltdb 文件从小端机器复制到大端机器并使其正常工作。对于大多数用户来说，这不是问题，因为现代 CPU 大多是小端的。</p></li><li><p><strong>由于页面在磁盘上的布局方式，boltdb 不能截断数据文件并将空闲页面返回到磁盘</strong>。相反，boltdb 在其数据文件中维护一个未使用页面的空闲列表。这些空闲页面可以被后续事务重用。这对许多用例来说效果很好，因为数据库通常会增长。然而，重要的是要注意，删除大量数据不会允许你回收磁盘上的空间。</p></li></ul><p>对于页申请（page allocation）的信息，可以查看
<a href=https://github.com/boltdb/bolt/issues/308#issuecomment-74811638>此评论</a>。</p><h2 id=阅读源代码>阅读源代码
<a class=anchor href=#%e9%98%85%e8%af%bb%e6%ba%90%e4%bb%a3%e7%a0%81>#</a></h2><p>boltdb 是一个相对较小的代码库（&lt;3KLOC），用于嵌入式、可序列化、事务性的键/值数据库，因此对于对数据库工作原理感兴趣的人来说，它是一个很好的起点。</p><p>最好的入手点是 boltdb 的主要入口：</p><ul><li><p><code>Open()</code> - 初始化对数据库的引用。负责创建数据库（如果不存在的话）、获取文件的独占锁、读取元页面和内存映射文件。</p></li><li><p><code>DB.Begin()</code> - 根据 <code>writable</code> 参数的值启动只读或读写事务。这需要暂时获取“元”锁来跟踪打开的事务。一次只能存在一个读写事务，因此在读写事务期间会获取<code>rwlock</code>。</p></li><li><p><code>Bucket.Put()</code> - 将一个键/值对写入桶。在验证参数后，使用游标遍历 B+ 树到键和值将被写入的页面和位置。一旦找到位置，桶会将底层页面及其父页面加载到内存中作为“节点”。这些节点是读写事务期间发生变更的地方。这些更改会在提交时刷新到磁盘。</p></li><li><p><code>Bucket.Get()</code> - 从桶中检索一个键/值对。使用游标移动到键/值对的页面和位置。在只读事务期间，键和值数据作为对底层 mmap 文件的直接引用返回，因此没有分配开销。对于读写事务，这些数据可能引用 mmap 文件或内存中的节点值之一。</p></li><li><p><code>Cursor</code> - 这个对象用于遍历 B+ 树上的磁盘页面或内存节点。它可以定位到特定键，移动到第一个或最后一个值，或者向前或向后移动。游标处理 B+ 树的上下移动，对最终用户透明。</p></li><li><p><code>Tx.Commit()</code> - 将内存中的脏节点和空闲页面列表转换为要写入磁盘的页面。写入磁盘的过程分为两个阶段。首先，将脏页面写入磁盘并进行 <code>fsync()</code>。其次，写入一个新的元页面，并进行另一个 <code>fsync()</code>。这种两阶段写入确保了在崩溃事件中，部分写入的数据页面会被忽略，因为指向它们的元页面永远不会被写入。部分写入的元页面会被使无效，因为它们是带有校验和的。</p></li></ul></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#boltdb-介绍>boltdb 介绍</a><ul><li><a href=#打开数据库>打开数据库</a></li><li><a href=#事务>事务</a><ul><li><a href=#读写事务>读写事务</a></li><li><a href=#只读事务>只读事务</a></li><li><a href=#批量读写事务>批量读写事务</a></li><li><a href=#手动管理事务>手动管理事务</a></li></ul></li><li><a href=#使用桶>使用桶</a></li><li><a href=#使用-kv-对>使用 KV 对</a></li><li><a href=#桶的自增整数>桶的自增整数</a></li><li><a href=#迭代-key>迭代 key</a><ul><li><a href=#前缀扫描>前缀扫描</a></li><li><a href=#范围扫描>范围扫描</a></li><li><a href=#foreach>ForEach()</a></li></ul></li><li><a href=#嵌套桶>嵌套桶</a></li><li><a href=#数据库备份>数据库备份</a></li><li><a href=#统计>统计</a></li><li><a href=#只读模式>只读模式</a></li><li><a href=#注意事项>注意事项</a></li><li><a href=#阅读源代码>阅读源代码</a></li></ul></li></ul></nav></div></aside></main></body></html>