<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Netty on Leon' Blog</title><link>https://ileonli.github.io/docs/Netty/</link><description>Recent content in Netty on Leon' Blog</description><generator>Hugo</generator><language>en</language><atom:link href="https://ileonli.github.io/docs/Netty/index.xml" rel="self" type="application/rss+xml"/><item><title>ByteBuf</title><link>https://ileonli.github.io/docs/Netty/ByteBuf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/Netty/ByteBuf/</guid><description>ByteBuf # 基本结构 # +-------------------+------------------+------------------+-------------+ | discardable bytes | readable bytes | writable bytes | ... | | | (CONTENT) | | | +-------------------+------------------+------------------+-------------+ | | | | | 0 &amp;lt;= readerIndex &amp;lt;= writerIndex &amp;lt;= capacity maxCapacity 相关操作 # 有些方法会返回 this，以支持链式调用。
容量 # ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(); int capacity = buf.capacity();// 获取当前的容量 int maxCapacity = buf.maxCapacity();// 支持的最大容量，通常为 Integer.MAX_VALUE int readableBytes = buf.readableBytes();// writerIndex - readerIndex int writableBytes = buf.writableBytes();// capacity - writerIndex boolean readable; readable = buf.</description></item><item><title>EventLoop</title><link>https://ileonli.github.io/docs/Netty/EventLoop/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/Netty/EventLoop/</guid><description>EventLoop # 一旦注册，将处理 Channel 的所有 I/O 操作。一个 EventLoop 实例通常会处理多个 Channel，但这可能取决于实现细节和内部机制。
EventLoop 本质是一个单线程执行器，同时维护了一个 Selector。
EventLoop 由 Thread 驱动，且不会更改
try (EventLoop loop = new DefaultEventLoop()) { for (int i = 0; i &amp;lt; 3; i++) { loop.submit(() -&amp;gt; { for (int j = 0; j &amp;lt; 16; j++) { System.out.print(j + &amp;#34; &amp;#34;); } System.out.println(); }); } } 使用 EventLoop 的定时调度功能。
try (EventLoop loop = new DefaultEventLoop()) { ScheduledFuture&amp;lt;?&amp;gt; future = loop.</description></item><item><title>EventLoopGroup</title><link>https://ileonli.github.io/docs/Netty/EventLoopGroup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/Netty/EventLoopGroup/</guid><description> EventLoopGroup #</description></item><item><title>Channel</title><link>https://ileonli.github.io/docs/Netty/Channel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/Netty/Channel/</guid><description> Channel #</description></item><item><title>ChannelHandler</title><link>https://ileonli.github.io/docs/Netty/ChannelHandler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/Netty/ChannelHandler/</guid><description>ChannelHandler # ChannelHandler 共分为两类，ChannelInboundHandler 和 ChannelOutboundHandler。
ChannelInboundHandler： ChannelOutboundHandler： 常用 # ChannelHandlerAdapter ChannelInboundHandlerAdapter ChannelOutboundHandlerAdapter ChannelDuplexHandler Pipeline 执行顺序 # Inbound 是从 ChannelPipeline 头到尾部，Outbound 是从 ChannelPipeline 尾到头部。
生命周期 # handlerAdded new ChannelHandler() { @Override public void handlerAdded(ChannelHandlerContext ctx) throws Exception { } @Override public void handlerRemoved(ChannelHandlerContext ctx) throws Exception { } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { } } ChannelInboundHandler # ChannelInboundHandlerAdapter # ChannelInboundHandlerAdapter 中的所有方法默认会调用 ctx.fireChannel*() 传递到下一个 Handler。</description></item><item><title>编码器和解码器</title><link>https://ileonli.github.io/docs/Netty/encoder-and-decoder/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/Netty/encoder-and-decoder/</guid><description>编码器和解码器 # 编码器：将消息转换为适合于传输的格式（通常是字节流）。 解码器：将网络字节流转换为应用程序的消息格式。 因此，编码器处理出站数据，而解码器处理入站数据。
解码器 # 由于解码器是负责处理入站数据的，因此，解码器是 ChannelInboundHandler。
解码器主要有下边两种：
将字节解码为消息的 ByteToMessageDecoder 和 ReplayingDecoder。 将一种消息类型解码为另一种消息的 MessageToMessageDecoder。 ByteToMessageDecoder # ReplayingDecoder # ReplayingDecoder 扩展了 ByteToMessageDecoder 类，使得我们不必调用 readableBytes() 方法。它通过使用一个自定义的 ByteBuf 实现， ReplayingDecoderByteBuf，包装传入的 ByteBuf 实现了这一点，其将在内部执行该调用
MessageToMessageDecoder # 编码器 # 编解码器类 # 这些类同时实现了 ChannelInboundHandler 和 ChannelOutboundHandler 接口。
ByteToMessageCodec # MessageToMessageCodec # CombinedChannelDuplexHandler # CombinedChannelDuplexHandler 可将 ChannelInboundHandler 和 ChannelOutboundHandler 结合在一起。</description></item></channel></rss>