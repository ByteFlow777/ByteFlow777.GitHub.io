<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="ByteBuf # 基本结构 # +-------------------+------------------+------------------+-------------+ | discardable bytes | readable bytes | writable bytes | ... | | | (CONTENT) | | | +-------------------+------------------+------------------+-------------+ | | | | | 0 <= readerIndex <= writerIndex <= capacity maxCapacity 相关操作 # 有些方法会返回 this，以支持链式调用。
容量 # ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(); int capacity = buf.capacity();// 获取当前的容量 int maxCapacity = buf.maxCapacity();// 支持的最大容量，通常为 Integer.MAX_VALUE int readableBytes = buf.readableBytes();// writerIndex - readerIndex int writableBytes = buf.writableBytes();// capacity - writerIndex boolean readable; readable = buf."><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://ileonli.github.io/docs/Netty/ByteBuf/"><meta property="og:site_name" content="Leon' Blog"><meta property="og:title" content="ByteBuf"><meta property="og:description" content="ByteBuf # 基本结构 # +-------------------+------------------+------------------+-------------+ | discardable bytes | readable bytes | writable bytes | ... | | | (CONTENT) | | | +-------------------+------------------+------------------+-------------+ | | | | | 0 <= readerIndex <= writerIndex <= capacity maxCapacity 相关操作 # 有些方法会返回 this，以支持链式调用。
容量 # ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(); int capacity = buf.capacity();// 获取当前的容量 int maxCapacity = buf.maxCapacity();// 支持的最大容量，通常为 Integer.MAX_VALUE int readableBytes = buf.readableBytes();// writerIndex - readerIndex int writableBytes = buf.writableBytes();// capacity - writerIndex boolean readable; readable = buf."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2024-07-25T22:58:20+08:00"><title>ByteBuf | Leon' Blog</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.c4648f90e7f239143d6b1f74326dc2ce1794185b23b8cbbf3f813cfdf5d576ca.css integrity="sha256-xGSPkOfyORQ9ax90Mm3CzheUGFsjuMu/P4E8/fXVdso=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.d81b492b84e18364d8db53fb21e20a301c2ed758056ece81dd160337b1c1346e.js integrity="sha256-2BtJK4Thg2TY21P7IeIKMBwu11gFbs6B3RYDN7HBNG4=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-EL04QEY330"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EL04QEY330")}</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Leon' Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-dfc62bc51fd10e15afc9a11c29a21438 class=toggle>
<label for=section-dfc62bc51fd10e15afc9a11c29a21438 class="flex justify-between"><a role=button>Java</a></label><ul><li><a href=/docs/Java/Agent/>Agent</a></li><li><a href=/docs/Java/Cleaner/>Cleaner 类</a></li><li><a href=/docs/Java/JDBC/>JDBC</a></li><li><a href=/docs/Java/MethodHandles/>MethodHandles</a></li><li><a href=/docs/Java/DynamicProxy/>动态代理</a></li></ul></li><li><input type=checkbox id=section-dd174040a908659982d53d695ff59f6c class=toggle>
<label for=section-dd174040a908659982d53d695ff59f6c class="flex justify-between"><a role=button>JVM</a></label><ul><li><a href=/docs/JVM/AsmTools/>AsmTools</a></li><li><a href=/docs/JVM/loading-linking-initializing/>JVM 加载-链接-初始化</a></li><li><input type=checkbox id=section-8116e10cba9ea1a7d22332ccf696967c class=toggle>
<label for=section-8116e10cba9ea1a7d22332ccf696967c class="flex justify-between"><a role=button>字节码</a></label><ul><li><a href=/docs/JVM/ByteCode/ClassFile/>Class 文件结构</a></li><li><a href=/docs/JVM/ByteCode/constant_pool/>常量池</a></li></ul></li></ul></li><li><input type=checkbox id=section-322adad93406759f98a33491e2ecc8af class=toggle>
<label for=section-322adad93406759f98a33491e2ecc8af class="flex justify-between"><a role=button>Linux 网络编程</a></label><ul><li><a href=/docs/system-programming/network-byte-order/>网络字节序</a></li><li><a href=/docs/system-programming/address-families/>网络地址族</a></li><li><a href=/docs/system-programming/block-and-nonblock-io/>（非）阻塞 I/O</a></li><li><a href=/docs/system-programming/multiplexing/>I/O 多路复用</a></li><li><a href=/docs/system-programming/reactor-pattern/>Reactor 模型</a></li><li><a href=/docs/system-programming/sockets/>套接字（socket）</a></li><li><a href=/docs/system-programming/echo-server/>echo 服务器</a></li></ul></li><li><input type=checkbox id=section-be784f006af4b056e801791bd4131884 class=toggle>
<label for=section-be784f006af4b056e801791bd4131884 class="flex justify-between"><a role=button>MyBatis</a></label><ul><li><a href=/docs/MyBatis/SqlSession/>SqlSession</a></li><li><a href=/docs/MyBatis/ResultSetHandler/>ResultSetHandler</a></li><li><a href=/docs/MyBatis/StatementHandler/>StatementHandler</a></li><li><a href=/docs/MyBatis/Executor/>Executor</a></li><li><a href=/docs/MyBatis/Cache/>Cache</a></li></ul></li><li><input type=checkbox id=section-8e8ae3b760618e1158c1946d2d023ca5 class=toggle checked>
<label for=section-8e8ae3b760618e1158c1946d2d023ca5 class="flex justify-between"><a role=button>Netty</a></label><ul><li><a href=/docs/Netty/ByteBuf/ class=active>ByteBuf</a></li><li><a href=/docs/Netty/EventLoop/>EventLoop</a></li><li><a href=/docs/Netty/EventLoopGroup/>EventLoopGroup</a></li><li><a href=/docs/Netty/Channel/>Channel</a></li><li><a href=/docs/Netty/ChannelHandler/>ChannelHandler</a></li><li><a href=/docs/Netty/encoder-and-decoder/>编码器和解码器</a></li></ul></li><li><input type=checkbox id=section-bccb031e3769927ed8f05e90efe74959 class=toggle>
<label for=section-bccb031e3769927ed8f05e90efe74959 class="flex justify-between"><a role=button>Pro Git</a></label><ul><li><a href=/docs/ProGit/Git-%E5%9F%BA%E7%A1%80/>Git 基础</a></li><li><a href=/docs/ProGit/Git-%E5%88%86%E6%94%AF/>Git 分支</a></li></ul></li><li><span>计算机网络</span><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>ByteBuf</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#bytebuf>ByteBuf</a><ul><li><a href=#基本结构>基本结构</a></li><li><a href=#相关操作>相关操作</a><ul><li><a href=#容量>容量</a></li><li><a href=#读写>读写</a></li><li><a href=#派生>派生</a></li><li><a href=#读写指针>读写指针</a></li><li><a href=#丢弃字节>丢弃字节</a></li></ul></li><li><a href=#bytebufholder>ByteBufHolder</a></li><li><a href=#分类>分类</a><ul><li><a href=#heap-和-direct>Heap 和 Direct</a></li><li><a href=#pooled-和-unpooled>Pooled 和 Unpooled</a></li><li><a href=#safe-和-unsafe>Safe 和 Unsafe</a></li></ul></li><li><a href=#abstractbytebuf>AbstractByteBuf</a></li><li><a href=#bytebufallocator>ByteBufAllocator</a><ul><li><a href=#继承关系>继承关系</a></li><li><a href=#默认-allocator>默认 Allocator</a></li></ul></li><li><a href=#内存回收>内存回收</a></li><li><a href=#扩容逻辑>扩容逻辑</a><ul><li><a href=#ensurewritable0>ensureWritable0</a></li><li><a href=#calculatenewcapacity>calculateNewCapacity</a></li></ul></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=bytebuf>ByteBuf
<a class=anchor href=#bytebuf>#</a></h1><h2 id=基本结构>基本结构
<a class=anchor href=#%e5%9f%ba%e6%9c%ac%e7%bb%93%e6%9e%84>#</a></h2><pre tabindex=0><code>+-------------------+------------------+------------------+-------------+
| discardable bytes |  readable bytes  |  writable bytes  |     ...     |
|                   |     (CONTENT)    |                  |             |
+-------------------+------------------+------------------+-------------+
|                   |                  |                  |             |
0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity     maxCapacity
</code></pre><h2 id=相关操作>相关操作
<a class=anchor href=#%e7%9b%b8%e5%85%b3%e6%93%8d%e4%bd%9c>#</a></h2><p>有些方法会返回 <code>this</code>，以支持链式调用。</p><h3 id=容量>容量
<a class=anchor href=#%e5%ae%b9%e9%87%8f>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>ByteBuf buf <span style=color:#f92672>=</span> ByteBufAllocator.<span style=color:#a6e22e>DEFAULT</span>.<span style=color:#a6e22e>buffer</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> capacity <span style=color:#f92672>=</span> buf.<span style=color:#a6e22e>capacity</span>();<span style=color:#75715e>// 获取当前的容量</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> maxCapacity <span style=color:#f92672>=</span> buf.<span style=color:#a6e22e>maxCapacity</span>();<span style=color:#75715e>// 支持的最大容量，通常为 Integer.MAX_VALUE</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> readableBytes <span style=color:#f92672>=</span> buf.<span style=color:#a6e22e>readableBytes</span>();<span style=color:#75715e>// writerIndex - readerIndex</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> writableBytes <span style=color:#f92672>=</span> buf.<span style=color:#a6e22e>writableBytes</span>();<span style=color:#75715e>// capacity - writerIndex</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>boolean</span> readable;
</span></span><span style=display:flex><span>readable <span style=color:#f92672>=</span> buf.<span style=color:#a6e22e>isReadable</span>(8);<span style=color:#75715e>// isReadable(int), writerIndex - readerIndex &gt;= size</span>
</span></span><span style=display:flex><span>readable <span style=color:#f92672>=</span> buf.<span style=color:#a6e22e>isReadable</span>();<span style=color:#75715e>// 相当于 isReadable(1)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>boolean</span> writable;
</span></span><span style=display:flex><span>writable <span style=color:#f92672>=</span> buf.<span style=color:#a6e22e>isWritable</span>(8); <span style=color:#75715e>// isWritable(int), capacity - writerIndex &gt;= size</span>
</span></span><span style=display:flex><span>writable <span style=color:#f92672>=</span> buf.<span style=color:#a6e22e>isWritable</span>(); <span style=color:#75715e>// 相当于 isWritable(1)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> maxWritableBytes <span style=color:#f92672>=</span> buf.<span style=color:#a6e22e>maxWritableBytes</span>();<span style=color:#75715e>// maxCapacity - writerIndex</span>
</span></span></code></pre></div><h3 id=读写>读写
<a class=anchor href=#%e8%af%bb%e5%86%99>#</a></h3><p><code>readType()</code> 用于读取 <code>Type</code> 类型的数据，<code>writeType()</code> 用于写入 <code>Type</code> 类型的值。</p><p>与 <code>readType()</code> 类似的有 <code>getType()</code>，与 <code>writeType()</code> 类似的有 <code>setType()</code>。唯一的区别是 <code>getType()</code> 和 <code>setType()</code> 不会改变读写指针，而 <code>readType()</code> 和 <code>writeType()</code>会改变读写指针。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>ByteBuf buf <span style=color:#f92672>=</span> ByteBufAllocator.<span style=color:#a6e22e>DEFAULT</span>.<span style=color:#a6e22e>buffer</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>boolean</span> booleanV <span style=color:#f92672>=</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>writeBoolean</span>(booleanV); <span style=color:#75715e>// 8-bit</span>
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>readBoolean</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>byte</span> byteV <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>writeByte</span>(byteV); <span style=color:#75715e>// 8-bit</span>
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>readByte</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>short</span> shortV <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>writeShort</span>(shortV); <span style=color:#75715e>// 16-bit</span>
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>readShort</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> mediumV <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>writeMedium</span>(mediumV); <span style=color:#75715e>// 24-bit</span>
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>readMedium</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> intV <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>writeInt</span>(intV); <span style=color:#75715e>// 32-bit</span>
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>readInt</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>long</span> longV <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>writeLong</span>(longV); <span style=color:#75715e>// 64-bit</span>
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>readLong</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> charV <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>writeChar</span>(charV); <span style=color:#75715e>// 8-bit</span>
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>readChar</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float</span> floatV <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>writeFloat</span>(floatV); <span style=color:#75715e>// 32-bit</span>
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>readFloat</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>double</span> doubleV <span style=color:#f92672>=</span> 0.<span style=color:#a6e22e>0</span>;
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>writeDouble</span>(doubleV); <span style=color:#75715e>// 64-bit</span>
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>readDouble</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> bytes <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span>{0, 1, 2, 3, 4, 5, 6};
</span></span><span style=display:flex><span><span style=color:#75715e>// 等价于 buf.writeBytes(bytes, 0, bytes.length)</span>
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>writeBytes</span>(bytes);
</span></span><span style=display:flex><span><span style=color:#75715e>// 从 `bytes` 的 `srcIndex` 处读取`length` 字节，写入到 `buf`</span>
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>writeBytes</span>(bytes, 1, 3);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>byte</span><span style=color:#f92672>[]</span> bytesDestination <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>byte</span><span style=color:#f92672>[</span>8<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>readBytes</span>(bytesDestination);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ByteBuf originalBuf <span style=color:#f92672>=</span> ByteBufAllocator.<span style=color:#a6e22e>DEFAULT</span>.<span style=color:#a6e22e>buffer</span>();
</span></span><span style=display:flex><span><span style=color:#75715e>// 等价于 buf.writeBytes(originalBuf, originalBuf.readableBytes())</span>
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>writeBytes</span>(originalBuf);
</span></span><span style=display:flex><span><span style=color:#75715e>// 等价于 buf.writeBytes(originalBuf, originalBuf.readerIndex(), 3);</span>
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>writeBytes</span>(originalBuf, 3);
</span></span><span style=display:flex><span><span style=color:#75715e>// 从 `originalBuf` 的 `srcIndex` 处读取`length` 字节，写入到 `buf`</span>
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>writeBytes</span>(originalBuf, 1, 3);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ByteBuf bufDestination <span style=color:#f92672>=</span> ByteBufAllocator.<span style=color:#a6e22e>DEFAULT</span>.<span style=color:#a6e22e>buffer</span>();
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>readBytes</span>(bufDestination);
</span></span></code></pre></div><h3 id=派生>派生
<a class=anchor href=#%e6%b4%be%e7%94%9f>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>duplicate()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>slice()
</span></span><span style=display:flex><span>slice(<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>readSlice(<span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>retainedDuplicate()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>retainedSlice()
</span></span><span style=display:flex><span>retainedSlice(<span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>readRetainedSlice(<span style=color:#66d9ef>int</span>)
</span></span></code></pre></div><h3 id=读写指针>读写指针
<a class=anchor href=#%e8%af%bb%e5%86%99%e6%8c%87%e9%92%88>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>ByteBuf buf <span style=color:#f92672>=</span> ByteBufAllocator.<span style=color:#a6e22e>DEFAULT</span>.<span style=color:#a6e22e>buffer</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> readerIndex <span style=color:#f92672>=</span> buf.<span style=color:#a6e22e>readerIndex</span>(); <span style=color:#75715e>// 获取当前读指针位置</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> writerIndex <span style=color:#f92672>=</span> buf.<span style=color:#a6e22e>writerIndex</span>(); <span style=color:#75715e>// 获取当前写指针位置</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>readerIndex</span>(0); <span style=color:#75715e>// readerIndex(int)，设置读指针位置</span>
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>writerIndex</span>(0); <span style=color:#75715e>// writerIndex(int)，设置写指针位置</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>markReaderIndex</span>(); <span style=color:#75715e>// 记录当前读指针位置</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// do something</span>
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>resetReaderIndex</span>(); <span style=color:#75715e>// 恢复到之前 mark 的读指针位置</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>markWriterIndex</span>(); <span style=color:#75715e>// 记录当前写指针位置</span>
</span></span><span style=display:flex><span><span style=color:#75715e>// do something</span>
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>resetWriterIndex</span>(); <span style=color:#75715e>// 恢复到之前 mark 的写指针位置</span>
</span></span></code></pre></div><h3 id=丢弃字节>丢弃字节
<a class=anchor href=#%e4%b8%a2%e5%bc%83%e5%ad%97%e8%8a%82>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span>ByteBuf buf <span style=color:#f92672>=</span> ByteBufAllocator.<span style=color:#a6e22e>DEFAULT</span>.<span style=color:#a6e22e>buffer</span>();
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(buf); <span style=color:#75715e>// PooledUnsafeDirectByteBuf(ridx: 0, widx: 0, cap: 256)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 16; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    buf.<span style=color:#a6e22e>writeInt</span>(i);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> 8; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    buf.<span style=color:#a6e22e>readInt</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(buf); <span style=color:#75715e>// PooledUnsafeDirectByteBuf(ridx: 32, widx: 64, cap: 256)</span>
</span></span><span style=display:flex><span>buf.<span style=color:#a6e22e>discardReadBytes</span>();
</span></span><span style=display:flex><span>System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(buf); <span style=color:#75715e>// PooledUnsafeDirectByteBuf(ridx: 0, widx: 32, cap: 256)</span>
</span></span></code></pre></div><hr><p>调用 <code>discardReadBytes()</code> 丢弃 0 ~ readerIndex 之间的字节。将 <code>readerIndex</code> 和 <code>writerIndex</code> 之间的字节移动到第 0 个索引，并将 <code>readerIndex</code> 和 <code>writerIndex</code> 分别设置为 0 和 <code>oldWriterIndex - oldReaderIndex</code>。</p><pre tabindex=0><code>BEFORE discardReadBytes()

    +-------------------+------------------+------------------+
    | discardable bytes |  readable bytes  |  writable bytes  |
    +-------------------+------------------+------------------+
    |                   |                  |                  |
    0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity


AFTER discardReadBytes()

    +------------------+--------------------------------------+
    |  readable bytes  |    writable bytes (got more space)   |
    +------------------+--------------------------------------+
    |                  |                                      |
readerIndex (0) &lt;= writerIndex (decreased)        &lt;=        capacity
</code></pre><hr><p>也可以调用 <code>clear()</code> 方法，当调用后会直接将 <code>readerIndex</code> 和 <code>writerIndex</code> 同时设为 0。</p><pre tabindex=0><code>BEFORE clear()

    +-------------------+------------------+------------------+
    | discardable bytes |  readable bytes  |  writable bytes  |
    +-------------------+------------------+------------------+
    |                   |                  |                  |
    0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=    capacity


AFTER clear()

    +---------------------------------------------------------+
    |             writable bytes (got more space)             |
    +---------------------------------------------------------+
    |                                                         |
    0 = readerIndex = writerIndex            &lt;=            capacity
</code></pre><h2 id=bytebufholder>ByteBufHolder
<a class=anchor href=#bytebufholder>#</a></h2><p><code>ByteBufHolder</code> 可用于封装 <code>ByteBuf</code> 数据，可用于存储消息对象。</p><h2 id=分类>分类
<a class=anchor href=#%e5%88%86%e7%b1%bb>#</a></h2><h3 id=heap-和-direct>Heap 和 Direct
<a class=anchor href=#heap-%e5%92%8c-direct>#</a></h3><ul><li><p>Heap 底层使用 <code>byte[]</code>。</p></li><li><p>Direct 底层使用 <code>java.nio.ByteBuffer</code>。</p></li></ul><h3 id=pooled-和-unpooled>Pooled 和 Unpooled
<a class=anchor href=#pooled-%e5%92%8c-unpooled>#</a></h3><p>池化和非池化的区别，Netty 维护者（Norman Maurer）的
<a href=https://stackoverflow.com/questions/22842153/netty-4-buffers-pooled-vs-unpooled>回答</a>：</p><pre tabindex=0><code>The difference is that with unpooled Netty will allocate a new buffer everytime 
you call ByteBufAllocator.buffer which comes with some overhead, especially 
with direct buffers. When you use pooled Netty will try to pool the buffers 
and so minimize the overhead of allocation and releasing of buffers.
</code></pre><h3 id=safe-和-unsafe>Safe 和 Unsafe
<a class=anchor href=#safe-%e5%92%8c-unsafe>#</a></h3><p><code>Unsafe</code> 的 <code>ByteBuf</code> 会使用 <code>sun.misc.Unsafe</code> 直接申请内存。</p><h2 id=abstractbytebuf>AbstractByteBuf
<a class=anchor href=#abstractbytebuf>#</a></h2><p><code>AbstractByteBuf</code> 是 buffer 的基本骨架，提供了基本的操作。</p><hr><p>类中共有 4 个 <code>*Index</code> 和 1 个指定最大容量的字段 <code>maxCapacity</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>int</span> readerIndex;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> writerIndex;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> markedReaderIndex;
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> markedWriterIndex;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> maxCapacity;
</span></span></code></pre></div><p><code>readerIndex</code> 和 <code>writerIndex</code> 分别指定当前读入和写入的位置，当调用 <code>read*</code> 和 <code>write*</code> 方法时会修改位置，而 <code>get*</code> 和 <code>set*</code> 方法不会。</p><p><code>markedReaderIndex</code> 和 <code>markedWriterIndex</code> 用于标注当前的位置，默认值为 0。调用 <code>markReaderIndex()</code> 和 <code>markWriterIndex()</code> 方法用于标记当前读入和写入的位置。</p><hr><p>当调用 <code>resetReaderIndex()</code> 和 <code>resetWriterIndex()</code> 方法时，会将当前的 <code>readerIndex</code> 和 <code>writerIndex</code> 设置为 <code>markedReaderIndex</code> 和 <code>markedWriterIndex</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> ByteBuf <span style=color:#a6e22e>resetReaderIndex</span>() {
</span></span><span style=display:flex><span>    readerIndex(markedReaderIndex);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> ByteBuf <span style=color:#a6e22e>resetWriterIndex</span>() {
</span></span><span style=display:flex><span>    writerIndex(markedWriterIndex);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><p><strong>可读可写</strong>只需要判断 <code>writerIndex</code> 和 <code>readerIndex</code> 的相对位置即可。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isReadable</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> writerIndex <span style=color:#f92672>&gt;</span> readerIndex;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>boolean</span> <span style=color:#a6e22e>isWritable</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> capacity() <span style=color:#f92672>&gt;</span> writerIndex;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>readableBytes</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> writerIndex <span style=color:#f92672>-</span> readerIndex;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>writableBytes</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> capacity() <span style=color:#f92672>-</span> writerIndex;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=bytebufallocator>ByteBufAllocator
<a class=anchor href=#bytebufallocator>#</a></h2><h3 id=继承关系>继承关系
<a class=anchor href=#%e7%bb%a7%e6%89%bf%e5%85%b3%e7%b3%bb>#</a></h3><p><img src=/img/Netty/ByteBufAllocator.png alt></p><h3 id=默认-allocator>默认 Allocator
<a class=anchor href=#%e9%bb%98%e8%ae%a4-allocator>#</a></h3><p><code>ByteBufAllocator</code> 类中的 <code>DEFAULT</code> 指定 Netty 使用的 Allocator。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>interface</span> <span style=color:#a6e22e>ByteBufAllocator</span> {
</span></span><span style=display:flex><span>    ByteBufAllocator DEFAULT <span style=color:#f92672>=</span> ByteBufUtil.<span style=color:#a6e22e>DEFAULT_ALLOCATOR</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>ByteBufUtil</code> 类通过获取系统变量确认默认的 <code>ByteBufAllocator</code>，默认使用 <code>PooledByteBufAllocator</code> 类。</p><p>可以通过 <code>java -Dio.netty.allocator.type: {unpooled|pooled}</code> 指定。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ByteBufUtil</span> {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> ByteBufAllocator DEFAULT_ALLOCATOR;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> {
</span></span><span style=display:flex><span>        String allocType <span style=color:#f92672>=</span> SystemPropertyUtil.<span style=color:#a6e22e>get</span>(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;io.netty.allocator.type&#34;</span>, PlatformDependent.<span style=color:#a6e22e>isAndroid</span>() <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;unpooled&#34;</span> : <span style=color:#e6db74>&#34;pooled&#34;</span>);
</span></span><span style=display:flex><span>        allocType <span style=color:#f92672>=</span> allocType.<span style=color:#a6e22e>toLowerCase</span>(Locale.<span style=color:#a6e22e>US</span>).<span style=color:#a6e22e>trim</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        ByteBufAllocator alloc;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#e6db74>&#34;unpooled&#34;</span>.<span style=color:#a6e22e>equals</span>(allocType)) {
</span></span><span style=display:flex><span>            alloc <span style=color:#f92672>=</span> UnpooledByteBufAllocator.<span style=color:#a6e22e>DEFAULT</span>;
</span></span><span style=display:flex><span>            logger.<span style=color:#a6e22e>debug</span>(<span style=color:#e6db74>&#34;-Dio.netty.allocator.type: {}&#34;</span>, allocType);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (<span style=color:#e6db74>&#34;pooled&#34;</span>.<span style=color:#a6e22e>equals</span>(allocType)) {
</span></span><span style=display:flex><span>            alloc <span style=color:#f92672>=</span> PooledByteBufAllocator.<span style=color:#a6e22e>DEFAULT</span>;
</span></span><span style=display:flex><span>            logger.<span style=color:#a6e22e>debug</span>(<span style=color:#e6db74>&#34;-Dio.netty.allocator.type: {}&#34;</span>, allocType);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            alloc <span style=color:#f92672>=</span> PooledByteBufAllocator.<span style=color:#a6e22e>DEFAULT</span>;
</span></span><span style=display:flex><span>            logger.<span style=color:#a6e22e>debug</span>(<span style=color:#e6db74>&#34;-Dio.netty.allocator.type: pooled (unknown: {})&#34;</span>, allocType);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        DEFAULT_ALLOCATOR <span style=color:#f92672>=</span> alloc;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=内存回收>内存回收
<a class=anchor href=#%e5%86%85%e5%ad%98%e5%9b%9e%e6%94%b6>#</a></h2><p>Netty 使用<strong>引用计数</strong>方法对 <code>ByteBuf</code> 进行回收。实现 <code>ReferenceCounted</code> 的实例开始时的引用计数为 1，只要引用计数大于 0，就能保证对象不会被释放。当引用计数减少到 0 时，该实例就会被释放。</p><ul><li><code>UnpooledHeapByteBuf</code> 使用的是 JVM 内存，只需等 GC 回收即可。</li><li><code>UnpooledDirectByteBuf</code> 使用了直接内存，</li></ul><h2 id=扩容逻辑>扩容逻辑
<a class=anchor href=#%e6%89%a9%e5%ae%b9%e9%80%bb%e8%be%91>#</a></h2><p>当向 <code>ByteBuf</code> 写入数据，而容量不足时（<code>writerIndex > capacity()</code>），会自动进行扩容。</p><p>每次调用 <code>write*()</code> 时，方法内部会调用 <code>ensureWritable0()</code> 确保有足够的空间。</p><p>调用 <code>ensureWritable0()</code> 时会传入 <code>minWritableBytes</code> 参数，确保有足够的字节数，调用 <code>writeLong()</code> 时，会被设为 8。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AbstractByteBuf</span> <span style=color:#66d9ef>extends</span> ByteBuf {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> ByteBuf <span style=color:#a6e22e>writeInt</span>(<span style=color:#66d9ef>int</span> value) {
</span></span><span style=display:flex><span>        ensureWritable0(4);
</span></span><span style=display:flex><span>        _setInt(writerIndex, value);
</span></span><span style=display:flex><span>        writerIndex <span style=color:#f92672>+=</span> 4;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=ensurewritable0>ensureWritable0
<a class=anchor href=#ensurewritable0>#</a></h3><p><code>ensureWritable0()</code> 进行扩容的代码如下：</p><ol><li>获取当前的写入索引（<code>writerIndex</code>），并计算目标容量（<code>targetCapacity</code>），即当前写入索引加上要写入的最小字节数。</li><li>使用非短路逻辑与运算符（&）来检查目标容量是否在合理范围内。这里选择使用非短路逻辑与运算符是为了减少分支，因为该代码段通常是一个热点路径，并且目标容量很少会溢出。如果目标容量在合理范围内，则表示缓冲区已经有足够的空间，直接返回。</li><li>如果启用了边界检查（checkBounds），并且目标容量小于 0 或者大于最大容量（<code>maxCapacity</code>），则抛出索引越界异常。</li><li>如果目标容量不在合理范围内，需要增加缓冲区的容量。首先，调用 maxFastWritableBytes() 方法获取一个快速可写入的字节数，然后根据这个字节数和传入的最小可写入字节数来计算新的容量。如果快速可写入字节数大于等于传入的最小可写入字节数，则新容量直接设定为当前写入索引加上快速可写入字节数，否则通过调用 <code>calculateNewCapacity</code> 方法来计算新容量。</li><li>通过调用 <code>capacity(newCapacity)</code> 方法来调整缓冲区的容量，确保其足够可写入。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AbstractByteBuf</span> <span style=color:#66d9ef>extends</span> ByteBuf {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ensureWritable0</span>(<span style=color:#66d9ef>int</span> minWritableBytes) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> writerIndex <span style=color:#f92672>=</span> writerIndex();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> targetCapacity <span style=color:#f92672>=</span> writerIndex <span style=color:#f92672>+</span> minWritableBytes;
</span></span><span style=display:flex><span>        <span style=color:#75715e>// using non-short-circuit &amp; to reduce branching - this is a hot path and targetCapacity should rarely overflow</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (targetCapacity <span style=color:#f92672>&gt;=</span> 0 <span style=color:#f92672>&amp;</span> targetCapacity <span style=color:#f92672>&lt;=</span> capacity()) {
</span></span><span style=display:flex><span>            ensureAccessible();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (checkBounds <span style=color:#f92672>&amp;&amp;</span> (targetCapacity <span style=color:#f92672>&lt;</span> 0 <span style=color:#f92672>||</span> targetCapacity <span style=color:#f92672>&gt;</span> maxCapacity)) {
</span></span><span style=display:flex><span>            ensureAccessible();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IndexOutOfBoundsException(String.<span style=color:#a6e22e>format</span>(
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#34;writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s&#34;</span>,
</span></span><span style=display:flex><span>                    writerIndex, minWritableBytes, maxCapacity, <span style=color:#66d9ef>this</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Normalize the target capacity to the power of 2.</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> fastWritable <span style=color:#f92672>=</span> maxFastWritableBytes();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> newCapacity <span style=color:#f92672>=</span> fastWritable <span style=color:#f92672>&gt;=</span> minWritableBytes <span style=color:#f92672>?</span> writerIndex <span style=color:#f92672>+</span> fastWritable
</span></span><span style=display:flex><span>                : alloc().<span style=color:#a6e22e>calculateNewCapacity</span>(targetCapacity, maxCapacity);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Adjust to the new capacity.</span>
</span></span><span style=display:flex><span>        capacity(newCapacity);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=calculatenewcapacity>calculateNewCapacity
<a class=anchor href=#calculatenewcapacity>#</a></h3><p><code>calculateNewCapacity</code> 计算新的容量时的思路总结如下：</p><ol><li><code>minNewCapacity</code> 参数为最小申请的容量，检查传入的 <code>minNewCapacity</code> 参数是否为非负数，如果不是，则抛出异常。</li><li>检查 <code>minNewCapacity</code> 是否超过了最大容量 <code>maxCapacity</code>，如果超过了，则抛出异常。</li><li>设定一个阈值 <code>threshold</code>，表示页面大小为 4 MiB。</li><li><code>minNewCapacity</code> 等于阈值 <code>threshold</code>，则直接返回阈值，不再需要进行容量的调整。</li><li><code>minNewCapacity</code> 大于阈值 <code>threshold</code>，则按照阈值为单位递增容量。在这种情况下，新容量的计算方式不再是简单的翻倍增加，而是以阈值为单位递增。</li><li><code>minNewCapacity</code> 小于等于阈值 <code>threshold</code> 时，则将 <code>minNewCapacity</code> 设置为大于等于 64 的最接近的 2 的幂，以确保足够的容量同时尽量减小内存的浪费。</li><li>返回新容量和最大容量中较小的一个值，以确保新容量不会超过最大容量限制。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Java data-lang=Java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>AbstractByteBufAllocator</span> <span style=color:#66d9ef>implements</span> ByteBufAllocator {
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>calculateNewCapacity</span>(<span style=color:#66d9ef>int</span> minNewCapacity, <span style=color:#66d9ef>int</span> maxCapacity) {
</span></span><span style=display:flex><span>        checkPositiveOrZero(minNewCapacity, <span style=color:#e6db74>&#34;minNewCapacity&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (minNewCapacity <span style=color:#f92672>&gt;</span> maxCapacity) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> IllegalArgumentException(String.<span style=color:#a6e22e>format</span>(
</span></span><span style=display:flex><span>                    <span style=color:#e6db74>&#34;minNewCapacity: %d (expected: not greater than maxCapacity(%d)&#34;</span>,
</span></span><span style=display:flex><span>                    minNewCapacity, maxCapacity));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> threshold <span style=color:#f92672>=</span> CALCULATE_THRESHOLD; <span style=color:#75715e>// 4 MiB page</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (minNewCapacity <span style=color:#f92672>==</span> threshold) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> threshold;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// If over threshold, do not double but just increase by threshold.</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (minNewCapacity <span style=color:#f92672>&gt;</span> threshold) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> newCapacity <span style=color:#f92672>=</span> minNewCapacity <span style=color:#f92672>/</span> threshold <span style=color:#f92672>*</span> threshold;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (newCapacity <span style=color:#f92672>&gt;</span> maxCapacity <span style=color:#f92672>-</span> threshold) {
</span></span><span style=display:flex><span>                newCapacity <span style=color:#f92672>=</span> maxCapacity;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                newCapacity <span style=color:#f92672>+=</span> threshold;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> newCapacity;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 64 &lt;= newCapacity is a power of 2 &lt;= threshold</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span> newCapacity <span style=color:#f92672>=</span> MathUtil.<span style=color:#a6e22e>findNextPositivePowerOfTwo</span>(Math.<span style=color:#a6e22e>max</span>(minNewCapacity, 64));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> Math.<span style=color:#a6e22e>min</span>(newCapacity, maxCapacity);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    ...
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#bytebuf>ByteBuf</a><ul><li><a href=#基本结构>基本结构</a></li><li><a href=#相关操作>相关操作</a><ul><li><a href=#容量>容量</a></li><li><a href=#读写>读写</a></li><li><a href=#派生>派生</a></li><li><a href=#读写指针>读写指针</a></li><li><a href=#丢弃字节>丢弃字节</a></li></ul></li><li><a href=#bytebufholder>ByteBufHolder</a></li><li><a href=#分类>分类</a><ul><li><a href=#heap-和-direct>Heap 和 Direct</a></li><li><a href=#pooled-和-unpooled>Pooled 和 Unpooled</a></li><li><a href=#safe-和-unsafe>Safe 和 Unsafe</a></li></ul></li><li><a href=#abstractbytebuf>AbstractByteBuf</a></li><li><a href=#bytebufallocator>ByteBufAllocator</a><ul><li><a href=#继承关系>继承关系</a></li><li><a href=#默认-allocator>默认 Allocator</a></li></ul></li><li><a href=#内存回收>内存回收</a></li><li><a href=#扩容逻辑>扩容逻辑</a><ul><li><a href=#ensurewritable0>ensureWritable0</a></li><li><a href=#calculatenewcapacity>calculateNewCapacity</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>