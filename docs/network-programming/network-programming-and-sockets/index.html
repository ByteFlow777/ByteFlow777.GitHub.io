<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="网络编程和套接字 # 网络编程即编写程序使两台联网的计算机相互交换数据。计算机之间会通过网线、路由器和交换机等设备连接在一起，我们无需直接操控硬件，而使用操作系统提供的套接字（socket）。
套接字 # 网络编程中接受连接请求的套接字创建过程如下：
调用 socket 函数创建套接字。 调用 bind 函数分配 IP 地址和端口号。 调用 listen 函数转为可接受请求状态。 调用 accept 函数处理连接请求。 socket # 为了使用套接字，可以使用 socket 函数，创建用于通信的端点（endpoint）。
#include <sys/socket.h> int socket(int domain, int type, int protocol); 成功时会返回文件描述符，失败时会返回 -1。
https://man7.org/linux/man-pages/man2/socket.2.html
bind # 当使用 socket 函数创建套接字后，会存在于名称空间（地址族）中，但没有为其分配地址。bind 函数将 addr 指定的地址分配给文件描述符 sockfd 引用的套接字。
服务器可以不先调用 bind() 而直接调用 listen()，此时会为该 socket 分配一个 INADDR_ANY IP 地址（0.0.0.0）和临时端口（可通过 getsockname() 获取 socket 的地址）。示例代码可查看： no_bind()。
#include <sys/socket.h> int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 成功时返回 0，失败时返回 -1。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="网络编程和套接字"><meta property="og:description" content="网络编程和套接字 # 网络编程即编写程序使两台联网的计算机相互交换数据。计算机之间会通过网线、路由器和交换机等设备连接在一起，我们无需直接操控硬件，而使用操作系统提供的套接字（socket）。
套接字 # 网络编程中接受连接请求的套接字创建过程如下：
调用 socket 函数创建套接字。 调用 bind 函数分配 IP 地址和端口号。 调用 listen 函数转为可接受请求状态。 调用 accept 函数处理连接请求。 socket # 为了使用套接字，可以使用 socket 函数，创建用于通信的端点（endpoint）。
#include <sys/socket.h> int socket(int domain, int type, int protocol); 成功时会返回文件描述符，失败时会返回 -1。
https://man7.org/linux/man-pages/man2/socket.2.html
bind # 当使用 socket 函数创建套接字后，会存在于名称空间（地址族）中，但没有为其分配地址。bind 函数将 addr 指定的地址分配给文件描述符 sockfd 引用的套接字。
服务器可以不先调用 bind() 而直接调用 listen()，此时会为该 socket 分配一个 INADDR_ANY IP 地址（0.0.0.0）和临时端口（可通过 getsockname() 获取 socket 的地址）。示例代码可查看： no_bind()。
#include <sys/socket.h> int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 成功时返回 0，失败时返回 -1。"><meta property="og:type" content="article"><meta property="og:url" content="https://ileonli.github.io/docs/network-programming/network-programming-and-sockets/"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2024-01-24T23:35:32+08:00"><title>网络编程和套接字 | Leon' Blog</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.c4648f90e7f239143d6b1f74326dc2ce1794185b23b8cbbf3f813cfdf5d576ca.css integrity="sha256-xGSPkOfyORQ9ax90Mm3CzheUGFsjuMu/P4E8/fXVdso=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.b3fa310ae4db3955b5a3a1f9f80627cf278b22b191699f1d3da391839f1fc440.js integrity="sha256-s/oxCuTbOVW1o6H5+AYnzyeLIrGRaZ8dPaORg58fxEA=" crossorigin=anonymous></script><script defer src=/sw.min.88f1afdaf4798d7d3520420dcfe201f928c3d371fdedfc3ae28cd9b6b79544f8.js integrity="sha256-iPGv2vR5jX01IEINz+IB+SjD03H97fw64ozZtreVRPg=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-EL04QEY330"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EL04QEY330",{anonymize_ip:!1})}</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Leon' Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><span>C++</span><ul></ul></li><li><span>网络编程</span><ul><li><a href=/docs/network-programming/network-programming-and-sockets/ class=active>网络编程和套接字</a></li><li><a href=/docs/network-programming/network-byte-order/>网络字节序</a></li><li><a href=/docs/network-programming/address-families/>网络地址族</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>网络编程和套接字</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#网络编程和套接字>网络编程和套接字</a><ul><li><a href=#套接字>套接字</a><ul><li><a href=#socket>socket</a></li><li><a href=#bind>bind</a></li><li><a href=#listen>listen</a></li><li><a href=#accept>accept</a></li></ul></li><li><a href=#套接字协议>套接字协议</a><ul><li><a href=#协议族domain>协议族（domain）</a></li><li><a href=#数据传输方式type>数据传输方式（type）</a></li><li><a href=#协议protocol>协议（protocol）</a></li></ul></li><li><a href=#echo-服务器>echo 服务器</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=网络编程和套接字>网络编程和套接字
<a class=anchor href=#%e7%bd%91%e7%bb%9c%e7%bc%96%e7%a8%8b%e5%92%8c%e5%a5%97%e6%8e%a5%e5%ad%97>#</a></h1><p><strong>网络编程</strong>即编写程序使两台联网的计算机相互交换数据。计算机之间会通过网线、路由器和交换机等设备连接在一起，我们无需直接操控硬件，而使用操作系统提供的<strong>套接字（socket）</strong>。</p><h2 id=套接字>套接字
<a class=anchor href=#%e5%a5%97%e6%8e%a5%e5%ad%97>#</a></h2><p>网络编程中接受连接请求的套接字创建过程如下：</p><ol><li>调用 <code>socket</code> 函数创建套接字。</li><li>调用 <code>bind</code> 函数分配 IP 地址和端口号。</li><li>调用 <code>listen</code> 函数转为可接受请求状态。</li><li>调用 <code>accept</code> 函数处理连接请求。</li></ol><h3 id=socket>socket
<a class=anchor href=#socket>#</a></h3><p>为了使用套接字，可以使用 <code>socket</code> 函数，创建用于通信的端点（endpoint）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>socket</span>(<span style=color:#66d9ef>int</span> domain, <span style=color:#66d9ef>int</span> type, <span style=color:#66d9ef>int</span> protocol);
</span></span></code></pre></div><p><strong>成功时</strong>会返回文件描述符，<strong>失败时</strong>会返回 -1。</p><blockquote><p><a href=https://man7.org/linux/man-pages/man2/socket.2.html>https://man7.org/linux/man-pages/man2/socket.2.html</a></p></blockquote><h3 id=bind>bind
<a class=anchor href=#bind>#</a></h3><p>当使用 <code>socket</code> 函数创建套接字后，会存在于名称空间（地址族）中，但没有为其分配地址。<code>bind</code> 函数将 <code>addr</code> 指定的地址分配给文件描述符 <code>sockfd</code> 引用的套接字。</p><p>服务器可以不先调用 <code>bind()</code> 而直接调用 <code>listen()</code>，此时会为该 <code>socket</code> 分配一个 <strong><code>INADDR_ANY</code> IP 地址</strong>（0.0.0.0）和<strong>临时端口</strong>（可通过 <code>getsockname()</code> 获取 <code>socket</code> 的地址）。示例代码可查看：
<a href=https://github.com/ileonli/linuxp/blob/51653fee0f6ca9b67d750c8e778d6c6143bd0218/src/network.c#L52>no_bind()</a>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>bind</span>(<span style=color:#66d9ef>int</span> sockfd, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>addr,
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>socklen_t</span> addrlen);
</span></span></code></pre></div><p><strong>成功时</strong>返回 0，<strong>失败时</strong>返回 -1。</p><blockquote><p><a href=https://man7.org/linux/man-pages/man2/bind.2.html>https://man7.org/linux/man-pages/man2/bind.2.html</a></p></blockquote><h3 id=listen>listen
<a class=anchor href=#listen>#</a></h3><p><code>listen</code> 函数用于监听套接字上的连接。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>listen</span>(<span style=color:#66d9ef>int</span> sockfd, <span style=color:#66d9ef>int</span> backlog);
</span></span></code></pre></div><p><strong>成功时</strong>返回 0，<strong>失败时</strong>返回 -1。</p><blockquote><p><a href=https://man7.org/linux/man-pages/man2/listen.2.html>https://man7.org/linux/man-pages/man2/listen.2.html</a></p></blockquote><h3 id=accept>accept
<a class=anchor href=#accept>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>accept</span>(<span style=color:#66d9ef>int</span> sockfd, <span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>_Nullable <span style=color:#66d9ef>restrict</span> addr,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>socklen_t</span> <span style=color:#f92672>*</span>_Nullable <span style=color:#66d9ef>restrict</span> addrlen);
</span></span></code></pre></div><p><strong>成功时</strong>会返回文件描述符，<strong>失败时</strong>会返回 -1。</p><blockquote><p><a href=https://man7.org/linux/man-pages/man2/accept.2.html>https://man7.org/linux/man-pages/man2/accept.2.html</a></p></blockquote><h2 id=套接字协议>套接字协议
<a class=anchor href=#%e5%a5%97%e6%8e%a5%e5%ad%97%e5%8d%8f%e8%ae%ae>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/socket.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>socket</span>(<span style=color:#66d9ef>int</span> domain, <span style=color:#66d9ef>int</span> type, <span style=color:#66d9ef>int</span> protocol);
</span></span></code></pre></div><p><code>socket</code> 函数有三个参数：</p><ul><li><code>domain</code>：用于通信的协议族。</li><li><code>type</code>：数据传输类型。</li><li><code>protocol</code>：指定套接字类型。</li></ul><h3 id=协议族domain>协议族（domain）
<a class=anchor href=#%e5%8d%8f%e8%ae%ae%e6%97%8fdomain>#</a></h3><p>所有的协议族可以点击
<a href=https://man7.org/linux/man-pages/man7/address_families.7.html>address_families</a> 查看，本文主要介绍 <code>AF_INET</code>（IPv4） 和 <code>AF_INET6</code>（IPv6）。</p><p>主要的协议族分类如下：</p><table><thead><tr><th>协议族</th><th>描述</th></tr></thead><tbody><tr><td>AF_INET</td><td>使用 IPv4 地址</td></tr><tr><td>AF_INET6</td><td>使用 IPv6 地址</td></tr><tr><td>AF_UNIX</td><td>本地通信，用于同一台机器上的进程间通信</td></tr><tr><td>AF_PACKET</td><td>原始数据包捕获和注入，需要特殊权限</td></tr><tr><td>AF_NETLINK</td><td>用于 Linux 内核与用户空间进程之间的通信</td></tr></tbody></table><h3 id=数据传输方式type>数据传输方式（type）
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e4%bc%a0%e8%be%93%e6%96%b9%e5%bc%8ftype>#</a></h3><p>数据传输类型主要有以下两种：</p><ul><li><strong>面向连接的套接字</strong>（SOCK_STREAM）：提供有序的、可靠的、双向的、基于连接的字节流。可以支持带外（
<a href=https://en.wikipedia.org/wiki/Out-of-band_data>out-of-band</a> ）数据传输机制。</li><li><strong>面向消息的套接字</strong>（SOCK_DGRAM）：支持数据报（无连接、最大长度固定的不可靠消息）。</li></ul><h3 id=协议protocol>协议（protocol）
<a class=anchor href=#%e5%8d%8f%e8%ae%aeprotocol>#</a></h3><p><a href="https://man7.org/linux/man-pages/man2/socket.2.html#:~:text=Since%20Linux%202.6.27%2C%20the%20type%20argument%20serves%20a%20second%20purpose%3A%20in%0A%20%20%20%20%20%20%20addition%20to%20specifying%20a%20socket%20type%2C%20it%20may%20include%20the%20bitwise%0A%20%20%20%20%20%20%20OR%20of%20any%20of%20the%20following%20values%2C%20to%20modify%20the%20behavior%20of%0A%20%20%20%20%20%20%20socket%28%29%3A">Linux 2.6.27</a> 对 <code>protocol</code> 进行了扩展。</p><p><code>socket</code> 函数前两个参数已经可以指定<strong>协议族信息</strong>和<strong>数据传输方式</strong>，为什么还需要使用第三个参数？</p><blockquote><p>通常，在给定的协议族中，只有一个协议存在以支持特定的套接字类型，在这种情况下，可以将 <code>protocol</code> 指定为 0。</p><p>在大部分情况下，第三个参数传递 0 即可。然而，协议族下可能存在许多协议，在这种情况下，必须使用 <code>protocol</code> 指定一个特定的协议。</p></blockquote><h2 id=echo-服务器>echo 服务器
<a class=anchor href=#echo-%e6%9c%8d%e5%8a%a1%e5%99%a8>#</a></h2><p><a href=https://github.com/ileonli/linuxp/blob/main/src/echo/echo_client.c>https://github.com/ileonli/linuxp/blob/main/src/echo/echo_client.c</a></p><p><a href=https://github.com/ileonli/linuxp/blob/main/src/echo/echo_server.c>https://github.com/ileonli/linuxp/blob/main/src/echo/echo_server.c</a></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#网络编程和套接字>网络编程和套接字</a><ul><li><a href=#套接字>套接字</a><ul><li><a href=#socket>socket</a></li><li><a href=#bind>bind</a></li><li><a href=#listen>listen</a></li><li><a href=#accept>accept</a></li></ul></li><li><a href=#套接字协议>套接字协议</a><ul><li><a href=#协议族domain>协议族（domain）</a></li><li><a href=#数据传输方式type>数据传输方式（type）</a></li><li><a href=#协议protocol>协议（protocol）</a></li></ul></li><li><a href=#echo-服务器>echo 服务器</a></li></ul></li></ul></nav></div></aside></main></body></html>