<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>网络编程 on Leon' Blog</title><link>https://ileonli.github.io/docs/network-programming/</link><description>Recent content in 网络编程 on Leon' Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://ileonli.github.io/docs/network-programming/index.xml" rel="self" type="application/rss+xml"/><item><title>网络编程和套接字</title><link>https://ileonli.github.io/docs/network-programming/network-programming-and-sockets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/network-programming/network-programming-and-sockets/</guid><description>网络编程和套接字 # 网络编程即编写程序使两台联网的计算机相互交换数据。计算机之间会通过网线、路由器和交换机等设备连接在一起，我们无需直接操控硬件，而使用操作系统提供的套接字（socket）。
套接字 # 网络编程中接受连接请求的套接字创建过程如下：
调用 socket 函数创建套接字。 调用 bind 函数分配 IP 地址和端口号。 调用 listen 函数转为可接受请求状态。 调用 accept 函数处理连接请求。 socket # 为了使用套接字，可以使用 socket 函数，创建用于通信的端点（endpoint）。
#include &amp;lt;sys/socket.h&amp;gt; int socket(int domain, int type, int protocol); 成功时会返回文件描述符，失败时会返回 -1。
https://man7.org/linux/man-pages/man2/socket.2.html
bind # 当使用 socket 函数创建套接字后，会存在于名称空间（地址族）中，但没有为其分配地址。bind 函数将 addr 指定的地址分配给文件描述符 sockfd 引用的套接字。
服务器可以不先调用 bind() 而直接调用 listen()，此时会为该 socket 分配一个 INADDR_ANY IP 地址（0.0.0.0）和临时端口（可通过 getsockname() 获取 socket 的地址）。示例代码可查看： no_bind()。
#include &amp;lt;sys/socket.h&amp;gt; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 成功时返回 0，失败时返回 -1。</description></item></channel></rss>