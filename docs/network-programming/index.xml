<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>网络编程 on Leon' Blog</title><link>https://ileonli.github.io/docs/network-programming/</link><description>Recent content in 网络编程 on Leon' Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://ileonli.github.io/docs/network-programming/index.xml" rel="self" type="application/rss+xml"/><item><title>网络字节序</title><link>https://ileonli.github.io/docs/network-programming/network-byte-order/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/network-programming/network-byte-order/</guid><description>网络字节序 # 大小端 # 不同架构的 CPU 中，4 字节整数 1 在内存中存储的方式是不同的。
大端序（big endian）：最高位有效字节存储在低内存地址，而最低位有效字节存储在高内存地址。 小端序（little endian）：最高位有效字节存储在高内存地址，而最低位有效字节存储在低内存地址。 对于一个 4 字节整数 0x01020304，大小端序存储方式分别如下：
地址: 0 1 2 3 （大端序保存） 01 02 03 04 地址: 0 1 2 3 （小端序保存） 04 03 02 01 可以使用下边的方法判断机器的字节序：
通过 endian.h 提供的 BYTE_ORDER 宏。 #include &amp;lt;endian.h&amp;gt; bool big_endian() { return BYTE_ORDER == BIG_ENDIAN; } bool little_endian() { return BYTE_ORDER == LITTLE_ENDIAN; } 将 uint16_t 类型的数字转为 char *，通过高字节和低字节进行判断。 bool big_endian() { uint16_t val = 0x0102; return ((char *) (&amp;amp;val))[0] == 0x01; } bool little_endian() { uint16_t val = 0x0102; return ((char *) (&amp;amp;val))[1] == 0x01; } 和方法 2 类似，利用的是 union 相同的内存位置存储不同的数据类型。 union endian { uint16_t val; char bytes[2]; }; bool big_endian() { union endian en{}; en.</description></item><item><title>网络地址族</title><link>https://ileonli.github.io/docs/network-programming/address-families/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/network-programming/address-families/</guid><description>网络地址族 # 网络地址 # 网络地址分为 IPv4 和 IPv6，分别使用 sockaddr_in 和 sockaddr_in6 结构体表示。
sockaddr_in # struct sockaddr_in { sa_family_t sin_family; /* address family: AF_INET */ in_port_t sin_port; /* port in network byte order */ struct in_addr sin_addr; /* internet address */ /* Pad to size of `struct sockaddr&amp;#39;. */ unsigned char sin_zero[8]; }; /* Internet address */ struct in_addr { uint32_t s_addr; /* address in network byte order */ }; sin_family：在 IPv4 中设为 AF_INET。 sin_port：网络字节序保存的端口（0～65535）。 sin_addr：网络字节序保存的 32 位 IP 地址信息。 sin_zero：使 sockaddr_in 和 sockaddr 结构体大小保持一致而插入的填充位，需手动设为 0。 https://man7.</description></item><item><title>listen 中的 backlog 参数</title><link>https://ileonli.github.io/docs/network-programming/backlog/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/network-programming/backlog/</guid><description/></item><item><title>TCP 协议</title><link>https://ileonli.github.io/docs/network-programming/TCP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/network-programming/TCP/</guid><description> TCP 协议 # TCP 报文格式 # Offsets0123OctetBit0123456701234567012345670123456700Source portDestination port432Sequence number864Acknowledgment number (if ACK set)1296Data offsetReserved
0 0 0 0CWRECEURGACKPSHRSTSYNFINWindow Size16128ChecksumUrgent pointer (if URG set)20
160
Options (ifdata offset &amp;gt; 5. Padded at the end with "0" bits if necessary.)
⋮⋮56448 源端口号（source port）：发送端的端口号。 目的端口号（destination port）：TCP 接收端的端口号。 序列号（sequence number）：报文的序列号，标识从 TCP 发端向 TCP 收端发送的数据字节流。 确认序列号（acknowledgement number）：如果设置了 ACK 位，此字段包含了接收方期望从发送方接收到的下一个数据字节的序列号。 首部长度（data offset）：该字段用来表示 TCP 报文首部的长度，首部长度单位是 32 位。由于这个字段只占 4 个比特位，因此首部总长度最大可达到 60 字节（15 个字长）。该字段使得 TCP 接收端可以确定变长的选项字段（options）的长度，以及数据域的起始点。 保留位（reserved）：该字段包含 4 个未使用的比特位（必须置为 0）。 控制位（control bit）：该字段由 8 个比特位组成，能进一步指定报文的含义。 CWR：拥塞窗口减小标记（congestion window reduced flag）。 TCP 序列号和确认机制 #</description></item><item><title>套接字（socket）</title><link>https://ileonli.github.io/docs/network-programming/sockets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/network-programming/sockets/</guid><description>套接字（socket） # 网络编程即编写程序使两台联网的计算机相互交换数据。计算机之间会通过网线、路由器和交换机等设备连接在一起，我们无需直接操控硬件，而使用操作系统提供的套接字（socket）。
基本函数 # socket # 为了使用套接字，可以使用 socket 函数，创建用于通信的端点（endpoint）。
#include &amp;lt;sys/socket.h&amp;gt; int socket(int domain, int type, int protocol); 成功时会返回文件描述符，失败时会返回 -1。
https://man7.org/linux/man-pages/man2/socket.2.html
bind # 当使用 socket 函数创建套接字后，会存在于名称空间（地址族）中，但没有为其分配地址。bind 函数将 addr 指定的地址分配给文件描述符 sockfd 引用的套接字。
服务器可以不先调用 bind() 而直接调用 listen()，此时会为该 socket 分配一个 INADDR_ANY IP 地址（0.0.0.0）和临时端口（可通过 getsockname() 获取 socket 的地址）。
#include &amp;lt;sys/socket.h&amp;gt; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 成功时返回 0，失败时返回 -1。
https://man7.org/linux/man-pages/man2/bind.2.html
listen # listen 函数将文件描述符引用的 socket 标记为被动，该 socket 会被用来接受来自其它主动 socket 的连接。</description></item><item><title>echo 服务器</title><link>https://ileonli.github.io/docs/network-programming/echo-server/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/network-programming/echo-server/</guid><description>echo 服务器 # 流程 # 服务端（被动）接受连接请求的套接字创建过程如下：
调用 socket 函数创建套接字。 调用 bind 函数分配 IP 地址和端口号。 调用 listen 函数转为可接受请求状态。 调用 accept 函数处理连接请求。 客户端（主动）连接请求的套接字创建过程如下：
调用 socket 函数创建套接字。 调用 connect 函数与服务器建立连接。 echo 服务器 # https://github.com/ileonli/linuxp/blob/main/src/echo/echo_client.c
https://github.com/ileonli/linuxp/blob/main/src/echo/echo_server.c</description></item></channel></rss>