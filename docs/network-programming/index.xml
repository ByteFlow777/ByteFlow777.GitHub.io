<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>网络编程 on Leon' Blog</title><link>https://ileonli.github.io/docs/network-programming/</link><description>Recent content in 网络编程 on Leon' Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://ileonli.github.io/docs/network-programming/index.xml" rel="self" type="application/rss+xml"/><item><title>网络编程和套接字</title><link>https://ileonli.github.io/docs/network-programming/network-programming-and-sockets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/network-programming/network-programming-and-sockets/</guid><description>网络编程和套接字 # 网络编程即编写程序使两台联网的计算机相互交换数据。计算机之间会通过网线、路由器和交换机等设备连接在一起，我们无需直接操控硬件，而使用操作系统提供的套接字（socket）。
套接字 # 网络编程中接受连接请求的套接字创建过程如下：
调用 socket 函数创建套接字。 调用 bind 函数分配 IP 地址和端口号。 调用 listen 函数转为可接受请求状态。 调用 accept 函数处理连接请求。 socket # 为了使用套接字，可以使用 socket 函数，创建用于通信的端点（endpoint）。
#include &amp;lt;sys/socket.h&amp;gt; int socket(int domain, int type, int protocol); 成功时会返回文件描述符，失败时会返回 -1。
https://man7.org/linux/man-pages/man2/socket.2.html
bind # 当使用 socket 函数创建套接字后，会存在于名称空间（地址族）中，但没有为其分配地址。bind 函数将 addr 指定的地址分配给文件描述符 sockfd 引用的套接字。
服务器可以不先调用 bind() 而直接调用 listen()，此时会为该 socket 分配一个 INADDR_ANY IP 地址（0.0.0.0）和临时端口（可通过 getsockname() 获取 socket 的地址）。示例代码可查看： no_bind()。
#include &amp;lt;sys/socket.h&amp;gt; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 成功时返回 0，失败时返回 -1。</description></item><item><title>网络字节序</title><link>https://ileonli.github.io/docs/network-programming/network-byte-order/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/network-programming/network-byte-order/</guid><description>网络字节序 # 大小端 # 不同架构的 CPU 中，4 字节整数 1 在内存中存储的方式是不同的。
大端序（big endian）：最高位有效字节存储在低内存地址，而最低位有效字节存储在高内存地址。 小端序（little endian）：最高位有效字节存储在高内存地址，而最低位有效字节存储在低内存地址。 对于一个 4 字节整数 0x01020304，大小端存储方式分别如下：
地址: 0 1 2 3 （大端序保存） 01 02 03 04 地址: 0 1 2 3 （小端序保存） 04 03 02 01 可以使用下边的方法判断机器的字节序：
#include &amp;lt;endian.h&amp;gt; bool big_endian() { return BYTE_ORDER == BIG_ENDIAN; } bool little_endian() { return BYTE_ORDER == LITTLE_ENDIAN; } bool big_endian() { uint16_t val = 0x0102; return ((char *) (&amp;amp;val))[0] == 0x01; } bool little_endian() { uint16_t val = 0x0102; return ((char *) (&amp;amp;val))[1] == 0x01; } union endian { uint16_t val; char bytes[2]; }; bool big_endian() { union endian en{}; en.</description></item><item><title>网络地址族</title><link>https://ileonli.github.io/docs/network-programming/address-families/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/network-programming/address-families/</guid><description>网络地址族 # 网络地址 # 网络地址分为 IPv4 和 IPv6，分别使用 sockaddr_in 和 sockaddr_in6 结构体表示。
sockaddr_in # struct sockaddr_in { sa_family_t sin_family; /* address family: AF_INET */ in_port_t sin_port; /* port in network byte order */ struct in_addr sin_addr; /* internet address */ /* Pad to size of `struct sockaddr&amp;#39;. */ unsigned char sin_zero[8]; }; /* Internet address */ struct in_addr { uint32_t s_addr; /* address in network byte order */ }; sin_family：在 IPv4 中设为 AF_INET。 sin_port：网络字节序保存的端口（0～65535）。 sin_addr：网络字节序保存的 32 位 IP 地址信息。 sin_zero：使 sockaddr_in 和 sockaddr 结构体大小保持一致而插入的填充位，需手动设为 0。 https://man7.</description></item></channel></rss>