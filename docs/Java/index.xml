<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on Leon' Blog</title><link>https://ileonli.github.io/docs/Java/</link><description>Recent content in Java on Leon' Blog</description><generator>Hugo</generator><language>en</language><atom:link href="https://ileonli.github.io/docs/Java/index.xml" rel="self" type="application/rss+xml"/><item><title>Agent</title><link>https://ileonli.github.io/docs/Java/Agent/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/Java/Agent/</guid><description>&lt;blockquote>
&lt;p>
 &lt;a href="https://www.cnblogs.com/crazymakercircle/p/16635330.html">https://www.cnblogs.com/crazymakercircle/p/16635330.html&lt;/a>&lt;/p>
&lt;p>
 &lt;a href="https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html#whatIs">https://docs.oracle.com/javase/8/docs/platform/jvmti/jvmti.html#whatIs&lt;/a>&lt;/p>
&lt;/blockquote></description></item><item><title>Cleaner 类</title><link>https://ileonli.github.io/docs/Java/Cleaner/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/Java/Cleaner/</guid><description>&lt;h1 id="参考文献">
 参考文献
 &lt;a class="anchor" href="#%e5%8f%82%e8%80%83%e6%96%87%e7%8c%ae">#&lt;/a>
&lt;/h1>
&lt;ol>
&lt;li>
 &lt;a href="https://openjdk.org/jeps/421">https://openjdk.org/jeps/421&lt;/a>&lt;/li>
&lt;li>
 &lt;a href="https://inside.java/2022/05/25/clean-cleaner/">https://inside.java/2022/05/25/clean-cleaner/&lt;/a>&lt;/li>
&lt;li>
 &lt;a href="https://docs.oracle.com/javase/9/docs/api/java/lang/ref/Cleaner.html">https://docs.oracle.com/javase/9/docs/api/java/lang/ref/Cleaner.html&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>JDBC</title><link>https://ileonli.github.io/docs/Java/JDBC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/Java/JDBC/</guid><description>&lt;h1 id="jdbc">
 JDBC
 &lt;a class="anchor" href="#jdbc">#&lt;/a>
&lt;/h1>
&lt;blockquote>
&lt;p>本教程使用 MySQL 数据库。&lt;/p>
&lt;p>主要参考：https://docs.oracle.com/javase/tutorial/jdbc/basics/index.html&lt;/p>
&lt;/blockquote>
&lt;h2 id="建立连接">
 建立连接
 &lt;a class="anchor" href="#%e5%bb%ba%e7%ab%8b%e8%bf%9e%e6%8e%a5">#&lt;/a>
&lt;/h2>
&lt;p>数据源可以是数据库管理系统 (DBMS)、传统文件系统或其他带有相应 JDBC 驱动的数据源。通常，JDBC 使用以下两种类之一来连接目标数据源：&lt;/p>
&lt;ul>
&lt;li>&lt;code>DriverManager&lt;/code>：用于将应用程序连接到通过数据库 URL 指定的数据源。当此类首次尝试建立连接时，它会自动加载类路径中找到的任何 JDBC 4.0 驱动程序。必须手动加载任何 4.0 版本之前的 JDBC 驱动程序。&lt;/li>
&lt;li>&lt;code>DataSource&lt;/code>：相比于 &lt;code>DriverManager&lt;/code>，更推荐使用此接口，因为它允许应用程序对底层数据源的细节保持透明。&lt;code>DataSource&lt;/code> 对象的属性被设置为表示特定的数据源。&lt;/li>
&lt;/ul>
&lt;h3 id="使用-drivermanager-类">
 使用 &lt;code>DriverManager&lt;/code> 类
 &lt;a class="anchor" href="#%e4%bd%bf%e7%94%a8-drivermanager-%e7%b1%bb">#&lt;/a>
&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>String url &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;jdbc:mysql://localhost:3306/db&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String username &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;root&amp;#34;&lt;/span>, password &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;0987654321&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Connection conn &lt;span style="color:#f92672">=&lt;/span> DriverManager.&lt;span style="color:#a6e22e">getConnection&lt;/span>(url, username, password);
&lt;/span>&lt;/span>&lt;/code>&lt;/pr</description></item><item><title>MethodHandles</title><link>https://ileonli.github.io/docs/Java/MethodHandles/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/Java/MethodHandles/</guid><description>&lt;h1 id="methodhandles">
 MethodHandles
 &lt;a class="anchor" href="#methodhandles">#&lt;/a>
&lt;/h1>
&lt;blockquote>
&lt;p>翻译自：
 &lt;a href="https://dev.java/learn/introduction_to_method_handles/">https://dev.java/learn/introduction_to_method_handles/&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="什么是方法句柄what-are-method-handles">
 什么是方法句柄（What are method handles）
 &lt;a class="anchor" href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%96%b9%e6%b3%95%e5%8f%a5%e6%9f%84what-are-method-handles">#&lt;/a>
&lt;/h2>
&lt;p>方法句柄是一种用于查找和调用方法的低级机制。与反射一样，方法句柄也提供了调用方法、调用构造函数以及访问字段的手段。&lt;/p>
&lt;p>那么，方法句柄究竟什么是呢？它是对底层方法、构造函数或字段的可调用引用。方法句柄允许在一个简单的指向方法的引用之上进行一系列操作，这些操作包括插入或重新排列参数、转换返回值等。&lt;/p>
&lt;p>让我们深入探讨一下方法句柄能够提供什么功能以及我们如何有效地使用它们。&lt;/p>
&lt;h2 id="访问检查access-checking">
 访问检查（Access checking）
 &lt;a class="anchor" href="#%e8%ae%bf%e9%97%ae%e6%a3%80%e6%9f%a5access-checking">#&lt;/a>
&lt;/h2>
&lt;p>方法句柄的访问检查与反射的执行方式是不同的。&lt;strong>使用反射时&lt;/strong>，每次调用都会对调用者进行访问检查。&lt;strong>而对于方法句柄&lt;/strong>，访问检查只在方法句柄创建时进行。&lt;/p>
&lt;p>需要注意的是，如果在能够访问非公共成员的上下文中创建了方法句柄，那么当该方法句柄被传递到外部时，可以通过方法句柄访问非公共成员。&lt;/p>
&lt;p>因此，非公共成员可能会被不应有访问权限的代码访问。开发者有责任将此类方法句柄限制在其创建的上下文内。另外，可以直接使用合适的查找对象来创建具有访问限制的方法句柄。&lt;/p>
&lt;h2 id="方法句柄查找method-handle-lookup">
 方法句柄查找（Method handle lookup）
 &lt;a class="anchor" href="#%e6%96%b9%e6%b3%95%e5%8f%a5%e6%9f%84%e6%9f%a5%e6%89%bemethod-handle-lookup">#&lt;/a>
&lt;/h2>
&lt;p>要创建方法句柄，我们首先需要创建一个 
 &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html">&lt;code>LookUp&lt;/code>&lt;/a> 对象，此为创建方法句柄的工厂。根据 &lt;code>Lookup&lt;/code> 对象本身或方法句柄的使用方式，我们可以决定是否需要限制其访问级别。&lt;/p></description></item><item><title>动态代理</title><link>https://ileonli.github.io/docs/Java/DynamicProxy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/Java/DynamicProxy/</guid><description>&lt;h1 id="动态代理">
 动态代理
 &lt;a class="anchor" href="#%e5%8a%a8%e6%80%81%e4%bb%a3%e7%90%86">#&lt;/a>
&lt;/h1>
&lt;p>在 Java 动态代理机制中，&lt;code>InvocationHandler&lt;/code> 接口和 &lt;code>Proxy&lt;/code> 类是核心。&lt;/p>
&lt;h2 id="proxy">
 Proxy
 &lt;a class="anchor" href="#proxy">#&lt;/a>
&lt;/h2>
&lt;p>&lt;code>Proxy&lt;/code> 类主要使用 &lt;code>newProxyInstance()&lt;/code> 静态方法生成代理对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Object &lt;span style="color:#a6e22e">newProxyInstance&lt;/span>(ClassLoader loader,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;[]&lt;/span> interfaces,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InvocationHandler h) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pr</description></item></channel></rss>