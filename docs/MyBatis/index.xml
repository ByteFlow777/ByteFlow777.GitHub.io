<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MyBatis on Leon' Blog</title><link>https://ileonli.github.io/docs/MyBatis/</link><description>Recent content in MyBatis on Leon' Blog</description><generator>Hugo</generator><language>en</language><atom:link href="https://ileonli.github.io/docs/MyBatis/index.xml" rel="self" type="application/rss+xml"/><item><title>SqlSession</title><link>https://ileonli.github.io/docs/MyBatis/SqlSession/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/MyBatis/SqlSession/</guid><description>SqlSession # SalSession 是用于操作数据库的接口，具体的操作都通过此接口。
SqlSessionFactoryBuilder # 此类可以被实例化、使用和丢弃，一旦使用此类创建了 SqlSessionFactory，后续就不需要使用此类了。因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。
可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证 XML 资源可以被释放。
SqlSessionFactory # SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。使用 SqlSessionFactory 的最佳实践是在应用运行期间只创建一次。
SqlSessionFactory 的作用是为了创建 SqlSession 实例。SqlSession 是 MyBatis 执行 SQL 命令的核心接口，通过此实例可以对数据库进行查询、插入、更新和删除操作。
import java.sql.Connection; /** * Creates an {@link SqlSession} out of a connection or a DataSource * * @author Clinton Begin */ public interface SqlSessionFactory { SqlSession openSession(); SqlSession openSession(boolean autoCommit); SqlSession openSession(Connection connection); SqlSession openSession(TransactionIsolationLevel level); SqlSession openSession(ExecutorType execType); SqlSession openSession(ExecutorType execType, boolean autoCommit); SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level); SqlSession openSession(ExecutorType execType, Connection connection); Configuration getConfiguration(); } SqlSessionFactory 主要有两个具体的实现：</description></item><item><title>ResultSetHandler</title><link>https://ileonli.github.io/docs/MyBatis/ResultSetHandler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/MyBatis/ResultSetHandler/</guid><description> ResultSetHandler # ResultSetHandler
public interface ResultSetHandler { &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; handleResultSets(Statement stmt) throws SQLException; &amp;lt;E&amp;gt; Cursor&amp;lt;E&amp;gt; handleCursorResultSets(Statement stmt) throws SQLException; void handleOutputParameters(CallableStatement cs) throws SQLException; }</description></item><item><title>StatementHandler</title><link>https://ileonli.github.io/docs/MyBatis/StatementHandler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/MyBatis/StatementHandler/</guid><description>StatementHandler # StatementHandler 接口中的功能很多，例如创建 Statement 对象，为 SQL 语句绑定实参，执行 select、insert、update、delete 等多种类型的 SQL 语句，批量执行 SQL 语句，将结果集映射成结果对象。
public interface StatementHandler { Statement prepare(Connection connection, Integer transactionTimeout) throws SQLException; void parameterize(Statement statement) throws SQLException; void batch(Statement statement) throws SQLException; int update(Statement statement) throws SQLException; &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(Statement statement, ResultHandler resultHandler) throws SQLException; &amp;lt;E&amp;gt; Cursor&amp;lt;E&amp;gt; queryCursor(Statement statement) throws SQLException; BoundSql getBoundSql(); ParameterHandler getParameterHandler(); } prepare：从 Connection 中创建 Statement 对象。 parameterize：绑定 statement 执行时需要的参数。 batch：批量执行 SQL 语句。 update：执行 insert、update 和 delete 操作。 query 和 queryCursor：用于执行 select 操作。 getBoundSql：获取绑定的 SQL。 getParameterHandler：负责处理 SQL 语句中的参数的处理器。 BaseStatementHandler # prepare # BaseStatementHandler 中设计了模板方法 prepare，通过该方法可以获取 Statement 对象。</description></item><item><title>Executor</title><link>https://ileonli.github.io/docs/MyBatis/Executor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/MyBatis/Executor/</guid><description>Executor # SqlSession 中的具体操作都会通过 Executor 接口进行实现。
public class DefaultSqlSession implements SqlSession { ... private final Executor executor; ... } ExecutorType # Executor 一共有三种类型：
SIMPLE： REUSE： BATCH： public enum ExecutorType { SIMPLE, REUSE, BATCH } BaseExecutor # BaseExecutor 是继承自 Executor 接口的抽象类。该类实现了 Executor 中的大部分方法。
该类使用了模板方法模式，继承 BaseExecutor 的子类只需要实现下边的四个基本方法即可完成数据库的相关操作。
public abstract class BaseExecutor implements Executor { ... protected abstract int doUpdate(MappedStatement ms, Object parameter) throws SQLException; protected abstract List&amp;lt;BatchResult&amp;gt; doFlushStatements(boolean isRollback) throws SQLException; protected abstract &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; doQuery(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) throws SQLException; protected abstract &amp;lt;E&amp;gt; Cursor&amp;lt;E&amp;gt; doQueryCursor(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql) throws SQLException; .</description></item><item><title>Cache</title><link>https://ileonli.github.io/docs/MyBatis/Cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/MyBatis/Cache/</guid><description>一级缓存和二级缓存 # MyBatis 提供了二层缓存架构，分别为：一级缓存和二级缓存。
一级缓存 # 一级缓存是会话级别的，MyBatis 每创建一个 SqlSession，就表示开启了一次数据库会话。在一次会话内，可能会在短时间内反复执行完全相同的查询语句。
Executor 对象内会建立一个简单的缓存，在执行查询操作时，会先查询一级缓存，如果其中存在完全一样的查询语句，则直接从一级缓存中取出结果。
一级缓存的生命周期与 SqlSession 相同，SqlSession 内部有 Executor 对象，当调用 SqlSession 的 close() 方法时，会调用 Executor 的 close() 方法。
具体流程 # @Override public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler) throws SQLException { BoundSql boundSql = ms.getBoundSql(parameter); CacheKey key = createCacheKey(ms, parameter, rowBounds, boundSql); return query(ms, parameter, rowBounds, resultHandler, key, boundSql); } @SuppressWarnings(&amp;#34;unchecked&amp;#34;) @Override public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException { ErrorContext.</description></item></channel></rss>