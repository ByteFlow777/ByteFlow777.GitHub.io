<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MyBatis on Leon' Blog</title><link>https://ileonli.github.io/docs/MyBatis/</link><description>Recent content in MyBatis on Leon' Blog</description><generator>Hugo</generator><language>en</language><atom:link href="https://ileonli.github.io/docs/MyBatis/index.xml" rel="self" type="application/rss+xml"/><item><title>SqlSession</title><link>https://ileonli.github.io/docs/MyBatis/SqlSession/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/MyBatis/SqlSession/</guid><description>SqlSession # SalSession 是用于操作数据库的接口，具体的操作都通过此接口。
SqlSessionFactoryBuilder # 此类可以被实例化、使用和丢弃，一旦使用此类创建了 SqlSessionFactory，后续就不需要使用此类了。因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。
可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证 XML 资源可以被释放。
SqlSessionFactory # SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。使用 SqlSessionFactory 的最佳实践是在应用运行期间只创建一次。
SqlSessionFactory 的作用是为了创建 SqlSession 实例。SqlSession 是 MyBatis 执行 SQL 命令的核心接口，通过此实例可以对数据库进行查询、插入、更新和删除操作。
import java.sql.Connection; /** * Creates an {@link SqlSession} out of a connection or a DataSource * * @author Clinton Begin */ public interface SqlSessionFactory { SqlSession openSession(); SqlSession openSession(boolean autoCommit); SqlSession openSession(Connection connection); SqlSession openSession(TransactionIsolationLevel level); SqlSession openSession(ExecutorType execType); SqlSession openSession(ExecutorType execType, boolean autoCommit); SqlSession openSession(ExecutorType execType, TransactionIsolationLevel level); SqlSession openSession(ExecutorType execType, Connection connection); Configuration getConfiguration(); } SqlSessionFactory 主要有两个具体的实现：</description></item><item><title>Executor</title><link>https://ileonli.github.io/docs/MyBatis/Executor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/MyBatis/Executor/</guid><description> Executor #</description></item><item><title>StatementHandler</title><link>https://ileonli.github.io/docs/MyBatis/StatementHandler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/MyBatis/StatementHandler/</guid><description>StatementHandler # StatementHandler 接口中的功能很多，例如创建 Statement 对象，为 SQL 语句绑定实参，执行 select、insert、update、delete 等多种类型的 SQL 语句，批量执行 SQL 语句，将结果集映射成结果对象。
public interface StatementHandler { Statement prepare(Connection connection, Integer transactionTimeout) throws SQLException; void parameterize(Statement statement) throws SQLException; void batch(Statement statement) throws SQLException; int update(Statement statement) throws SQLException; &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(Statement statement, ResultHandler resultHandler) throws SQLException; &amp;lt;E&amp;gt; Cursor&amp;lt;E&amp;gt; queryCursor(Statement statement) throws SQLException; BoundSql getBoundSql(); ParameterHandler getParameterHandler(); } prepare：从 Connection 中创建 Statement 对象。 parameterize：绑定 statement 执行时需要的参数。 batch：批量执行 SQL 语句。 update：执行 insert、update 和 delete 操作。 query 和 queryCursor：用于执行 select 操作。 getBoundSql：获取绑定的 SQL。 getParameterHandler：负责处理 SQL 语句中的参数的处理器。 BaseStatementHandler # prepare # BaseStatementHandler 中设计了模板方法 prepare，通过该方法可以获取 Statement 对象。</description></item></channel></rss>