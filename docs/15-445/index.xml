<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>15-445 on Leon' Blog</title><link>https://ileonli.github.io/docs/15-445/</link><description>Recent content in 15-445 on Leon' Blog</description><generator>Hugo</generator><language>en</language><atom:link href="https://ileonli.github.io/docs/15-445/index.xml" rel="self" type="application/rss+xml"/><item><title>Database Storage</title><link>https://ileonli.github.io/docs/15-445/storage/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/15-445/storage/</guid><description>Database Storage # https://15445.courses.cs.cmu.edu/fall2023/slides/03-storage1.pdf
DBMS 假设数据库主要使用的存储是非易失的（non-volatile）。DBMS 主要工作之一为：管理数据在易失存储设备和非易失存储设备之间的移动。
存储设备 # 对于存储设备来说：速度越快 -&amp;gt; 价钱昂贵，速度越慢 -&amp;gt; 价格便宜。因此，要在价格和速度之间进行一部分取舍。
主流的做法为，采用速度更快的存储设备作为底层设备的缓存。
此课程只关注非易失存储设备
不同存储设备的延迟对比如下：
Intel 开发了 Optane 非易失存储设备，可以提供类似内存的速度和易失性（volatile），但又具有非易失性的特性（non-volatile）。这意味着数据在断电时仍然保持不变，适合用于需要快速恢复状态的应用场景，如数据库和日志记录。
Intel 已经终止了此设备的研发
在非易失存储设备上进行随机读取（random access）比顺序读取（sequential access）慢的多。
为了充分利用顺序读取速度较快的优势，DBMS 可以使用下边的优化方法：
减少写入随机页面的次数：尝试减少对随机存储页面（即内存或磁盘上的页面）的写操作次数。这样做的目的是让数据能够存储在连续的块中。连续的存储块更有利于提高数据的访问速度，因为读取连续的数据比读取散乱分布的数据效率更高。这种优化有助于提高存储系统的性能，特别是在磁盘 I/O 操作方面。 扩展（Extent）：当一次性分配多个页面时，这种分配方式称为扩展。换句话说，一个扩展就是一组连续分配的页面块。通过这种方式，可以更高效地管理存储空间，并进一步确保数据以连续的方式存储，从而提高读写性能。 一个良好的 DBMS 应该有以下设计原则：
允许管理的数据库的数据大小超过内存（RAM）。 尽量减少磁盘读写的次数。 最大化使用顺序读取，减少随机读取的次数。 large stalls：当磁盘读写操作没有得到有效管理时，尤其是在面对随机访问过多或磁盘 I/O 负载过重的情况下，系统可能会经历长时间的等待，导致处理速度明显变慢。
缓冲池 # 当执行引擎（execution engine）需要获取页（page）时，会尝试从缓冲池（buffer pool）中获取。
缓冲池作用为：将保存在磁盘中的页加载到内存中，由于内存通常远远小于磁盘大小，需要采用一些算法（如：LRU）来保证页的加载和换出。
加载到缓冲池中后，我们就可以直接使用此页了。
当需要修改数据时，可以直接对内存中的页进行修改，修改后没写回到磁盘的页称为脏页（dirty page）。
mmap # DBMS 可以使用 mmap 技术，将文件的内容直接映射到程序的地址空间中。
OS 负责管理文件页面的调度和内存交换，因此 DBMS 不需要直接处理这些细节。
当访问 page1 时，会触发缺页中断，将磁盘数据加载到内存中。
当访问 page3 时，会触发缺页中断，将磁盘数据加载到内存中。
当物理内存满了后，操作系统会采用置换算法将内存中的页换出到磁盘中。
但操作系统不知道内存中的页正在进行的操作，如：正处于事务中的页在事务完成前不应该换出。</description></item></channel></rss>