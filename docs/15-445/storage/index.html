<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Database Storage
  #



  https://15445.courses.cs.cmu.edu/fall2023/slides/03-storage1.pdf

DBMS 假设数据库主要使用的存储是非易失的（non-volatile）。DBMS 主要工作之一为：管理数据在易失存储设备和非易失存储设备之间的移动。

  基于磁盘的结构
  #


  存储结构
  #

对于存储设备来说：速度越快->价钱昂贵，速度越慢->价格便宜。因此，要在价格和速度之间进行一部分取舍。
主流的做法为，采用速度更快的存储设备作为底层设备的缓存。

此课程只关注非易失存储设备


  

  

Intel 开发了 Optane 非易失存储设备，可以提供类似内存的速度和易失性（volatile），但又具有非易失性的特性（non-volatile）。这意味着数据在断电时仍然保持不变，适合用于需要快速恢复状态的应用场景，如数据库和日志记录。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://ileonli.github.io/docs/15-445/storage/"><meta property="og:site_name" content="Leon' Blog"><meta property="og:title" content="Database Storage"><meta property="og:description" content=" Database Storage # https://15445.courses.cs.cmu.edu/fall2023/slides/03-storage1.pdf
DBMS 假设数据库主要使用的存储是非易失的（non-volatile）。DBMS 主要工作之一为：管理数据在易失存储设备和非易失存储设备之间的移动。
基于磁盘的结构 # 存储结构 # 对于存储设备来说：速度越快->价钱昂贵，速度越慢->价格便宜。因此，要在价格和速度之间进行一部分取舍。
主流的做法为，采用速度更快的存储设备作为底层设备的缓存。
此课程只关注非易失存储设备
Intel 开发了 Optane 非易失存储设备，可以提供类似内存的速度和易失性（volatile），但又具有非易失性的特性（non-volatile）。这意味着数据在断电时仍然保持不变，适合用于需要快速恢复状态的应用场景，如数据库和日志记录。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2024-09-07T17:05:50+08:00"><title>Database Storage | Leon' Blog</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.c4648f90e7f239143d6b1f74326dc2ce1794185b23b8cbbf3f813cfdf5d576ca.css integrity="sha256-xGSPkOfyORQ9ax90Mm3CzheUGFsjuMu/P4E8/fXVdso=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.643b6a7026e150b598c03377835c22e9d8c047f9919b38c88d70eaab1e5f7aa7.js integrity="sha256-ZDtqcCbhULWYwDN3g1wi6djAR/mRmzjIjXDqqx5feqc=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-EL04QEY330"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EL04QEY330")}</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Leon' Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-dfc62bc51fd10e15afc9a11c29a21438 class=toggle>
<label for=section-dfc62bc51fd10e15afc9a11c29a21438 class="flex justify-between"><a role=button>Java</a></label><ul><li><a href=/docs/Java/Agent/>Agent</a></li><li><a href=/docs/Java/Cleaner/>Cleaner 类</a></li><li><a href=/docs/Java/JDBC/>JDBC</a></li><li><a href=/docs/Java/MethodHandles/>MethodHandles</a></li><li><a href=/docs/Java/DynamicProxy/>动态代理</a></li></ul></li><li><input type=checkbox id=section-068f5864eab5429f74d44490ac7dda4f class=toggle>
<label for=section-068f5864eab5429f74d44490ac7dda4f class="flex justify-between"><a role=button>boltdb</a></label><ul><li><a href=/docs/boltdb/introduction/>boltdb 介绍</a></li><li><a href=/docs/boltdb/node/>boltdb node</a></li><li><a href=/docs/boltdb/transaction/>boltdb 事务</a></li><li><a href=/docs/boltdb/bucket/>boltdb 介绍</a></li><li><a href=/docs/boltdb/storage/>boltdb 存储</a></li><li><a href=/docs/boltdb/page/>boltdb 页结构</a></li></ul></li><li><input type=checkbox id=section-6a1b1f139889384d884552bee56583cd class=toggle checked>
<label for=section-6a1b1f139889384d884552bee56583cd class="flex justify-between"><a role=button>15-445</a></label><ul><li><a href=/docs/15-445/storage/ class=active>Database Storage</a></li></ul></li><li><input type=checkbox id=section-dd174040a908659982d53d695ff59f6c class=toggle>
<label for=section-dd174040a908659982d53d695ff59f6c class="flex justify-between"><a role=button>JVM</a></label><ul><li><a href=/docs/JVM/AsmTools/>AsmTools</a></li><li><a href=/docs/JVM/loading-linking-initializing/>JVM 加载-链接-初始化</a></li><li><input type=checkbox id=section-8116e10cba9ea1a7d22332ccf696967c class=toggle>
<label for=section-8116e10cba9ea1a7d22332ccf696967c class="flex justify-between"><a role=button>字节码</a></label><ul><li><a href=/docs/JVM/ByteCode/ClassFile/>Class 文件结构</a></li><li><a href=/docs/JVM/ByteCode/constant_pool/>常量池</a></li></ul></li></ul></li><li><input type=checkbox id=section-322adad93406759f98a33491e2ecc8af class=toggle>
<label for=section-322adad93406759f98a33491e2ecc8af class="flex justify-between"><a role=button>Linux 网络编程</a></label><ul><li><a href=/docs/system-programming/network-byte-order/>网络字节序</a></li><li><a href=/docs/system-programming/address-families/>网络地址族</a></li><li><a href=/docs/system-programming/block-and-nonblock-io/>（非）阻塞 I/O</a></li><li><a href=/docs/system-programming/multiplexing/>I/O 多路复用</a></li><li><a href=/docs/system-programming/reactor-pattern/>Reactor 模型</a></li><li><a href=/docs/system-programming/sockets/>套接字（socket）</a></li><li><a href=/docs/system-programming/echo-server/>echo 服务器</a></li></ul></li><li><input type=checkbox id=section-bcab9cce661800a90eaf0ba45525a392 class=toggle>
<label for=section-bcab9cce661800a90eaf0ba45525a392 class="flex justify-between"><a role=button>MapDB</a></label><ul><li><a href=/docs/MapDB/BTree/>BTree</a></li></ul></li><li><input type=checkbox id=section-be784f006af4b056e801791bd4131884 class=toggle>
<label for=section-be784f006af4b056e801791bd4131884 class="flex justify-between"><a role=button>MyBatis</a></label><ul><li><a href=/docs/MyBatis/SqlSession/>SqlSession</a></li><li><a href=/docs/MyBatis/Mapper/>Mapper</a></li><li><a href=/docs/MyBatis/ResultSetHandler/>ResultSetHandler</a></li><li><a href=/docs/MyBatis/StatementHandler/>StatementHandler</a></li><li><a href=/docs/MyBatis/Executor/>Executor</a></li><li><a href=/docs/MyBatis/Cache/>Cache</a></li></ul></li><li><input type=checkbox id=section-53f18a28714f2e0ba277c362c8e2fe7d class=toggle>
<label for=section-53f18a28714f2e0ba277c362c8e2fe7d class="flex justify-between"><a role=button>MySQL</a></label><ul></ul></li><li><input type=checkbox id=section-8e8ae3b760618e1158c1946d2d023ca5 class=toggle>
<label for=section-8e8ae3b760618e1158c1946d2d023ca5 class="flex justify-between"><a role=button>Netty</a></label><ul><li><a href=/docs/Netty/ByteBuf/>ByteBuf</a></li><li><a href=/docs/Netty/EventLoop/>EventLoop</a></li><li><a href=/docs/Netty/EventLoopGroup/>EventLoopGroup</a></li><li><a href=/docs/Netty/Channel/>Channel</a></li><li><a href=/docs/Netty/ChannelHandler/>ChannelHandler</a></li><li><a href=/docs/Netty/encoder-and-decoder/>编码器和解码器</a></li></ul></li><li><input type=checkbox id=section-bccb031e3769927ed8f05e90efe74959 class=toggle>
<label for=section-bccb031e3769927ed8f05e90efe74959 class="flex justify-between"><a role=button>Pro Git</a></label><ul><li><a href=/docs/ProGit/Git-%E5%9F%BA%E7%A1%80/>Git 基础</a></li><li><a href=/docs/ProGit/Git-%E5%88%86%E6%94%AF/>Git 分支</a></li></ul></li><li><span>计算机网络</span><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Database Storage</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#database-storage>Database Storage</a><ul><li><a href=#基于磁盘的结构>基于磁盘的结构</a><ul><li><a href=#存储结构>存储结构</a></li><li><a href=#访问时间>访问时间</a></li><li><a href=#随机和顺序读取>随机和顺序读取</a></li><li><a href=#设计原则>设计原则</a></li><li><a href=#面向磁盘的-dbms>面向磁盘的 DBMS</a></li></ul></li><li><a href=#文件存储>文件存储</a><ul><li><a href=#存储管理>存储管理</a></li><li><a href=#数据库页>数据库页</a></li><li><a href=#堆文件>堆文件</a></li></ul></li><li><a href=#页结构>页结构</a><ul><li><a href=#页头>页头</a></li><li><a href=#存储元组>存储元组</a></li><li><a href=#插槽页>插槽页</a></li><li><a href=#record-ids>record ids</a></li></ul></li><li><a href=#元组结构>元组结构</a><ul><li><a href=#元组头>元组头</a></li><li><a href=#元组数据>元组数据</a></li><li><a href=#反规范化>反规范化</a></li></ul></li><li><a href=#基于日志的存储>基于日志的存储</a><ul><li><a href=#日志存储>日志存储</a></li><li><a href=#日志压缩>日志压缩</a></li></ul></li><li><a href=#基于索引组织的存储>基于索引组织的存储</a></li><li><a href=#数据展示>数据展示</a><ul><li><a href=#数据布局>数据布局</a></li><li><a href=#字对齐>字对齐</a></li><li><a href=#数据展示-1>数据展示</a></li><li><a href=#可变精度数字>可变精度数字</a></li><li><a href=#固定精度数字>固定精度数字</a></li><li><a href=#postgres-numeric>Postgres NUMERIC</a></li><li><a href=#mysql-numeric>MySQL NUMERIC</a></li><li><a href=#null-类型>NULL 类型</a></li><li><a href=#较大的值>较大的值</a></li><li><a href=#外部文件存储>外部文件存储</a></li></ul></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=database-storage>Database Storage
<a class=anchor href=#database-storage>#</a></h1><blockquote><p><a href=https://15445.courses.cs.cmu.edu/fall2023/slides/03-storage1.pdf>https://15445.courses.cs.cmu.edu/fall2023/slides/03-storage1.pdf</a></p></blockquote><p>DBMS 假设数据库主要使用的存储是非易失的（non-volatile）。DBMS 主要工作之一为：管理数据在易失存储设备和非易失存储设备之间的移动。</p><h2 id=基于磁盘的结构>基于磁盘的结构
<a class=anchor href=#%e5%9f%ba%e4%ba%8e%e7%a3%81%e7%9b%98%e7%9a%84%e7%bb%93%e6%9e%84>#</a></h2><h3 id=存储结构>存储结构
<a class=anchor href=#%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84>#</a></h3><p>对于存储设备来说：<strong>速度越快->价钱昂贵</strong>，<strong>速度越慢->价格便宜</strong>。因此，要在价格和速度之间进行一部分取舍。</p><p>主流的做法为，采用速度更快的存储设备作为底层设备的缓存。</p><blockquote><p>此课程只关注非易失存储设备</p></blockquote><p><img src=/img/15445/storage1/6.jpg alt></p><p><img src=/img/15445/storage1/7.jpg alt></p><hr><p>Intel 开发了 Optane 非易失存储设备，可以提供类似内存的速度和易失性（volatile），但又具有非易失性的特性（non-volatile）。这意味着数据在断电时仍然保持不变，适合用于需要快速恢复状态的应用场景，如数据库和日志记录。</p><blockquote><p>由于此业务不赚钱，Intel 已经终止了此设备的研发</p></blockquote><p><img src=/img/15445/storage1/11.jpg alt></p><h3 id=访问时间>访问时间
<a class=anchor href=#%e8%ae%bf%e9%97%ae%e6%97%b6%e9%97%b4>#</a></h3><p>不同存储设备的延迟对比如下：</p><p><img src=/img/15445/storage1/16.jpg alt></p><h3 id=随机和顺序读取>随机和顺序读取
<a class=anchor href=#%e9%9a%8f%e6%9c%ba%e5%92%8c%e9%a1%ba%e5%ba%8f%e8%af%bb%e5%8f%96>#</a></h3><p>在<strong>非易失存储设备</strong>上进行随机读取（random access）比顺序读取（sequential access）慢的多。</p><p>为了充分利用顺序读取速度较快的优势，DBMS 可以使用下边的优化方法：</p><ol><li><strong>减少写入随机页面的次数</strong>：尝试减少对随机存储页面（即内存或磁盘上的页面）的写操作次数。这样做的目的是让数据能够存储在连续的块中。连续的存储块更有利于提高数据的访问速度，因为读取连续的数据比读取散乱分布的数据效率更高。这种优化有助于提高存储系统的性能，特别是在磁盘 I/O 操作方面。</li><li><strong>扩展（Extent）</strong>：当一次性分配多个页面时，这种分配方式称为<strong>扩展</strong>。换句话说，一个<strong>扩展</strong>就是一组连续分配的页面块。通过这种方式，可以更高效地管理存储空间，并进一步确保数据以连续的方式存储，从而提高读写性能。</li></ol><p><img src=/img/15445/storage1/17.jpg alt></p><h3 id=设计原则>设计原则
<a class=anchor href=#%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99>#</a></h3><p>一个良好的 DBMS 应该有以下设计原则：</p><ol><li>允许管理的数据库的数据大小超过内存（RAM）。</li><li>尽量减少磁盘读写的次数。</li><li>最大化使用顺序读取，减少随机读取的次数。</li></ol><blockquote><p><strong>large stalls</strong>：当磁盘读写操作没有得到有效管理时，尤其是在面对随机访问过多或磁盘 I/O 负载过重的情况下，系统可能会经历长时间的等待，导致处理速度明显变慢。</p></blockquote><p><img src=/img/15445/storage1/18.jpg alt></p><h3 id=面向磁盘的-dbms>面向磁盘的 DBMS
<a class=anchor href=#%e9%9d%a2%e5%90%91%e7%a3%81%e7%9b%98%e7%9a%84-dbms>#</a></h3><p>当执行引擎（execution engine）需要获取页（page）时，会尝试从缓冲池（buffer pool）中获取。</p><p><strong>缓冲池</strong>作用为：将保存在磁盘中的页加载到内存中，由于内存通常远远小于磁盘大小，需要采用一些算法（如：LRU）来保证页的加载和换出。</p><p>加载到缓冲池中后，我们就可以直接使用此页了。当需要修改数据时，可以直接对内存中的页进行修改，修改后没写回到磁盘的页称为脏页（dirty page）。</p><p><img src=/img/15445/storage1/19.jpg alt></p><h2 id=文件存储>文件存储
<a class=anchor href=#%e6%96%87%e4%bb%b6%e5%ad%98%e5%82%a8>#</a></h2><p>DBMS 会将数据库在磁盘上以特有的格式保存为一个或多个文件。</p><p><img src=/img/15445/storage1/21.jpg alt></p><h3 id=存储管理>存储管理
<a class=anchor href=#%e5%ad%98%e5%82%a8%e7%ae%a1%e7%90%86>#</a></h3><p>存储管理（storage manager）有义务维护数据库的文件。为提高时间（spatial）和空间（temporal）局部性，会采用特定的调度策略。</p><p>数据库文件会被组织为页的集合。存储管理需要处理对页的读写操作以及跟踪空闲的空间。</p><p><img src=/img/15445/storage1/22.jpg alt></p><h3 id=数据库页>数据库页
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e5%ba%93%e9%a1%b5>#</a></h3><p>页是固定大小的数据块，页有以下特性：</p><ol><li>页中的数据块可用于存储元组（tuples）、元数据（meta-data）、索引（indexes）和日志记录（log records）。</li><li>大多数系统会将不同类型的数据分别存储在不同的页中，而不是在同一页内混合存储不同类型的数据。</li><li>每个页独立存储和管理自己的数据，使其在单独读取或处理时不需要引用其他页的数据。</li><li>每个页都有一个唯一的标识符，DBMS 使用中间层将 ID 映射到磁盘上的位置。</li></ol><p><img src=/img/15445/storage1/23.jpg alt></p><hr><p>DBMS 中会存在 3 中不同类型的页：</p><ol><li>硬件页（通常是 4KB）</li><li>OS 页（通常是 4KB，x64 为 2MB/1GB）</li><li>数据库页（512B - 32KB）</li></ol><p>硬件页面（hardware page）是存储设备能够保证写入操作是安全的、不会失败的最大数据块。</p><blockquote><p>存储设备（如固态硬盘、硬盘驱动器等）在执行写入操作时，会以页为单位来处理数据。这些页通常是固定大小的（比如 4KB 或 8KB）。在写入数据时，设备可以确保这些页的数据能够被完整地写入，即使在断电或其他故障的情况下，这些数据也不会损坏或丢失。这样可以保证数据的可靠性和一致性。</p></blockquote><p><img src=/img/15445/storage1/24.jpg alt></p><hr><p>不同的 DBMS 以不同的文件形式管理页：</p><ul><li>Heap File Organization</li><li>Tree File Organization</li><li>Sequential / Sorted File Organization (ISAM)</li><li>Hashing File Organization</li></ul><p><img src=/img/15445/storage1/25.jpg alt></p><h3 id=堆文件>堆文件
<a class=anchor href=#%e5%a0%86%e6%96%87%e4%bb%b6>#</a></h3><p><strong>堆文件（heap file）</strong> 是一种无序的页面集合，其中的元组（记录）以随机顺序存储。</p><p>在单个堆文件中获取第 i 个页是很容易的，由于页大小是固定的，只需要计算偏移值即可，计算公式：<code>offset = Page# x PageSize</code>。</p><p><img src=/img/15445/storage1/26.jpg alt></p><hr><p>如果我们有多个堆文件，需要元数据来跟踪多个文件中存在的页面，以及哪些页面有可用空间。</p><p><img src=/img/15445/storage1/27.jpg alt></p><p><img src=/img/15445/storage1/28.jpg alt></p><h2 id=页结构>页结构
<a class=anchor href=#%e9%a1%b5%e7%bb%93%e6%9e%84>#</a></h2><h3 id=页头>页头
<a class=anchor href=#%e9%a1%b5%e5%a4%b4>#</a></h3><p>每个页包含一个头部的元数据，用于记录页内容的信息。可能会含有一下的元数据：</p><ul><li>Page Size</li><li>Checksum</li><li>DBMS Version</li><li>Transaction Visibility</li><li>Compression / Encoding Meta-data</li><li>Schema Information</li><li>Data Summary / Sketches</li></ul><p><img src=/img/15445/storage1/30.jpg alt></p><h3 id=存储元组>存储元组
<a class=anchor href=#%e5%ad%98%e5%82%a8%e5%85%83%e7%bb%84>#</a></h3><p>如何在页里存储元组数据呢？</p><p><strong>错误的想法（稻草人的想法）</strong>：记录页内元组的数量，然后仅仅在尾部添加新的元组。</p><p><img src=/img/15445/storage1/33.jpg alt></p><hr><p>如果我们需要删除一个元组，页内就会产生空洞。</p><p><img src=/img/15445/storage1/35.jpg alt></p><hr><p>如果我们想将新插入的 4 号页放到刚删除元组的位置，仅靠数量一个元数据是不够的，我们需要额外的元数据。</p><p><img src=/img/15445/storage1/36.jpg alt></p><hr><p>如果元组的长度是可变的话，我们也无法对其进行处理，无法定位到具体的元组。</p><p><img src=/img/15445/storage1/37.jpg alt></p><h3 id=插槽页>插槽页
<a class=anchor href=#%e6%8f%92%e6%a7%bd%e9%a1%b5>#</a></h3><p>可以采用插槽页（slotted pages）的方法，每个插槽存储元组开始的索引位置。</p><blockquote><p>也可以在插槽中存储元组的长度</p></blockquote><p><img src=/img/15445/storage1/39.jpg alt></p><hr><p>插槽数据和元组存储时，增长的方向如下所示：</p><p><img src=/img/15445/storage1/40.jpg alt></p><h4 id=删除元组>删除元组
<a class=anchor href=#%e5%88%a0%e9%99%a4%e5%85%83%e7%bb%84>#</a></h4><p>当我们删除页中元组时，只需要将删除元组前的数据拷贝过来并更新插槽中的索引位置即可。</p><p><img src=/img/15445/storage1/41.jpg alt></p><p><img src=/img/15445/storage1/42.jpg alt></p><p><img src=/img/15445/storage1/43.jpg alt></p><h3 id=record-ids>record ids
<a class=anchor href=#record-ids>#</a></h3><p>有些 DBMS 会在元组内存储一个唯一的记录标识，用于表示其在数据库中的物理位置。</p><p><img src=/img/15445/storage1/44.jpg alt></p><h2 id=元组结构>元组结构
<a class=anchor href=#%e5%85%83%e7%bb%84%e7%bb%93%e6%9e%84>#</a></h2><p>元组本质上是字节序列，DBMS 需要将这些字节解释为<strong>属性类型</strong>和<strong>值</strong>。</p><p><img src=/img/15445/storage1/46.jpg alt></p><h3 id=元组头>元组头
<a class=anchor href=#%e5%85%83%e7%bb%84%e5%a4%b4>#</a></h3><p>每个元组前面都有一个头部，包含关于自身的元数据。</p><p><img src=/img/15445/storage1/47.jpg alt></p><h3 id=元组数据>元组数据
<a class=anchor href=#%e5%85%83%e7%bb%84%e6%95%b0%e6%8d%ae>#</a></h3><p>属性通常按照创建表时指定的顺序存储，这样做的目录是因为<strong>简单</strong>。</p><p><img src=/img/15445/storage1/48.jpg alt></p><h3 id=反规范化>反规范化
<a class=anchor href=#%e5%8f%8d%e8%a7%84%e8%8c%83%e5%8c%96>#</a></h3><p>DBMS 可以将相关联的元组存储在一个页上，这样可以减少 I/O 次数，以提高数据库性能。</p><blockquote><p>更新操作可能会变得更加复杂和昂贵，如果一个数据项在多个页中都有存储（因为相关元组被预连接在一起），更新时需要在多个位置同步更新这些数据。这增加了更新操作的复杂性和时间开销。</p></blockquote><p><img src=/img/15445/storage1/49.jpg alt></p><hr><p>当我们需要使用 <code>JOIN</code> 时，只需要加载一次页即可。可明显减少 I/O 次数。</p><p><img src=/img/15445/storage1/50.jpg alt></p><p><img src=/img/15445/storage1/51.jpg alt></p><p>很多数据库都已经使用了此技术。</p><p><img src=/img/15445/storage1/52.jpg alt></p><h2 id=基于日志的存储>基于日志的存储
<a class=anchor href=#%e5%9f%ba%e4%ba%8e%e6%97%a5%e5%bf%97%e7%9a%84%e5%ad%98%e5%82%a8>#</a></h2><h3 id=日志存储>日志存储
<a class=anchor href=#%e6%97%a5%e5%bf%97%e5%ad%98%e5%82%a8>#</a></h3><p>数据库管理系统（DBMS）不再将元组存储在页中，而是维护一个日志来记录对元组的更改。</p><p>DBMS 只需要将新的日志条目追加到内存缓冲中，并顺序写入磁盘中。</p><p><img src=/img/15445/storage2/7.jpg alt></p><p>DBMS 存储包含对元组进行修改的记录（<code>PUT</code> 和 <code>DELETE</code>）。</p><ul><li>每个日志记录包含元组的唯一标识符。</li><li><code>PUT</code> 记录包含元组的内容。</li><li><code>DELETE</code> 标记元组被删掉了。</li></ul><p><img src=/img/15445/storage2/8.jpg alt></p><p>数据库管理系统有时会在事务处理过程中将未完全填满的数据页写入磁盘，但在当前讨论的上下文中，这个细节并不重要，因此可以暂时忽略</p><p><img src=/img/15445/storage2/9.jpg alt></p><p>为读取给定 <code>id</code> 的元组，DBMS 只需要从最新的日志扫描到最旧的日志，找到此 <code>id</code> 的第一条日志，即为最新日志记录。</p><p><img src=/img/15445/storage2/10.jpg alt></p><p>为加快扫描速度，可以维护一个索引，将元组 <code>id</code> 与最新的日志记录映射起来。</p><ul><li>如果日志记录在内存中，直接读取即可。</li><li>如果日志记录在磁盘上，从磁盘拉取到内存中。</li></ul><p><img src=/img/15445/storage2/11.jpg alt></p><h3 id=日志压缩>日志压缩
<a class=anchor href=#%e6%97%a5%e5%bf%97%e5%8e%8b%e7%bc%a9>#</a></h3><p>DBMS 不需要一直维护所有元组的旧日志条目（只需要维护最新的一条即可）。</p><p>定期的压缩页以减少浪费的空间。</p><p><img src=/img/15445/storage2/13.jpg alt></p><hr><p>日志压缩后，DBMS 无需维护页内记录的时间（temporal）顺序，每个元组 <code>id</code> 在页内最多出现一次。</p><p>DBMS 可以基于 <code>id</code> 对页进行排序，以提升查找性能。</p><ul><li>此排序叫做排序字符串表（SSTables）。</li><li>在头部嵌入索引或过滤器以减少搜索时间。</li></ul><p><img src=/img/15445/storage2/14.jpg alt></p><p><img src=/img/15445/storage2/15.jpg alt></p><hr><p>通过移除不必要的记录，将较大的驻留在磁盘上的日志文件合并为较小的文件。</p><p><img src=/img/15445/storage2/16.jpg alt></p><p><img src=/img/15445/storage2/17.jpg alt></p><p><img src=/img/15445/storage2/18.jpg alt></p><p>可以将日志文件进行分层，使用多级层次（levels）来管理数据文件。</p><ul><li><strong>L0 层（Level 0）</strong>：这是最顶层，写入的数据首先被放入这个层中。L0 层的数据文件可以彼此重叠（即键值范围可以有交集），因此查询时需要扫描所有的 L0 文件。</li><li><strong>L1 层及以下</strong>：当 L0 层的数据文件达到一定数量时，这些文件会被合并（compaction）到 L1 层。L1 层及更低层的文件不允许有重叠，每个文件都有一个特定的键值范围。合并时会将文件分配到适当的层级，并确保文件之间没有键值范围的重叠。</li></ul><p><img src=/img/15445/storage2/19.jpg alt></p><p><img src=/img/15445/storage2/20.jpg alt></p><p><img src=/img/15445/storage2/21.jpg alt></p><p><img src=/img/15445/storage2/22.jpg alt></p><hr><p>目前，基于日志的存储管理方法越来越广泛。基于日志的存储方法有以下缺点：</p><ul><li><strong>写放大（Write-Amplification）</strong>：为了写入一定量的数据而实际执行的写操作量比预期要大的现象，出现此现象的原因在于：<strong>数据压缩和合并</strong>、<strong>日志记录</strong>。</li><li><strong>压缩操作是非常昂贵的</strong>：此操作需要对所有文件进行扫描合并，是非常耗费时间的。</li></ul><p><img src=/img/15445/storage2/23.jpg alt></p><h2 id=基于索引组织的存储>基于索引组织的存储
<a class=anchor href=#%e5%9f%ba%e4%ba%8e%e7%b4%a2%e5%bc%95%e7%bb%84%e7%bb%87%e7%9a%84%e5%ad%98%e5%82%a8>#</a></h2><p>已经探讨过的两种存储方式都依赖于通过索引找到元组。如果 DBMS 能使用索引的方式将元组自动排序呢？</p><p><img src=/img/15445/storage2/24.jpg alt></p><p>DBMS 将表的所有元组作为索引结构的值，这些元组会使用类似于插槽页的布局。在页内，元组会基于 key 进行排序。</p><p><img src=/img/15445/storage2/25.jpg alt></p><h2 id=数据展示>数据展示
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e5%b1%95%e7%a4%ba>#</a></h2><h3 id=数据布局>数据布局
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e5%b8%83%e5%b1%80>#</a></h3><p>元组本质上是字节序列，DBMS 需要将这些字节解释为<strong>类型</strong>和<strong>值</strong>。</p><p>数据库管理系统（DBMS）的目录中包含关于表的模式信息，系统使用这些信息来确定元组的布局。</p><p><img src=/img/15445/storage2/26.jpg alt></p><hr><p>当我们创建一个 <code>AndySux</code> 表时，元组对应的形式如下图所示。当使用数据是，只需要将地址转型为对象的类型即可。</p><p><img src=/img/15445/storage2/27.jpg alt></p><h3 id=字对齐>字对齐
<a class=anchor href=#%e5%ad%97%e5%af%b9%e9%bd%90>#</a></h3><p>元组中的所有属性必须进行字对齐，以便 CPU 可以在没有任何意外行为或额外工作的情况下访问它们。</p><p><img src=/img/15445/storage2/28.jpg alt></p><p>当数据没有正确对齐时，会带来一些问题：</p><ul><li><strong>执行额外读取操作（Perform Extra Reads）</strong>：执行两次读取操作，分别加载数据字的不同部分，然后将它们重新组合起来。</li><li><strong>随机读取（Random Reads）</strong>：系统可能随机选择一组字节来填充 64 位字（word），而不是确保数据对齐。这种情况下，读取的数据可能不是预期的有效数据。</li><li><strong>拒绝（Reject）</strong>：直接拒绝未对齐的数据访问，并抛出异常。希望上层应用能够处理这种情况。</li></ul><p><img src=/img/15445/storage2/29.jpg alt></p><hr><p>为确保元组是字对齐的，可以在属性后添加空位。</p><p><img src=/img/15445/storage2/30.jpg alt></p><p>通过交换元组内属性存储的物理结构顺序以确保对齐，可能仍需要<strong>填充</strong>。</p><p><img src=/img/15445/storage2/31.jpg alt></p><h3 id=数据展示-1>数据展示
<a class=anchor href=#%e6%95%b0%e6%8d%ae%e5%b1%95%e7%a4%ba-1>#</a></h3><p>DBMS 中的数据类型及其对应的数据展示如下：</p><p><img src=/img/15445/storage2/32.jpg alt></p><h3 id=可变精度数字>可变精度数字
<a class=anchor href=#%e5%8f%af%e5%8f%98%e7%b2%be%e5%ba%a6%e6%95%b0%e5%ad%97>#</a></h3><p>可变精度数字类型可以直接使用 C/C++ 的支持类型。</p><p><img src=/img/15445/storage2/33.jpg alt></p><p>可变精度无法保证精确的值，只能进行近似表示。</p><p><img src=/img/15445/storage2/34.jpg alt></p><h3 id=固定精度数字>固定精度数字
<a class=anchor href=#%e5%9b%ba%e5%ae%9a%e7%b2%be%e5%ba%a6%e6%95%b0%e5%ad%97>#</a></h3><p>该类型支持任意精度和小数位数。这意味着它们可以表示非常大的数字或者非常精确的小数，而不会因为存储限制而失去精度。</p><p><img src=/img/15445/storage2/35.jpg alt></p><h3 id=postgres-numeric>Postgres NUMERIC
<a class=anchor href=#postgres-numeric>#</a></h3><p><img src=/img/15445/storage2/36.jpg alt></p><p><img src=/img/15445/storage2/37.jpg alt></p><p><a href=https://doxygen.postgresql.org/pgtypes__numeric_8h.html#af2fdf50e9e71e777deaff8c4453909ba>PGTYPESnumeric_add()</a></p><p><img src=/img/15445/storage2/38.jpg alt></p><h3 id=mysql-numeric>MySQL NUMERIC
<a class=anchor href=#mysql-numeric>#</a></h3><p><img src=/img/15445/storage2/39.jpg alt></p><p><img src=/img/15445/storage2/40.jpg alt></p><p><a href=https://github.com/mysql/mysql-server/blob/d69a12a94538d2d17c0cc45abedd57648a7b2ebd/strings/decimal.cc#L1841>do_add()</a></p><h3 id=null-类型>NULL 类型
<a class=anchor href=#null-%e7%b1%bb%e5%9e%8b>#</a></h3><ul><li><strong>Null Column Bitmap Header</strong>：在每个元组的头部存储一个位图，每个位对应一个列。如果某列的值是 <code>NULL</code>，对应的位就设置为 1，否则为 0。</li><li><strong>Special Values</strong>：为数据类型指定一个特殊的值来表示 <code>NULL</code>（例如，使用 <code>INT32_MIN</code> 表示整数类型的 <code>NULL</code>）。</li><li><strong>Per Attribute Null Flag</strong>：为每个属性存储一个标志来标记该值是否为 <code>NULL</code>。这种方法需要比单个比特更多的空间，因为这会影响字对齐。</li></ul><p><img src=/img/15445/storage2/41.jpg alt></p><h3 id=较大的值>较大的值
<a class=anchor href=#%e8%be%83%e5%a4%a7%e7%9a%84%e5%80%bc>#</a></h3><p>大多数 DBMS 不允许一个元组超过一个页的大小。</p><p>为了存储比一个页还大的值，DBMS 使用单独的 <code>overflow</code> 存储页进行存储。</p><ul><li>Postgres: TOAST (>2KB)</li><li>MySQL: Overflow (>½ size of page)</li><li>SQL Server: Overflow (>size of page)</li></ul><p><img src=/img/15445/storage2/42.jpg alt></p><h3 id=外部文件存储>外部文件存储
<a class=anchor href=#%e5%a4%96%e9%83%a8%e6%96%87%e4%bb%b6%e5%ad%98%e5%82%a8>#</a></h3><p>一些系统允许在外部文件中存储较大的值，视为 <strong>BLOB</strong> 类型。</p><ul><li>Oracle: <strong>BFILE</strong> data type</li><li>Microsoft: <strong>FILESTREAM</strong> data type</li></ul><p>DBMS 无法操作外部文件的内容。无<strong>持久化</strong>和<strong>事务</strong>的保护。</p><p><img src=/img/15445/storage2/43.jpg alt></p><p><img src=/img/15445/storage2/44.jpg alt></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#database-storage>Database Storage</a><ul><li><a href=#基于磁盘的结构>基于磁盘的结构</a><ul><li><a href=#存储结构>存储结构</a></li><li><a href=#访问时间>访问时间</a></li><li><a href=#随机和顺序读取>随机和顺序读取</a></li><li><a href=#设计原则>设计原则</a></li><li><a href=#面向磁盘的-dbms>面向磁盘的 DBMS</a></li></ul></li><li><a href=#文件存储>文件存储</a><ul><li><a href=#存储管理>存储管理</a></li><li><a href=#数据库页>数据库页</a></li><li><a href=#堆文件>堆文件</a></li></ul></li><li><a href=#页结构>页结构</a><ul><li><a href=#页头>页头</a></li><li><a href=#存储元组>存储元组</a></li><li><a href=#插槽页>插槽页</a></li><li><a href=#record-ids>record ids</a></li></ul></li><li><a href=#元组结构>元组结构</a><ul><li><a href=#元组头>元组头</a></li><li><a href=#元组数据>元组数据</a></li><li><a href=#反规范化>反规范化</a></li></ul></li><li><a href=#基于日志的存储>基于日志的存储</a><ul><li><a href=#日志存储>日志存储</a></li><li><a href=#日志压缩>日志压缩</a></li></ul></li><li><a href=#基于索引组织的存储>基于索引组织的存储</a></li><li><a href=#数据展示>数据展示</a><ul><li><a href=#数据布局>数据布局</a></li><li><a href=#字对齐>字对齐</a></li><li><a href=#数据展示-1>数据展示</a></li><li><a href=#可变精度数字>可变精度数字</a></li><li><a href=#固定精度数字>固定精度数字</a></li><li><a href=#postgres-numeric>Postgres NUMERIC</a></li><li><a href=#mysql-numeric>MySQL NUMERIC</a></li><li><a href=#null-类型>NULL 类型</a></li><li><a href=#较大的值>较大的值</a></li><li><a href=#外部文件存储>外部文件存储</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>