<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Database Storage # https://15445.courses.cs.cmu.edu/fall2023/slides/03-storage1.pdf
DBMS 假设数据库主要使用的存储是非易失的（non-volatile）。DBMS 主要工作之一为：管理数据在易失存储设备和非易失存储设备之间的移动。
存储设备 # 对于存储设备来说：速度越快 -> 价钱昂贵，速度越慢 -> 价格便宜。因此，要在价格和速度之间进行一部分取舍。
主流的做法为，采用速度更快的存储设备作为底层设备的缓存。
此课程只关注非易失存储设备
不同存储设备的延迟对比如下：
Intel 开发了 Optane 非易失存储设备，可以提供类似内存的速度和易失性（volatile），但又具有非易失性的特性（non-volatile）。这意味着数据在断电时仍然保持不变，适合用于需要快速恢复状态的应用场景，如数据库和日志记录。
Intel 已经终止了此设备的研发
在非易失存储设备上进行随机读取（random access）比顺序读取（sequential access）慢的多。
为了充分利用顺序读取速度较快的优势，DBMS 可以使用下边的优化方法：
减少写入随机页面的次数：尝试减少对随机存储页面（即内存或磁盘上的页面）的写操作次数。这样做的目的是让数据能够存储在连续的块中。连续的存储块更有利于提高数据的访问速度，因为读取连续的数据比读取散乱分布的数据效率更高。这种优化有助于提高存储系统的性能，特别是在磁盘 I/O 操作方面。 扩展（Extent）：当一次性分配多个页面时，这种分配方式称为扩展。换句话说，一个扩展就是一组连续分配的页面块。通过这种方式，可以更高效地管理存储空间，并进一步确保数据以连续的方式存储，从而提高读写性能。 一个良好的 DBMS 应该有以下设计原则：
允许管理的数据库的数据大小超过内存（RAM）。 尽量减少磁盘读写的次数。 最大化使用顺序读取，减少随机读取的次数。 large stalls：当磁盘读写操作没有得到有效管理时，尤其是在面对随机访问过多或磁盘 I/O 负载过重的情况下，系统可能会经历长时间的等待，导致处理速度明显变慢。
缓冲池 # 当执行引擎（execution engine）需要获取页（page）时，会尝试从缓冲池（buffer pool）中获取。
缓冲池作用为：将保存在磁盘中的页加载到内存中，由于内存通常远远小于磁盘大小，需要采用一些算法（如：LRU）来保证页的加载和换出。
加载到缓冲池中后，我们就可以直接使用此页了。
当需要修改数据时，可以直接对内存中的页进行修改，修改后没写回到磁盘的页称为脏页（dirty page）。
mmap # DBMS 可以使用 mmap 技术，将文件的内容直接映射到程序的地址空间中。
OS 负责管理文件页面的调度和内存交换，因此 DBMS 不需要直接处理这些细节。
当访问 page1 时，会触发缺页中断，将磁盘数据加载到内存中。
当访问 page3 时，会触发缺页中断，将磁盘数据加载到内存中。
当物理内存满了后，操作系统会采用置换算法将内存中的页换出到磁盘中。
但操作系统不知道内存中的页正在进行的操作，如：正处于事务中的页在事务完成前不应该换出。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://ileonli.github.io/docs/15-445/storage/"><meta property="og:site_name" content="Leon' Blog"><meta property="og:title" content="Database Storage"><meta property="og:description" content="Database Storage # https://15445.courses.cs.cmu.edu/fall2023/slides/03-storage1.pdf
DBMS 假设数据库主要使用的存储是非易失的（non-volatile）。DBMS 主要工作之一为：管理数据在易失存储设备和非易失存储设备之间的移动。
存储设备 # 对于存储设备来说：速度越快 -> 价钱昂贵，速度越慢 -> 价格便宜。因此，要在价格和速度之间进行一部分取舍。
主流的做法为，采用速度更快的存储设备作为底层设备的缓存。
此课程只关注非易失存储设备
不同存储设备的延迟对比如下：
Intel 开发了 Optane 非易失存储设备，可以提供类似内存的速度和易失性（volatile），但又具有非易失性的特性（non-volatile）。这意味着数据在断电时仍然保持不变，适合用于需要快速恢复状态的应用场景，如数据库和日志记录。
Intel 已经终止了此设备的研发
在非易失存储设备上进行随机读取（random access）比顺序读取（sequential access）慢的多。
为了充分利用顺序读取速度较快的优势，DBMS 可以使用下边的优化方法：
减少写入随机页面的次数：尝试减少对随机存储页面（即内存或磁盘上的页面）的写操作次数。这样做的目的是让数据能够存储在连续的块中。连续的存储块更有利于提高数据的访问速度，因为读取连续的数据比读取散乱分布的数据效率更高。这种优化有助于提高存储系统的性能，特别是在磁盘 I/O 操作方面。 扩展（Extent）：当一次性分配多个页面时，这种分配方式称为扩展。换句话说，一个扩展就是一组连续分配的页面块。通过这种方式，可以更高效地管理存储空间，并进一步确保数据以连续的方式存储，从而提高读写性能。 一个良好的 DBMS 应该有以下设计原则：
允许管理的数据库的数据大小超过内存（RAM）。 尽量减少磁盘读写的次数。 最大化使用顺序读取，减少随机读取的次数。 large stalls：当磁盘读写操作没有得到有效管理时，尤其是在面对随机访问过多或磁盘 I/O 负载过重的情况下，系统可能会经历长时间的等待，导致处理速度明显变慢。
缓冲池 # 当执行引擎（execution engine）需要获取页（page）时，会尝试从缓冲池（buffer pool）中获取。
缓冲池作用为：将保存在磁盘中的页加载到内存中，由于内存通常远远小于磁盘大小，需要采用一些算法（如：LRU）来保证页的加载和换出。
加载到缓冲池中后，我们就可以直接使用此页了。
当需要修改数据时，可以直接对内存中的页进行修改，修改后没写回到磁盘的页称为脏页（dirty page）。
mmap # DBMS 可以使用 mmap 技术，将文件的内容直接映射到程序的地址空间中。
OS 负责管理文件页面的调度和内存交换，因此 DBMS 不需要直接处理这些细节。
当访问 page1 时，会触发缺页中断，将磁盘数据加载到内存中。
当访问 page3 时，会触发缺页中断，将磁盘数据加载到内存中。
当物理内存满了后，操作系统会采用置换算法将内存中的页换出到磁盘中。
但操作系统不知道内存中的页正在进行的操作，如：正处于事务中的页在事务完成前不应该换出。"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:modified_time" content="2024-09-01T21:53:12+08:00"><title>Database Storage | Leon' Blog</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.c4648f90e7f239143d6b1f74326dc2ce1794185b23b8cbbf3f813cfdf5d576ca.css integrity="sha256-xGSPkOfyORQ9ax90Mm3CzheUGFsjuMu/P4E8/fXVdso=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.6cabe903f8c9db4ee1b709631719bf7be31283e9dbec26e8db23c738192727a2.js integrity="sha256-bKvpA/jJ207htwljFxm/e+MSg+nb7Cbo2yPHOBknJ6I=" crossorigin=anonymous></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk=" crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-EL04QEY330"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EL04QEY330")}</script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>Leon' Blog</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-dfc62bc51fd10e15afc9a11c29a21438 class=toggle>
<label for=section-dfc62bc51fd10e15afc9a11c29a21438 class="flex justify-between"><a role=button>Java</a></label><ul><li><a href=/docs/Java/Agent/>Agent</a></li><li><a href=/docs/Java/Cleaner/>Cleaner 类</a></li><li><a href=/docs/Java/JDBC/>JDBC</a></li><li><a href=/docs/Java/MethodHandles/>MethodHandles</a></li><li><a href=/docs/Java/DynamicProxy/>动态代理</a></li></ul></li><li><input type=checkbox id=section-068f5864eab5429f74d44490ac7dda4f class=toggle>
<label for=section-068f5864eab5429f74d44490ac7dda4f class="flex justify-between"><a role=button>boltdb</a></label><ul><li><a href=/docs/boltdb/introduction/>boltdb 介绍</a></li><li><a href=/docs/boltdb/node/>boltdb node</a></li><li><a href=/docs/boltdb/transaction/>boltdb 事务</a></li><li><a href=/docs/boltdb/bucket/>boltdb 介绍</a></li><li><a href=/docs/boltdb/storage/>boltdb 存储</a></li><li><a href=/docs/boltdb/page/>boltdb 页结构</a></li></ul></li><li><input type=checkbox id=section-6a1b1f139889384d884552bee56583cd class=toggle checked>
<label for=section-6a1b1f139889384d884552bee56583cd class="flex justify-between"><a role=button>15-445</a></label><ul><li><a href=/docs/15-445/storage/ class=active>Database Storage</a></li></ul></li><li><input type=checkbox id=section-dd174040a908659982d53d695ff59f6c class=toggle>
<label for=section-dd174040a908659982d53d695ff59f6c class="flex justify-between"><a role=button>JVM</a></label><ul><li><a href=/docs/JVM/AsmTools/>AsmTools</a></li><li><a href=/docs/JVM/loading-linking-initializing/>JVM 加载-链接-初始化</a></li><li><input type=checkbox id=section-8116e10cba9ea1a7d22332ccf696967c class=toggle>
<label for=section-8116e10cba9ea1a7d22332ccf696967c class="flex justify-between"><a role=button>字节码</a></label><ul><li><a href=/docs/JVM/ByteCode/ClassFile/>Class 文件结构</a></li><li><a href=/docs/JVM/ByteCode/constant_pool/>常量池</a></li></ul></li></ul></li><li><input type=checkbox id=section-322adad93406759f98a33491e2ecc8af class=toggle>
<label for=section-322adad93406759f98a33491e2ecc8af class="flex justify-between"><a role=button>Linux 网络编程</a></label><ul><li><a href=/docs/system-programming/network-byte-order/>网络字节序</a></li><li><a href=/docs/system-programming/address-families/>网络地址族</a></li><li><a href=/docs/system-programming/block-and-nonblock-io/>（非）阻塞 I/O</a></li><li><a href=/docs/system-programming/multiplexing/>I/O 多路复用</a></li><li><a href=/docs/system-programming/reactor-pattern/>Reactor 模型</a></li><li><a href=/docs/system-programming/sockets/>套接字（socket）</a></li><li><a href=/docs/system-programming/echo-server/>echo 服务器</a></li></ul></li><li><input type=checkbox id=section-bcab9cce661800a90eaf0ba45525a392 class=toggle>
<label for=section-bcab9cce661800a90eaf0ba45525a392 class="flex justify-between"><a role=button>MapDB</a></label><ul><li><a href=/docs/MapDB/BTree/>BTree</a></li></ul></li><li><input type=checkbox id=section-be784f006af4b056e801791bd4131884 class=toggle>
<label for=section-be784f006af4b056e801791bd4131884 class="flex justify-between"><a role=button>MyBatis</a></label><ul><li><a href=/docs/MyBatis/SqlSession/>SqlSession</a></li><li><a href=/docs/MyBatis/Mapper/>Mapper</a></li><li><a href=/docs/MyBatis/ResultSetHandler/>ResultSetHandler</a></li><li><a href=/docs/MyBatis/StatementHandler/>StatementHandler</a></li><li><a href=/docs/MyBatis/Executor/>Executor</a></li><li><a href=/docs/MyBatis/Cache/>Cache</a></li></ul></li><li><input type=checkbox id=section-8e8ae3b760618e1158c1946d2d023ca5 class=toggle>
<label for=section-8e8ae3b760618e1158c1946d2d023ca5 class="flex justify-between"><a role=button>Netty</a></label><ul><li><a href=/docs/Netty/ByteBuf/>ByteBuf</a></li><li><a href=/docs/Netty/EventLoop/>EventLoop</a></li><li><a href=/docs/Netty/EventLoopGroup/>EventLoopGroup</a></li><li><a href=/docs/Netty/Channel/>Channel</a></li><li><a href=/docs/Netty/ChannelHandler/>ChannelHandler</a></li><li><a href=/docs/Netty/encoder-and-decoder/>编码器和解码器</a></li></ul></li><li><input type=checkbox id=section-bccb031e3769927ed8f05e90efe74959 class=toggle>
<label for=section-bccb031e3769927ed8f05e90efe74959 class="flex justify-between"><a role=button>Pro Git</a></label><ul><li><a href=/docs/ProGit/Git-%E5%9F%BA%E7%A1%80/>Git 基础</a></li><li><a href=/docs/ProGit/Git-%E5%88%86%E6%94%AF/>Git 分支</a></li></ul></li><li><span>计算机网络</span><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>Database Storage</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#database-storage>Database Storage</a><ul><li><a href=#存储设备>存储设备</a></li><li><a href=#缓冲池>缓冲池</a></li><li><a href=#mmap>mmap</a></li><li><a href=#文件存储>文件存储</a><ul><li><a href=#页page>页（page）</a></li><li><a href=#堆文件>堆文件</a></li><li><a href=#存储元组>存储元组</a></li></ul></li><li><a href=#元组格式>元组格式</a><ul><li><a href=#元组头>元组头</a></li><li><a href=#元组数据>元组数据</a></li><li><a href=#反规范化>反规范化</a></li></ul></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=database-storage>Database Storage
<a class=anchor href=#database-storage>#</a></h1><blockquote><p><a href=https://15445.courses.cs.cmu.edu/fall2023/slides/03-storage1.pdf>https://15445.courses.cs.cmu.edu/fall2023/slides/03-storage1.pdf</a></p></blockquote><p>DBMS 假设数据库主要使用的存储是非易失的（non-volatile）。DBMS 主要工作之一为：管理数据在易失存储设备和非易失存储设备之间的移动。</p><p><img src=/img/15445/storage1/4.jpg alt></p><h2 id=存储设备>存储设备
<a class=anchor href=#%e5%ad%98%e5%82%a8%e8%ae%be%e5%a4%87>#</a></h2><p>对于存储设备来说：速度越快 -> 价钱昂贵，速度越慢 -> 价格便宜。因此，要在价格和速度之间进行一部分取舍。</p><p>主流的做法为，采用速度更快的存储设备作为底层设备的缓存。</p><blockquote><p>此课程只关注非易失存储设备</p></blockquote><p><img src=/img/15445/storage1/5.jpg alt></p><p>不同存储设备的延迟对比如下：</p><p><img src=/img/15445/storage1/12.jpg alt></p><hr><p>Intel 开发了 Optane 非易失存储设备，可以提供类似内存的速度和易失性（volatile），但又具有非易失性的特性（non-volatile）。这意味着数据在断电时仍然保持不变，适合用于需要快速恢复状态的应用场景，如数据库和日志记录。</p><blockquote><p>Intel 已经终止了此设备的研发</p></blockquote><p><img src=/img/15445/storage1/10.jpg alt></p><hr><p>在<strong>非易失存储设备</strong>上进行随机读取（random access）比顺序读取（sequential access）慢的多。</p><p>为了充分利用顺序读取速度较快的优势，DBMS 可以使用下边的优化方法：</p><ol><li><strong>减少写入随机页面的次数</strong>：尝试减少对随机存储页面（即内存或磁盘上的页面）的写操作次数。这样做的目的是让数据能够存储在连续的块中。连续的存储块更有利于提高数据的访问速度，因为读取连续的数据比读取散乱分布的数据效率更高。这种优化有助于提高存储系统的性能，特别是在磁盘 I/O 操作方面。</li><li><strong>扩展（Extent）</strong>：当一次性分配多个页面时，这种分配方式称为<strong>扩展</strong>。换句话说，一个<strong>扩展</strong>就是一组连续分配的页面块。通过这种方式，可以更高效地管理存储空间，并进一步确保数据以连续的方式存储，从而提高读写性能。</li></ol><p><img src=/img/15445/storage1/13.jpg alt></p><hr><p>一个良好的 DBMS 应该有以下设计原则：</p><ol><li>允许管理的数据库的数据大小超过内存（RAM）。</li><li>尽量减少磁盘读写的次数。</li><li>最大化使用顺序读取，减少随机读取的次数。</li></ol><blockquote><p><strong>large stalls</strong>：当磁盘读写操作没有得到有效管理时，尤其是在面对随机访问过多或磁盘 I/O 负载过重的情况下，系统可能会经历长时间的等待，导致处理速度明显变慢。</p></blockquote><p><img src=/img/15445/storage1/14.jpg alt></p><h2 id=缓冲池>缓冲池
<a class=anchor href=#%e7%bc%93%e5%86%b2%e6%b1%a0>#</a></h2><p>当执行引擎（execution engine）需要获取页（page）时，会尝试从缓冲池（buffer pool）中获取。</p><p><strong>缓冲池</strong>作用为：将保存在磁盘中的页加载到内存中，由于内存通常远远小于磁盘大小，需要采用一些算法（如：LRU）来保证页的加载和换出。</p><p><img src=/img/15445/storage1/15.jpg alt></p><p>加载到缓冲池中后，我们就可以直接使用此页了。</p><p><img src=/img/15445/storage1/16.jpg alt></p><hr><p>当需要修改数据时，可以直接对内存中的页进行修改，修改后没写回到磁盘的页称为脏页（dirty page）。</p><p><img src=/img/15445/storage1/17.jpg alt></p><h2 id=mmap>mmap
<a class=anchor href=#mmap>#</a></h2><p>DBMS 可以使用 <code>mmap</code> 技术，将文件的内容直接映射到程序的地址空间中。</p><p>OS 负责管理文件页面的调度和内存交换，因此 DBMS 不需要直接处理这些细节。</p><p><img src=/img/15445/storage1/19.jpg alt></p><p>当访问 <code>page1</code> 时，会触发<strong>缺页中断</strong>，将磁盘数据加载到内存中。</p><p><img src=/img/15445/storage1/20.jpg alt></p><p>当访问 <code>page3</code> 时，会触发<strong>缺页中断</strong>，将磁盘数据加载到内存中。</p><p><img src=/img/15445/storage1/21.jpg alt></p><hr><p>当物理内存满了后，操作系统会采用<strong>置换算法</strong>将内存中的页换出到磁盘中。</p><p>但操作系统不知道内存中的页正在进行的操作，如：正处于事务中的页在事务完成前不应该换出。</p><p><img src=/img/15445/storage1/22.jpg alt></p><hr><p>当多线程访问 <code>mmap</code> 文件时，就会发生一些问题。</p><p><img src=/img/15445/storage1/23.jpg alt></p><hr><p>使用 <code>mmap</code> 会有下边各种各样的问题：</p><ol><li><strong>事务安全（Transaction Safety）</strong>：OS 可能在任意时间将脏页刷新磁盘中。</li><li><strong>I/O 停顿（I/O Stalls）</strong>：DBMS 不知道有哪些页在内存中，当发生缺页时，OS 会将线程停顿。</li><li><strong>错误处理（Error Handling）</strong>：DBMS 必须处理由于访问无效页产生的 <code>SIGBUS</code> 信号。</li><li><strong>性能问题（Performance Issues）</strong>：会发生 OS 数据结构冲突，TLB 清空。</li></ol><p><img src=/img/15445/storage1/24.jpg alt></p><hr><p>可以使用 <code>madvise</code>、<code>mlock</code> 和 <code>msync</code> 来解决 <code>mmap</code> 带来的问题。</p><p><img src=/img/15445/storage1/25.jpg alt></p><hr><p>DBMS 会尽可能控制任何事情，可以比 OS 做的更好。</p><p><img src=/img/15445/storage1/27.jpg alt></p><hr><p><a href=https://db.cs.cmu.edu/papers/2022/cidr2022-p13-crotty.pdf>Are You Sure You Want to Use MMAP in Your Database Management System?</a> 介绍了为什么不推荐在 DBMS 中使用 <code>mmap</code> 的原因。</p><p><img src=/img/15445/storage1/28.jpg alt></p><h2 id=文件存储>文件存储
<a class=anchor href=#%e6%96%87%e4%bb%b6%e5%ad%98%e5%82%a8>#</a></h2><p>DBMS 会将数据库在磁盘上以特有的格式保存为一个或多个文件。</p><p><img src=/img/15445/storage1/31.jpg alt></p><hr><p>存储管理（storage manager）有义务维护数据库的文件。为提高时间（spatial）和空间（temporal）局部性，会采用特定的调度策略。</p><p>数据库文件会被组织为页的集合。存储管理需要处理对页的读写操作以及跟踪空闲的空间。</p><p><img src=/img/15445/storage1/32.jpg alt></p><h3 id=页page>页（page）
<a class=anchor href=#%e9%a1%b5page>#</a></h3><p>页是固定大小的数据块，页有以下特性：</p><ol><li>页中的数据块可用于存储元组（tuples）、元数据（meta-data）、索引（indexes）和日志记录（log records）。</li><li>大多数系统会将不同类型的数据分别存储在不同的页中，而不是在同一页内混合存储不同类型的数据。</li><li>每个页独立存储和管理自己的数据，使其在单独读取或处理时不需要引用其他页的数据。</li><li>每个页都有一个唯一的标识符，DBMS 使用中间层将 ID 映射到磁盘上的位置。</li></ol><p><img src=/img/15445/storage1/33.jpg alt></p><hr><p>DBMS 中会存在 3 中不同类型的页：</p><ol><li>硬件页（通常是 4KB）</li><li>OS 页（通常是 4KB，x64 为 2MB/1GB）</li><li>数据库页（512B - 32KB）</li></ol><p>硬件页面（hardware page）是存储设备能够保证写入操作是安全的、不会失败的最大数据块。</p><blockquote><p>存储设备（如固态硬盘、硬盘驱动器等）在执行写入操作时，会以页为单位来处理数据。这些页通常是固定大小的（比如 4KB 或 8KB）。在写入数据时，设备可以确保这些页的数据能够被完整地写入，即使在断电或其他故障的情况下，这些数据也不会损坏或丢失。这样可以保证数据的可靠性和一致性。</p></blockquote><p><img src=/img/15445/storage1/34.jpg alt></p><hr><p>不同的 DBMS 以不同的文件形式管理页：</p><ul><li>Heap File Organization</li><li>Tree File Organization</li><li>Sequential / Sorted File Organization (ISAM)</li><li>Hashing File Organization</li></ul><p><img src=/img/15445/storage1/35.jpg alt></p><h3 id=堆文件>堆文件
<a class=anchor href=#%e5%a0%86%e6%96%87%e4%bb%b6>#</a></h3><p><strong>堆文件（heap file）</strong> 是一种无序的页面集合，其中的元组（记录）以随机顺序存储。</p><p>在单个堆文件中获取第 i 个页是很容易的，由于页大小是固定的，只需要计算偏移值即可，计算公式：<code>offset = Page# x PageSize</code>。</p><p><img src=/img/15445/storage1/36.jpg alt></p><hr><p>如果我们有多个堆文件，需要元数据来跟踪多个文件中存在的页面，以及哪些页面有可用空间。”</p><p><img src=/img/15445/storage1/37.jpg alt></p><p><img src=/img/15445/storage1/38.jpg alt></p><hr><p>DBMS 需要维护特殊的页，用于跟踪数据库文件中数据页的位置。</p><blockquote><p>必须确保<strong>目录页</strong>与<strong>数据页</strong>保持同步</p></blockquote><p>目录页面还记录了关于可用空间的元数据：每个页面中空闲插槽的数量，以及空闲（free）或空（empty）页的列表。</p><p><img src=/img/15445/storage1/39.jpg alt></p><hr><p>每个页包含一个头部的元数据，用于记录页内容的信息。</p><ul><li>Page Size</li><li>Checksum</li><li>DBMS Version</li><li>Transaction Visibility</li><li>Compression / Encoding Meta-data</li><li>Schema Information</li><li>Data Summary / Sketches</li></ul><p><img src=/img/15445/storage1/41.jpg alt></p><h3 id=存储元组>存储元组
<a class=anchor href=#%e5%ad%98%e5%82%a8%e5%85%83%e7%bb%84>#</a></h3><p>如何在页里存储元组数据呢？</p><h4 id=错误的方式>错误的方式
<a class=anchor href=#%e9%94%99%e8%af%af%e7%9a%84%e6%96%b9%e5%bc%8f>#</a></h4><p>错误的想法（稻草人的想法）：记录页内元组的数量，然后仅仅在尾部添加新的元组。</p><p><img src=/img/15445/storage1/44.jpg alt></p><p><img src=/img/15445/storage1/45.jpg alt></p><hr><p>如果我们需要删除一个元组，页内就会产生空洞。</p><p><img src=/img/15445/storage1/46.jpg alt></p><hr><p>如果我们想将新插入的 4 号页放到刚删除元组的位置，仅靠数量一个元数据是不够的，我们需要额外的元数据。</p><p><img src=/img/15445/storage1/47.jpg alt></p><hr><p>如果元组的长度是可变的话，我们也无法对其进行处理，无法定位到具体的元组。</p><p><img src=/img/15445/storage1/48.jpg alt></p><h4 id=插槽页>插槽页
<a class=anchor href=#%e6%8f%92%e6%a7%bd%e9%a1%b5>#</a></h4><p>可以采用插槽页（slotted pages）的方法，每个插槽存储元组开始的索引位置。</p><blockquote><p>也可以在插槽中存储元组的长度</p></blockquote><p><img src=/img/15445/storage1/49.jpg alt></p><hr><p>插槽数据和元组存储时，增长的方向如下所示：</p><p><img src=/img/15445/storage1/50.jpg alt></p><h4 id=删除元组>删除元组
<a class=anchor href=#%e5%88%a0%e9%99%a4%e5%85%83%e7%bb%84>#</a></h4><p>当我们删除页中元组时，只需要将删除元组前的数据拷贝过来并更新插槽中的索引位置即可。</p><p><img src=/img/15445/storage1/51.jpg alt></p><p><img src=/img/15445/storage1/52.jpg alt></p><p><img src=/img/15445/storage1/53.jpg alt></p><h4 id=record-ids>record ids
<a class=anchor href=#record-ids>#</a></h4><p>有些 DBMS 会在元组内存储一个唯一的记录标识，用于表示其在数据库中的物理位置。</p><p><img src=/img/15445/storage1/54.jpg alt></p><h2 id=元组格式>元组格式
<a class=anchor href=#%e5%85%83%e7%bb%84%e6%a0%bc%e5%bc%8f>#</a></h2><p>元组本质上是字节序列，DBMS 需要将这些字节解释为<strong>属性类型</strong>和<strong>值</strong>。</p><p><img src=/img/15445/storage1/56.jpg alt></p><h3 id=元组头>元组头
<a class=anchor href=#%e5%85%83%e7%bb%84%e5%a4%b4>#</a></h3><p>每个元组前面都有一个头部，包含关于自身的元数据。</p><p><img src=/img/15445/storage1/57.jpg alt></p><h3 id=元组数据>元组数据
<a class=anchor href=#%e5%85%83%e7%bb%84%e6%95%b0%e6%8d%ae>#</a></h3><p>属性通常按照创建表时指定的顺序存储，这样做的目录是因为<strong>简单</strong>。</p><p><img src=/img/15445/storage1/58.jpg alt></p><h3 id=反规范化>反规范化
<a class=anchor href=#%e5%8f%8d%e8%a7%84%e8%8c%83%e5%8c%96>#</a></h3><p>DBMS 可以将相关联的元组存储在一个页上，这样可以减少 I/O 次数，以提高数据库性能。</p><blockquote><p>更新操作可能会变得更加复杂和昂贵，如果一个数据项在多个页中都有存储（因为相关元组被预连接在一起），更新时需要在多个位置同步更新这些数据。这增加了更新操作的复杂性和时间开销。</p></blockquote><p><img src=/img/15445/storage1/59.jpg alt></p><hr><p>当我们需要使用 <code>JOIN</code> 时，只需要加载一次页即可。可明显减少 I/O 次数。</p><p><img src=/img/15445/storage1/60.jpg alt></p><p><img src=/img/15445/storage1/61.jpg alt></p><p>很多数据库都已经使用了此种技术。</p><p><img src=/img/15445/storage1/62.jpg alt></p></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#database-storage>Database Storage</a><ul><li><a href=#存储设备>存储设备</a></li><li><a href=#缓冲池>缓冲池</a></li><li><a href=#mmap>mmap</a></li><li><a href=#文件存储>文件存储</a><ul><li><a href=#页page>页（page）</a></li><li><a href=#堆文件>堆文件</a></li><li><a href=#存储元组>存储元组</a></li></ul></li><li><a href=#元组格式>元组格式</a><ul><li><a href=#元组头>元组头</a></li><li><a href=#元组数据>元组数据</a></li><li><a href=#反规范化>反规范化</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>