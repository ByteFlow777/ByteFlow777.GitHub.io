[{"id":0,"href":"/docs/network-programming/network-byte-order/","title":"网络字节序","section":"网络编程","content":" 网络字节序 # 大小端 # 不同架构的 CPU 中，4 字节整数 1 在内存中存储的方式是不同的。\n大端序（big endian）：最高位有效字节存储在低内存地址，而最低位有效字节存储在高内存地址。 小端序（little endian）：最高位有效字节存储在高内存地址，而最低位有效字节存储在低内存地址。 对于一个 4 字节整数 0x01020304，大小端序存储方式分别如下：\n地址: 0 1 2 3 （大端序保存） 01 02 03 04 地址: 0 1 2 3 （小端序保存） 04 03 02 01 可以使用下边的方法判断机器的字节序：\n通过 endian.h 提供的 BYTE_ORDER 宏。 #include \u0026lt;endian.h\u0026gt; bool big_endian() { return BYTE_ORDER == BIG_ENDIAN; } bool little_endian() { return BYTE_ORDER == LITTLE_ENDIAN; } 将 uint16_t 类型的数字转为 char *，通过高字节和低字节进行判断。 bool big_endian() { uint16_t val = 0x0102; return ((char *) (\u0026amp;val))[0] == 0x01; } bool little_endian() { uint16_t val = 0x0102; return ((char *) (\u0026amp;val))[1] == 0x01; } 和方法 2 类似，利用的是 union 相同的内存位置存储不同的数据类型。 union endian { uint16_t val; char bytes[2]; }; bool big_endian() { union endian en{}; en.val = 0x0102; return en.bytes[0] == 0x01; } bool little_endian() { union endian en{}; en.val = 0x0102; return en.bytes[0] == 0x02; } 为什么有两种不同的字节序？\n大端序是人类最熟悉的读写方法，从左向右处理。\n小端序更利于计算机处理，因为计算都是从低位开始的，先处理低位字节，效率比较高。\n网络字节序 # 如果通信双方采用不同的架构，收发数据后进行解析时会发生问题。如：大端序机器 A 发送 0x01020304 到小端序机器 B 时，B 以小端序方式解析该数字为 0x04030201。\n为解决上边问题，网络传输数据时，通信双方需要约定统一方式，把此约定叫做网络字节序（network byte order）。\n网络字节序规定使用大端序，大多数网络协议（例如 TCP/IP 协议族）规定了网络字节序采用大端序。\n因此，小端序发送数据时，需要先转为大端序。\n字节序转换 # 下边函数用于字节序的相互转换：\n#include \u0026lt;arpa/inet.h\u0026gt; uint32_t htonl(uint32_t hostlong); uint16_t htons(uint16_t hostshort); uint32_t ntohl(uint32_t netlong); uint16_t ntohs(uint16_t netshort); 函数名中的 h 表示主机（host）字节序，n 表示网络（network）字节序；s 表示 short 类型，l 表示 long 类型。\n"},{"id":1,"href":"/docs/network-programming/address-families/","title":"网络地址族","section":"网络编程","content":" 网络地址族 # 网络地址 # 网络地址分为 IPv4 和 IPv6，分别使用 sockaddr_in 和 sockaddr_in6 结构体表示。\nsockaddr_in # struct sockaddr_in { sa_family_t sin_family; /* address family: AF_INET */ in_port_t sin_port; /* port in network byte order */ struct in_addr sin_addr; /* internet address */ /* Pad to size of `struct sockaddr\u0026#39;. */ unsigned char sin_zero[8]; }; /* Internet address */ struct in_addr { uint32_t s_addr; /* address in network byte order */ }; sin_family：在 IPv4 中设为 AF_INET。 sin_port：网络字节序保存的端口（0～65535）。 sin_addr：网络字节序保存的 32 位 IP 地址信息。 sin_zero：使 sockaddr_in 和 sockaddr 结构体大小保持一致而插入的填充位，需手动设为 0。 https://man7.org/linux/man-pages/man7/ip.7.html\nsockaddr_in6 # struct sockaddr_in6 { sa_family_t sin6_family; /* AF_INET6 */ in_port_t sin6_port; /* port number */ uint32_t sin6_flowinfo; /* IPv6 flow information */ struct in6_addr sin6_addr; /* IPv6 address */ uint32_t sin6_scope_id; /* Scope ID (new in Linux 2.4) */ }; struct in6_addr { unsigned char s6_addr[16]; /* IPv6 address */ }; sin6_family：在 IPv6 中总设为 AF_INET6。 sin6_port：网络字节序保存的端口（0～65535）。 sin6_flowinfo：IPv6 流信息（不广泛使用）。 sin6_addr：表示 IPv6 地址的结构体，定义为 struct in6_addr。 sin6_scope_id：范围标识符（用于链路本地和站点本地地址）。 https://man7.org/linux/man-pages/man7/ipv6.7.html\nin_addr 和 in6_addr # in_addr # 我们比较熟悉的 IPv4 地址表示方法为点分十进制表示法，如：201.123.235.213。\n而 in_addr 结构体使用 uint32_t 保存 IPv4 地址，我们需要将字符串形式的 IPv4 地址转为 32 位整数表示。\ninet_addr 函数可用于转换，该函数在转换的同时会进行网络字节序的转换。\ninet_ntoa 函数则相反，将 in_addr 结构体转为字符串。\n注意：inet_ntoa 函数返回的是一个指向静态缓冲区的指针，最好将返回值拷贝到其它地方，以免被覆盖。\n#include \u0026lt;arpa/inet.h\u0026gt; in_addr_t inet_addr(const char *cp); char *inet_ntoa(struct in_addr in); 也可以使用 inet_aton 函数，该函数将结果直接保存到传入的 inp 结构体中。\n#include \u0026lt;arpa/inet.h\u0026gt; int inet_aton(const char *cp, struct in_addr *inp); in6_addr # sockaddr_in5 结构体中的 in6_addr 结构体包含一个 unsigned char 类型的成员 s6_addr，用于存储 128 位的 IPv6 地址。\ninet_pton 函数中的 af 参数必须为 AF_INET 和 AF_INET6，分别处理 IPv4 和 IPv6 协议。\n#include \u0026lt;arpa/inet.h\u0026gt; int inet_pton(int af, const char *restrict src, void *restrict dst); const char *inet_ntop(int af, const void *restrict src, char dst[restrict .size], socklen_t size); 网络地址初始化 # IPv4 # #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; int main() { const char *address = \u0026#34;211.123.211.168\u0026#34;; // IP 地址 const char *port = \u0026#34;7890\u0026#34;; // 端口 struct sockaddr_in addr; memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin_family = AF_INET; // IPv4; addr.sin_addr.s_addr = inet_addr(address); // 设置 IP 地址 addr.sin_port = htons(atoi(port)); // 以网络字节序设置端口 } IPv6 # #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; int main() { const char *address = \u0026#34;2001:0db8:85a3:0000:0000:8a2e:0370:7334\u0026#34;; // IPv6 地址 const char *port = \u0026#34;7890\u0026#34;; // 端口 struct sockaddr_in6 addr; memset(\u0026amp;addr, 0, sizeof(addr)); addr.sin6_family = AF_INET6; // IPv6 inet_pton(AF_INET6, address, \u0026amp;addr.sin6_addr); // 设置 IP 地址 addr.sin6_port = htons(atoi(port)); // 以网络字节序设置端口 } 思考 # 为什么 sockaddr_in 和 sockaddr_in6 分别表示 IPv4 和 IPv6 协议，还要额外使用 sa_family_t 指定协议版本呢？\n因为 connect、bind、和 accept 函数第二个参数都接收 sockaddr 结构体。因此，需要使用 sa_family 用于区分不同版本的协议。通过使用通用的 sockaddr 结构体，该函数不仅可以处理 IPv4 和 IPv6 协议，还可处理其它协议。这样，就不需要为每种协议都提供对应的函数。\nstruct sockaddr { sa_family_t sa_family; /* Address family */ char sa_data[]; /* Socket address */ }; "},{"id":2,"href":"/docs/network-programming/sockets/","title":"套接字（socket）","section":"网络编程","content":" 套接字（socket） # 网络编程即编写程序使两台联网的计算机相互交换数据。计算机之间会通过网线、路由器和交换机等设备连接在一起，我们无需直接操控硬件，而使用操作系统提供的套接字（socket）。\n基本函数 # socket # 为了使用套接字，可以使用 socket 函数，创建用于通信的端点（endpoint）。\n#include \u0026lt;sys/socket.h\u0026gt; int socket(int domain, int type, int protocol); 成功时会返回文件描述符，失败时会返回 -1。\nhttps://man7.org/linux/man-pages/man2/socket.2.html\nbind # 当使用 socket 函数创建套接字后，会存在于名称空间（地址族）中，但没有为其分配地址。bind 函数将 addr 指定的地址分配给文件描述符 sockfd 引用的套接字。\n服务器可以不先调用 bind() 而直接调用 listen()，此时会为该 socket 分配一个 INADDR_ANY IP 地址（0.0.0.0）和临时端口（可通过 getsockname() 获取 socket 的地址）。\n#include \u0026lt;sys/socket.h\u0026gt; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 成功时返回 0，失败时返回 -1。\nhttps://man7.org/linux/man-pages/man2/bind.2.html\nlisten # listen 函数将文件描述符引用的 socket 标记为被动，该 socket 会被用来接受来自其它主动 socket 的连接。\n#include \u0026lt;sys/socket.h\u0026gt; int listen(int sockfd, int backlog); 成功时返回 0，失败时返回 -1。\nhttps://man7.org/linux/man-pages/man2/listen.2.html\naccept # 执行 accept 函数会创建一个新的 socket，此 socket 会与执行 connect 函数的 socket 进行连接。此函数调用返回值是已连接的 socket 的文件描述符。\n#include \u0026lt;sys/socket.h\u0026gt; int accept(int sockfd, struct sockaddr *_Nullable restrict addr, socklen_t *_Nullable restrict addrlen); 成功时会返回文件描述符，失败时会返回 -1。\nhttps://man7.org/linux/man-pages/man2/accept.2.html\nconnect # connect 函数将文件描述符 sockfd 引用的套接字连接到由 addr 指定的地址。\n#include \u0026lt;sys/socket.h\u0026gt; int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); https://man7.org/linux/man-pages/man2/connect.2.html\n套接字协议 # socket 函数（int socket(int domain, int type, int protocol)）有三个参数用于选择传输协议和方式。\n协议族（domain） # 所有的协议族可以点击 address_families 查看，主要的协议族分类如下：\n协议族 描述 AF_INET 使用 IPv4 地址 AF_INET6 使用 IPv6 地址 AF_UNIX 本地通信，用于同一台机器上的进程间通信 AF_PACKET 原始数据包捕获和注入，需要特殊权限 AF_NETLINK 用于 Linux 内核与用户空间进程之间的通信 AF_常量 和 PF_常量 的区别？\nAF 表示地址族（address family），PF 表示协议族（protocol family）。在一开始的时候，设计人员相信单个协议族可以支持多个地址族。但在实践中，没有哪一个协议族能够支持多个已经被定义的地址族，并且所有既有实现都将 PF_常量 定义成对应的 AF_常量 的同义词。\n数据传输方式（type） # 数据传输类型主要有以下两种：\n面向连接的套接字（SOCK_STREAM）：提供有序的、可靠的、双向的、基于连接的字节流。可以支持带外（ out-of-band）数据传输机制。 面向消息的套接字（SOCK_DGRAM）：支持数据报（无连接、最大长度固定的不可靠消息）。 协议（protocol） # 在给定的协议族中，通常只有一个协议存在以支持特定的套接字类型，在这种情况下，可以将 protocol 指定为 0。\n在大部分情况下，第三个参数传递 0 即可。然而，协议族下可能存在许多协议，在这种情况下，必须使用 protocol 指定一个特定的协议。\n"},{"id":3,"href":"/docs/network-programming/echo-server/","title":"echo 服务器","section":"网络编程","content":" echo 服务器 # 服务端代码 # 服务端（被动）接受连接请求的套接字创建过程如下：\n调用 socket 函数创建套接字。 调用 bind 函数分配 IP 地址和端口号。 调用 listen 函数转为可接受请求状态。 调用 accept 函数处理连接请求。 调用 read 和 write 函数进行数据交换。 调用 close 函数断开连接。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; void panic(char *err_message) { fputs(err_message, stderr); fputc(\u0026#39;\\n\u0026#39;, stderr); exit(EXIT_FAILURE); } int main(int argc, char *argv[]) { if (argc != 2) { panic(\u0026#34;Usage: \u0026lt;program_name\u0026gt; \u0026lt;port\u0026gt;\u0026#34;); } // server port int port = atoi(argv[1]); // PF_INET: IPv4 Internet protocols // SOCK_STREAM: TCP // 0: automatically choose int server_sock_fd = socket(PF_INET, SOCK_STREAM, 0); if (server_sock_fd == -1) { panic(\u0026#34;socket() error\u0026#34;); } struct sockaddr_in server_addr; memset(\u0026amp;server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = htonl(INADDR_ANY); server_addr.sin_port = htons(port); if (bind(server_sock_fd, (struct sockaddr *)\u0026amp;server_addr, sizeof(server_addr)) == -1) { panic(\u0026#34;bind() error\u0026#34;); } if (listen(server_sock_fd, 5) == -1) { panic(\u0026#34;listen() error\u0026#34;); } struct sockaddr_in client_addr; socklen_t client_addr_size = sizeof(client_addr); int client_sock_fd = accept(server_sock_fd, (struct sockaddr *)\u0026amp;client_addr, \u0026amp;client_addr_size); if (client_sock_fd == -1) { panic(\u0026#34;accept() error\u0026#34;); } char message[] = \u0026#34;Hello World\u0026#34;; write(client_sock_fd, message, sizeof(message)); close(client_sock_fd); close(server_sock_fd); return 0; } 客户端代码 # 客户端（主动）连接请求的套接字创建过程如下：\n调用 socket 函数创建套接字。 调用 connect 函数与服务器建立连接。 调用 read 和 write 函数进行数据交换。 调用 close 函数断开连接。 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; #include \u0026lt;sys/socket.h\u0026gt; void panic(char *err_message) { fputs(err_message, stderr); fputc(\u0026#39;\\n\u0026#39;, stderr); exit(EXIT_FAILURE); } int main(int argc, char *argv[]) { if (argc != 3) { panic(\u0026#34;Usage: \u0026lt;program_name\u0026gt; \u0026lt;IP\u0026gt; \u0026lt;port\u0026gt;\u0026#34;); } int sock_fd = socket(PF_INET, SOCK_STREAM, 0); if (sock_fd == -1) { panic(\u0026#34;socket() error\u0026#34;); } struct sockaddr_in server_addr; memset(\u0026amp;server_addr, 0, sizeof(server_addr)); server_addr.sin_family = AF_INET; server_addr.sin_addr.s_addr = inet_addr(argv[1]); server_addr.sin_port = htons(atoi(argv[2])); if (connect(sock_fd, (struct sockaddr *)\u0026amp;server_addr, sizeof(server_addr)) == -1) { panic(\u0026#34;connect() error\u0026#34;); } char message[128]; ssize_t read_size = read(sock_fd, message, sizeof(message) - 1); if (read_size == -1) { panic(\u0026#34;read() error\u0026#34;); } message[read_size] = \u0026#39;\\0\u0026#39;; printf(\u0026#34;%s\\n\u0026#34;, message); close(sock_fd); return 0; } 改进的服务端代码 # 上边的服务端代码只能处理一次客户端的连接，我们可以对其进行改进，当处理完某个客户端请求后，可以重新调用 accept 函数：\nwhile (1) { struct sockaddr_in client_addr; socklen_t client_addr_size = sizeof(client_addr); int client_sock_fd = accept(server_sock_fd, (struct sockaddr *) \u0026amp;client_addr, \u0026amp;client_addr_size); if (client_sock_fd == -1) { panic(\u0026#34;accept() error\u0026#34;); } char message[] = \u0026#34;Hello World\u0026#34;; write(client_sock_fd, message, sizeof(message)); close(client_sock_fd); } "}]