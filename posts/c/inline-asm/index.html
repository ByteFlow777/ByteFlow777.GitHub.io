<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://ileonli.github.io/favicon.ico><link rel=stylesheet href=/css/style.min.css><link rel=canonical href=https://ileonli.github.io/posts/c/inline-asm/><title>如何在 C 语言中使用内联汇编（翻译）</title></head><body><header id=banner></header><main id=content><article><header id=post-header><h1>如何在 C 语言中使用内联汇编（翻译）</h1><div><time>2023-08-29</time></div></header><blockquote><p><a href=https://gcc.gnu.org/onlinedocs/gcc/extensions-to-the-c-language-family/how-to-use-inline-assembly-language-in-c-code.html>https://gcc.gnu.org/onlinedocs/gcc/extensions-to-the-c-language-family/how-to-use-inline-assembly-language-in-c-code.html</a></p></blockquote><p><code>asm</code> 关键字允许你在 C 代码中嵌入汇编指令。GCC 提供了两种形式的内联 <code>asm</code> 语句。最基本的 <code>asm</code> 语句是没有操作数的，扩展的 <code>asm</code> 语句包含一个或多个操作数。若在函数中混合 C 代码和汇编代码，优先采用扩展形式；如果在顶层包含汇编语言，你必须使用 <code>asm</code>。</p><p>你也可以使用 <code>asm</code> 关键字来覆盖 C 符号（C symbol）的汇编名称，或将 C 变量放在特定寄存器中。</p><h2 id=基本汇编---不包含操作数的汇编指令>基本汇编 - 不包含操作数的汇编指令</h2><p>最基本的 <code>asm</code> 语句语法形式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-asm data-lang=asm><span class=line><span class=cl><span class=nf>asm</span> <span class=no>asm-qualifiers</span> <span class=p>(</span> <span class=no>AssemblerInstructions</span> <span class=p>)</span>
</span></span></code></pre></div><p>对于 C 语言来说，<code>asm</code> 关键字是 GNU 扩展。在编写可使用 <a href=https://gcc.gnu.org/onlinedocs/gcc/gcc-command-options/options-controlling-c-dialect.html#cmdoption-ansi>-ansi</a> 和 <a href=https://gcc.gnu.org/onlinedocs/gcc/gcc-command-options/options-controlling-c-dialect.html#cmdoption-std>-std</a> 选项编译的 C 代码时，这些选项选择了不带 GNU 扩展的 C 语言方言，请使用 <code>__asm__</code> 代替 <code>asm</code>（<a href=https://gcc.gnu.org/onlinedocs/gcc/extensions-to-the-c-language-family/alternate-keywords.html#alternate-keywords>Alternate Keywords</a>）。对于 C++ 语言来说，<code>asm</code> 是关键字，但 <code>__asm__</code> 可以使用参数 <a href=https://gcc.gnu.org/onlinedocs/gcc/gcc-command-options/options-controlling-c-dialect.html#cmdoption-fno-asm>-fno-asm</a>。</p><h2 id=修饰符qualifiers>修饰符（Qualifiers）</h2><p><code>volatile</code>：可选的 <code>volatile</code> 没有任何影响（no effect），所有基本的 <code>asm</code> 块都隐含使用 <code>volatile</code> 修饰。</p><p><code>inline</code>：如果你使用 <code>inline</code> 修饰符，出于内联目的，<code>asm</code> 语句的大小被视为可能的最小。</p><h2 id=参数parameters>参数（Parameters）</h2><p><code>AssemblerInstructions</code>：用于指定汇编代码的字符串，该字符串可以包含汇编器识别的任何指令。GCC 本身不会解析汇编指令，也不知道它们的含义，甚至不知道它们是否是有效的汇编输入。</p><p>你可以将多个汇编指令放到一个 <code>asm</code> 字符串中，用系统汇编常用的分割符进行分割。在大多数情况下，换行符加上制表符（书写为 <code>\n\t</code>）是一个有效的组合。一些汇编器（assemblers）允许使用分号作为换行符。请注意某些汇编语言使用分号作为注释。</p><h2 id=备注remarks>备注（Remarks）</h2><p>使用扩展 <code>asm</code> 产生更小、更安全和更高效的代码。在大多数情况下，扩展 <code>asm</code> 比标准 <code>asm</code> 更好。然而，以下两种情况只能使用标准 <code>asm</code>：</p><ul><li>扩展 <code>asm</code> 语句必须在 C 函数内，为了在文件范围内（top-level）C 语言函数外，你必须使用标准 <code>asm</code>。你可以使用此技术来发出汇编程序指令，定义可以在其他文件中执行的汇编语言宏，或者使用汇编语言写整个方法。函数之外的标准 <code>asm</code> 语句不得使用任何修饰符。</li><li>带有 <code>naked</code> 属性的函数声明同样需要基本 <code>asm</code>（<a href=https://gcc.gnu.org/onlinedocs/gcc/extensions-to-the-c-language-family/declaring-attributes-of-functions.html#function-attributes>Declaring Attributes of Functions</a>）。</li></ul><p>从基本 <code>asm</code> 安全地访问 C 数据和调用函数比看起来更加复杂。为了访问 C 数据，最好使用扩展 <code>asm</code>。</p><p>不要期望一系列 <code>asm</code> 语句在编译后保持完全连续（perfectly consecutive）。如果具体的指令在输出中需要保持连续（consecutive），请把他们放到一个多指令 <code>asm</code> 语句中。请注意，GCC 的优化器可以相对于其他代码移动 <code>asm</code> 语句，包括跨跳转（jumps）。</p><p><code>asm</code> 语句可能不能执行跳转到其它 <code>asm</code> 语句中的操作。GCC 不知道这些跳转（jumps），因此在决定如何优化时不能考虑这些跳转。从 <code>asm</code> 跳转到 C标签仅支持扩展 <code>asm</code>。</p><p>在具体环境下，GCC 在优化时可能复制你的汇编代码（或者删除重复的汇编代码）。如果您的汇编代码定义了符号或标签，这可能会导致编译期间出现意外的重复符号错误。</p><blockquote><p>C 语言标准没有制定 <code>asm</code> 的语义，可能是不同编译器不兼容的潜在来源。这些不兼容可能不会产生编译警告或者错误。</p></blockquote><p>GCC 不会解析 <code>asm</code> 的 <code>AssemblerInstructions</code>，这意味着无法与编译器沟通内部发生的情况。GCC 在 <code>asm</code> 中没有符号可见性，并且可能将他们作为未引用（unreferenced）而抛弃。GCC 不知道汇编代码的副作用，比如修改内存或者寄存器。和一些编译器不一样的是，GCC 假设通用寄存器没有发生改变。这个假设可能在未来发生变化。</p><p>为了避免未来语义变化和编译器之间的兼容性问题带来的复杂性，考虑使用扩展 <code>asm</code> 替换标准 <code>asm</code>。查看 <a href=https://gcc.gnu.org/wiki/ConvertBasicAsmToExtended>How to convert from basic asm to extended asm</a> 查看更多执行此种转换的信息。</p></article></main><footer id=footer></footer></body></html>