<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://ileonli.github.io/favicon.ico><link rel=stylesheet href=/css/style.min.css><link rel=canonical href=https://ileonli.github.io/posts/c/inline-asm/><title>如何在 C 语言中使用内联汇编（翻译）</title></head><body><header id=banner></header><main id=content><article><header id=post-header><h1>如何在 C 语言中使用内联汇编（翻译）</h1><div><time>2023-08-29</time></div></header><blockquote><p><a href=https://gcc.gnu.org/onlinedocs/gcc/extensions-to-the-c-language-family/how-to-use-inline-assembly-language-in-c-code.html>https://gcc.gnu.org/onlinedocs/gcc/extensions-to-the-c-language-family/how-to-use-inline-assembly-language-in-c-code.html</a></p></blockquote><p><code>asm</code> 关键字允许你在 C 代码中嵌入汇编指令。GCC 提供了两种形式的内联 <code>asm</code> 语句。最基本的 <code>asm</code> 语句是没有操作数的，扩展的 <code>asm</code> 语句包含一个或多个操作数。若在函数中混合 C 代码和汇编代码，优先采用扩展形式；如果在顶层包含汇编语言，你必须使用 <code>asm</code>。</p><p>你也可以使用 <code>asm</code> 关键字来覆盖 C 符号（C symbol）的汇编名称，或将 C 变量放在特定寄存器中。</p><h2 id=基本-asm---不包含操作数的汇编指令>基本 <code>asm</code> - 不包含操作数的汇编指令</h2><p>最基本的 <code>asm</code> 语句语法形式如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>asm</span> <span class=k>asm</span><span class=o>-</span><span class=nf>qualifiers</span> <span class=p>(</span> <span class=n>AssemblerInstructions</span> <span class=p>)</span>
</span></span></code></pre></div><p>对于 C 语言来说，<code>asm</code> 关键字是 GNU 扩展。在编写可使用 <a href=https://gcc.gnu.org/onlinedocs/gcc/gcc-command-options/options-controlling-c-dialect.html#cmdoption-ansi>-ansi</a> 和 <a href=https://gcc.gnu.org/onlinedocs/gcc/gcc-command-options/options-controlling-c-dialect.html#cmdoption-std>-std</a> 选项编译的 C 代码时，这些选项选择了不带 GNU 扩展的 C 语言方言，请使用 <code>__asm__</code> 代替 <code>asm</code>（<a href=https://gcc.gnu.org/onlinedocs/gcc/extensions-to-the-c-language-family/alternate-keywords.html#alternate-keywords>Alternate Keywords</a>）。对于 C++ 语言来说，<code>asm</code> 是关键字，但 <code>__asm__</code> 可以使用参数 <a href=https://gcc.gnu.org/onlinedocs/gcc/gcc-command-options/options-controlling-c-dialect.html#cmdoption-fno-asm>-fno-asm</a>。</p><h3 id=修饰符qualifiers>修饰符（Qualifiers）</h3><p><code>volatile</code>：可选的 <code>volatile</code> 没有任何影响（no effect），所有基本的 <code>asm</code> 块都隐含使用 <code>volatile</code> 修饰。</p><p><code>inline</code>：如果你使用 <code>inline</code> 修饰符，出于内联目的，<code>asm</code> 语句的大小被视为可能的最小。</p><h3 id=参数parameters>参数（Parameters）</h3><p><code>AssemblerInstructions</code>：用于指定汇编代码的字符串，该字符串可以包含汇编器识别的任何指令。GCC 本身不会解析汇编指令，也不知道它们的含义，甚至不知道它们是否是有效的汇编输入。</p><p>你可以将多个汇编指令放到一个 <code>asm</code> 字符串中，用系统汇编常用的分割符进行分割。在大多数情况下，换行符加上制表符（书写为 <code>\n\t</code>）是一个有效的组合。一些汇编器（assemblers）允许使用分号作为换行符。请注意某些汇编语言使用分号作为注释。</p><h3 id=备注remarks>备注（Remarks）</h3><p>使用扩展 <code>asm</code> 产生更小、更安全和更高效的代码。在大多数情况下，扩展 <code>asm</code> 比标准 <code>asm</code> 更好。然而，以下两种情况只能使用标准 <code>asm</code>：</p><ul><li>扩展 <code>asm</code> 语句必须在 C 函数内，为了在文件范围内（top-level）C 语言函数外，你必须使用标准 <code>asm</code>。你可以使用此技术来发出汇编程序指令，定义可以在其他文件中执行的汇编语言宏，或者使用汇编语言写整个方法。函数之外的标准 <code>asm</code> 语句不得使用任何修饰符。</li><li>带有 <code>naked</code> 属性的函数声明同样需要基本 <code>asm</code>（<a href=https://gcc.gnu.org/onlinedocs/gcc/extensions-to-the-c-language-family/declaring-attributes-of-functions.html#function-attributes>Declaring Attributes of Functions</a>）。</li></ul><p>从基本 <code>asm</code> 安全地访问 C 数据和调用函数比看起来更加复杂。为了访问 C 数据，最好使用扩展 <code>asm</code>。</p><p>不要期望一系列 <code>asm</code> 语句在编译后保持完全连续（perfectly consecutive）。如果具体的指令在输出中需要保持连续（consecutive），请把他们放到一个多指令 <code>asm</code> 语句中。请注意，GCC 的优化器可以相对于其他代码移动 <code>asm</code> 语句，包括跨跳转（jumps）。</p><p><code>asm</code> 语句可能不能执行跳转到其它 <code>asm</code> 语句中的操作。GCC 不知道这些跳转（jumps），因此在决定如何优化时不能考虑这些跳转。从 <code>asm</code> 跳转到 C标签仅支持扩展 <code>asm</code>。</p><p>在具体环境下，GCC 在优化时可能复制你的汇编代码（或者删除重复的汇编代码）。如果您的汇编代码定义了符号或标签，这可能会导致编译期间出现意外的重复符号错误。</p><blockquote><p>C 语言标准没有制定 <code>asm</code> 的语义，可能是不同编译器不兼容的潜在来源。这些不兼容可能不会产生编译警告或者错误。</p></blockquote><p>GCC 不会解析 <code>asm</code> 的 <code>AssemblerInstructions</code>，这意味着无法与编译器沟通内部发生的情况。GCC 在 <code>asm</code> 中没有符号可见性，并且可能将他们作为未引用（unreferenced）而抛弃。GCC 不知道汇编代码的副作用，比如修改内存或者寄存器。和一些编译器不一样的是，GCC 假设通用寄存器没有发生改变。这个假设可能在未来发生变化。</p><p>为了避免未来语义变化和编译器之间的兼容性问题带来的复杂性，考虑使用扩展 <code>asm</code> 替换标准 <code>asm</code>。查看 <a href=https://gcc.gnu.org/wiki/ConvertBasicAsmToExtended>How to convert from basic asm to extended asm</a> 查看更多执行此种转换的信息。</p><p>编译器将基本 <code>asm</code> 中的汇编指令逐字复制到汇编语言输出文件中，不会处理方言（dialects）或任何在扩展 <code>asm</code> 中可见的 % 操作符。这会导致在基本 <code>asm</code> 字符串和扩展 <code>asm</code> 模板中产生一些细微的变化。例如：要引用寄存器，可以在基本 <code>asm</code> 中使用 <code>%eax</code>，在扩展 <code>asm</code> 中使用 <code>%%eax</code>。</p><p>在支持多种汇编语言的 x86 等架构（targets）上，所有的标准 <code>asm</code> 块使用通过 <code>-masm</code> 命令行选项指定的汇编语言（<a href=https://gcc.gnu.org/onlinedocs/gcc/gcc-command-options/machine-dependent-options/x86-options.html#x86-options>x86</a>）。基本 <code>asm</code> 没有提供任何机制支持不同方言的不同汇编字符串。</p><p>对于具有非空汇编字符串的标准 <code>asm</code>，GCC 假设汇编块不会改变任何通用寄存器，但是它可以读写任何全局可访问的变量。</p><p>下边是 i386 基本 <code>asm</code> 的示例：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=cm>/* Note that this code will not compile with -masm=intel */</span>
</span></span><span class=line><span class=cl><span class=cp>#define DebugBreak() asm(&#34;int $3&#34;)
</span></span></span></code></pre></div><h2 id=扩展-asm---带有-c-表达式操作数的汇编指令>扩展 <code>asm</code> - 带有 C 表达式操作数的汇编指令</h2><p>使用扩展 <code>asm</code>，你可以从汇编程序读取和写入 C 变量，并执行从汇编程序代码到 C 标签的跳转。扩展 <code>asm</code> 语法在汇编其模板之后使用冒号（:）分割操作数参数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=k>asm</span> <span class=k>asm</span><span class=o>-</span><span class=nf>qualifiers</span> <span class=p>(</span> <span class=nl>AssemblerTemplate</span>
</span></span><span class=line><span class=cl>                 <span class=p>:</span> <span class=n>OutputOperands</span>
</span></span><span class=line><span class=cl>                 <span class=p>[</span> <span class=o>:</span> <span class=n>InputOperands</span>
</span></span><span class=line><span class=cl>                 <span class=p>[</span> <span class=o>:</span> <span class=n>Clobbers</span> <span class=p>]</span> <span class=p>])</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>asm</span> <span class=k>asm</span><span class=o>-</span><span class=nf>qualifiers</span> <span class=p>(</span> <span class=nl>AssemblerTemplate</span>
</span></span><span class=line><span class=cl>                      <span class=p>:</span> <span class=nl>OutputOperands</span>
</span></span><span class=line><span class=cl>                      <span class=p>:</span> <span class=nl>InputOperands</span>
</span></span><span class=line><span class=cl>                      <span class=p>:</span> <span class=nl>Clobbers</span>
</span></span><span class=line><span class=cl>                      <span class=p>:</span> <span class=n>GotoLabels</span><span class=p>)</span>
</span></span></code></pre></div><p>在最后一种形式中，<code>asm-qualifiers</code> 包含 <code>goto</code>（在第一种形式中，不是）。
<code>asm</code> 关键词是 GNU 扩展。当编写可以使用 <a href=https://gcc.gnu.org/onlinedocs/gcc/gcc-command-options/options-controlling-c-dialect.html#cmdoption-ansi>-ansi</a> 和各种 <a href=https://gcc.gnu.org/onlinedocs/gcc/gcc-command-options/options-controlling-c-dialect.html#cmdoption-std>-std</a> 选项编译的代码时，请使用 <code>__asm__</code> 而不是 <code>asm</code>（<a href=https://gcc.gnu.org/onlinedocs/gcc/extensions-to-the-c-language-family/alternate-keywords.html#alternate-keywords>Alternate Keywords</a>）。</p><h3 id=修饰符qualifiers-1>修饰符（Qualifiers）</h3><p><code>volatile</code>：扩展 <code>asm</code> 典型用法是操作输入值以产生输出值。但是你的 <code>asm</code> 语句也可能也会产生副作用。因此，你可能需要使用 <code>volatile</code> 修饰符禁用具体的优化。</p><p><code>inline</code>：如果你使用 <code>inline</code> 修饰符，出于内联目的，<code>asm</code> 语句的大小被视为可能的最小。</p><p><code>goto</code>：此修饰符告诉编译器此 <code>asm</code> 语句可能产生一个跳转至在 <code>GotoLabels</code> 中列出的标签。</p><h3 id=参数parameters-1>参数（Parameters）</h3><p><code>AssemblerTemplate</code>：此字符串是汇编代码的模板。它是固定文本和标记的组合，引用输入、输出和 goto 参数。</p><p><code>OutputOperands</code>：由 <code>AssemblerTemplate</code> 中的指令修改的且由逗号分隔的 C 变量列表，允许使用空列表。</p><p><code>InputOperands</code>：由 <code>AssemblerTemplate</code> 中的指令读取的且由逗号分割的 C 表达式列表，允许使用空列表。</p><p><code>Clobbers</code>：由 <code>AssemblerTemplate</code> 改变且由逗号分割的寄存器列表或其它值，超出列表的将视为输入，允许使用空列表。</p><p><code>GotoLabels</code>：当你使用 <code>asm</code> 的 <code>goto</code> implicitly volatile形式时，此部分包含 <code>AssemblerTemplate</code> 中的代码可能跳转的所有 C 标签的列表。<code>asm</code> 语句不能执行跳转至其它 <code>asm</code> 语句，只能跳转至在 <code>GotoLabels</code> 列出的。GCC 的优化器可能不知道其它跳转，因此他们无法在决定如何优化时考虑他们。<code>input + output + goto</code> 操作数限制为 30。</p><h3 id=备注remarks-1>备注（Remarks）</h3><p><code>asm</code> 语句允许你直接在 C 代码中包含汇编指令。这可以帮助你最大限度地提高时间敏感的代码的性能或访问 C 程序不易使用的汇编指令。</p><p>扩展 <code>asm</code> 语句必须在方法内。只有基本 <code>asm</code> 可以在方法外。通过 <code>naked</code> 属性修饰的函数声明也需要基本 <code>asm</code>。</p><p>虽然 <code>asm</code> 的用途很广泛，它可能会帮助思考 <code>asm</code> 语句作为一系列转换输入参数和输出参数的低级别的指令。因此，使用 <code>asm</code> 的 i386 的简单（如果不是特别有用）示例可能如下所示：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>int</span> <span class=n>src</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>dst</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>asm</span> <span class=p>(</span><span class=s>&#34;mov %1, %0</span><span class=se>\n\t</span><span class=s>&#34;</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;add $1, %0&#34;</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=s>&#34;=r&#34;</span> <span class=p>(</span><span class=n>dst</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=s>&#34;r&#34;</span> <span class=p>(</span><span class=n>src</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>printf</span><span class=p>(</span><span class=s>&#34;%d</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>,</span> <span class=n>dst</span><span class=p>);</span>
</span></span></code></pre></div><p>此代码将 <code>src</code> 拷贝到 <code>dst</code> 中并加 1。</p><h4 id=volatile>volatile</h4><p>GCC 的优化器会在确定不需要输入变量的时候丢弃 <code>asm</code> 语句。此外，优化器可能会在代码总是返回一样的结果时，将代码移出循环（即输入值在调用时没有发生改变）。使用 <code>volatile</code> 修饰符禁用这些优化。没有输出数的 <code>asm</code> 语句和 <code>asm goto</code> 语句默认是 volatile 的。</p><p>此 i386 代码展示了不使用 <code>volatile</code> 修饰符的例子。如果正在执行断言检查，则此代码使用 <code>asm</code> 来执行验证。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-C data-lang=C><span class=line><span class=cl><span class=kt>void</span> <span class=nf>DoCheck</span><span class=p>(</span><span class=kt>uint32_t</span> <span class=n>dwSomeValue</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=kt>uint32_t</span> <span class=n>dwRes</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=c1>// Assumes dwSomeValue is not zero.
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=k>asm</span> <span class=p>(</span><span class=s>&#34;bsfl %1,%0&#34;</span>
</span></span><span class=line><span class=cl>     <span class=o>:</span> <span class=s>&#34;=r&#34;</span> <span class=p>(</span><span class=n>dwRes</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=o>:</span> <span class=s>&#34;r&#34;</span> <span class=p>(</span><span class=n>dwSomeValue</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=o>:</span> <span class=s>&#34;cc&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>   <span class=nf>assert</span><span class=p>(</span><span class=n>dwRes</span> <span class=o>&gt;</span> <span class=mi>3</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>// TODO</p><h4 id=assembler-template>Assembler Template</h4></article></main><footer id=footer></footer></body></html>