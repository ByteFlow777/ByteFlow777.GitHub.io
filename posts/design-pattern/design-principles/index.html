<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://ileonli.github.io/favicon.ico><link rel=stylesheet href=/css/style.min.css><link rel=canonical href=https://ileonli.github.io/posts/design-pattern/design-principles/><title>设计模式 - 面向对象设计原则</title></head><body><header id=banner></header><main id=content><article><header id=post-header><h1>设计模式 - 面向对象设计原则</h1><div><time>2023-07-14</time></div></header><blockquote><p>每一个模式描述了一个在我们周围不断重复发生以及该问题的解决方法的核心。这样，你就能一次有一次地使用该方案而不必做重复劳动。
&ndash; Alexa Christopher</p></blockquote><h2 id=面向对象>面向对象</h2><p>对象封装了代码和数据，是某种责任的抽象。</p><p>面向对象更加强调各个类的责任。</p><p>变化是复用的天敌，面向对象设计最大的优势在于<strong>抵御变化</strong>（使得变化带来的影响最小）。</p><h2 id=依赖倒置>依赖倒置</h2><p>高层模块（稳定）不应该依赖低层模块（变化），两者都应该依赖其抽象（稳定）。</p><p>抽象（稳定）不应该依赖于实现细节（变化），实现细节应该依赖抽象。</p><p>当我们需要计算列表的和时，参数使用 List 父接口，子类可以传入不同的实现，如：ArrayList 和 LinkedList 等。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>int</span> <span class=nf>sum</span><span class=o>(</span><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>list</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>sum</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=o>(</span><span class=n>Integer</span> <span class=n>n</span> <span class=o>:</span> <span class=n>list</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>sum</span> <span class=o>+=</span> <span class=n>n</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>sum</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=开闭原则>开闭原则</h2><p>对<strong>扩展</strong>开放，对<strong>更改</strong>封闭。</p><p>类模块应该是可扩展的，但是不可修改。</p><p>在程序需要进行扩展的时候，不用去修改原有的代码。</p><p>我们可以使用<strong>接口</strong>和<strong>抽象类</strong>实现这样的效果。当我们实现验证码功能时，可以抽象出一个接口，然后为短信提供商提供具体的实现，当新增短信提供商时，只需新增实现即可。</p><h2 id=单一职责>单一职责</h2><p>一个类应该仅有一个引起它变化的原因。</p><p>变化的方向隐含着类的责任。</p><h2 id=里氏代换>里氏代换</h2><p>子类必须能够替换它们的基类（IS-A）。</p><p>子类可以扩展父类的功能，但不要改变父类原有的功能。</p><p>里氏代换是继承复用的基石，只有当子类可以替换掉基类且软件的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。</p><p>当我们创建鸟类的时候，由于鸟有可以飞、不可以飞和可以飞和可以走三大类。我们应该更进一步细化，分为：FlyingBirds 和 NonflyingBirds 两种。不同的鸟实现不同的接口，细化功能。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>Bird</span> <span class=o>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>FlyingBirds</span> <span class=kd>extends</span> <span class=n>Bird</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>fly</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>NonflyingBirds</span> <span class=kd>extends</span> <span class=n>Bird</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>walk</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=c1>// 鸭子
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Duck</span> <span class=kd>implements</span> <span class=n>FlyingBirds</span><span class=err>，</span> <span class=n>NonflyingBirds</span> <span class=o>{}</span>
</span></span><span class=line><span class=cl><span class=c1>// 鸵鸟
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Ostrich</span> <span class=kd>implements</span> <span class=n>NonflyingBirds</span> <span class=o>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=o>(</span><span class=n>FlyingBirds</span> <span class=n>fb</span><span class=o>)</span> <span class=o>{</span> <span class=n>fb</span><span class=o>.</span><span class=na>fly</span><span class=o>();</span> <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>run</span><span class=o>(</span><span class=n>NonflyingBirds</span> <span class=n>nb</span><span class=o>)</span> <span class=o>{</span> <span class=n>nb</span><span class=o>.</span><span class=na>walk</span><span class=o>();</span> <span class=o>}</span>
</span></span></code></pre></div><h2 id=接口隔离>接口隔离</h2><p>不应该强迫客户端使用不应该被使用的方法，</p><p>一个类多另一个类的依赖应该建立在最小的接口上。</p><p>当我们需要实现安全门类的时候，不同的安全门有不同的功能，应该细化接口。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>SafetyDoor</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>open</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>close</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>带有密码锁的安全门应该只包含与密码锁功能相关的接口，不应该包含其它的功能，具有其它功能的安全门，我们应该单独设置新的接口。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>PasswordSafetyDoor</span> <span class=kd>extends</span> <span class=n>SafetyDoor</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>inputPassword</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>setPassword</span><span class=o>(</span><span class=n>String</span> <span class=n>oldPassword</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>FireproofSafetyDoor</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>protect</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=优先使用组合>优先使用组合</h2><p>优先使用组合，而不是继承。</p><p>类继承破坏了父类的封装，子类和父类耦合度高。</p><p>组合只要求组合的对象暴露出设计好的接口（API）即可。</p><h2 id=迪米特法则>迪米特法则</h2><p>也称为最少知识原则，一个类对于其他类知道的越少越好，用于降低类之间的耦合。</p><p>软件之间的通信通过第三方转发调用。</p><h2 id=针对接口编程>针对接口编程</h2><p>不将变量设置为具体类型，而是使用抽象接口。</p><p>客户不需要获知对象的具体类型，只需要知道暴露出的接口即可。</p></article></main><footer id=footer></footer></body></html>