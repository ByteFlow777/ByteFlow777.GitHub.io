<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://ileonli.github.io/favicon.ico><link rel=stylesheet href=/css/style.min.css><link rel=canonical href=https://ileonli.github.io/posts/design-pattern/creational-patterns/builder-pattern/><title>设计模式 - 创建型模式</title></head><body><header id=banner></header><main id=content><article><header id=post-header><h1>设计模式 - 创建型模式</h1><div><time>2023-07-14</time></div></header><p>建造者模式关注如何创建对象，将对象的创建和使用进行分离，使用者不需要关心对象的创建细节。</p><h2 id=单例模式>单例模式</h2><h3 id=饿汉式>饿汉式</h3><p>根据 <a href=https://docs.oracle.com/javase/specs/jls/se17/html/jls-8.html#jls-8.3.1.1>JLS 8.3.1.1</a> 可知类初始化时就会创建该单例对象。</p><h4 id=静态变量>静态变量</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Singleton</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=kd>static</span> <span class=n>Singleton</span> <span class=n>SINGLETON</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Singleton</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=nf>Singleton</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>Singleton</span> <span class=nf>getInstance</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>SINGLETON</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h4 id=静态方法块>静态方法块</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Singleton</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=n>Singleton</span> <span class=n>singleton</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>static</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>singleton</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Singleton</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=nf>Singleton</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>Singleton</span> <span class=nf>getInstance</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>singleton</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>静态变量会在编译时收集起来，收集到静态方法块中初始化。</p><p>通过 <code>javap -v</code> 反编译字节码文件，可以发现上边两段代码在字节码层面是一致的。</p><pre tabindex=0><code>static {};
  descriptor: ()V
  flags: (0x0008) ACC_STATIC
  Code:
    stack=2, locals=0, args_size=0
       0: new           #8                  // class org/example/Singleton
       3: dup
       4: invokespecial #13                 // Method &#34;&lt;init&gt;&#34;:()V
       7: putstatic     #7                  // Field SINGLETON:Lorg/example/Singleton;
      10: return
    LineNumberTable:
      line 4: 0
</code></pre><h3 id=懒汉式>懒汉式</h3><p>类加载时不会创建该单例对象，首次使用的时候才会创建此对象。</p><h4 id=双重检查>双重检查</h4><p>使用 <a href=https://en.wikipedia.org/wiki/Double-checked_locking>Double-checked locking</a> 实现线程安全的单例模式。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Singleton</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 添加 volatile 防止指令重排序
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kd>private</span> <span class=kd>volatile</span> <span class=kd>static</span> <span class=n>Singleton</span> <span class=n>singleton</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=nf>Singleton</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>Singleton</span> <span class=nf>getInstance</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>singleton</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=kd>synchronized</span> <span class=o>(</span><span class=n>singleton</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=o>(</span><span class=n>singleton</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>                    <span class=n>singleton</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Singleton</span><span class=o>();</span>
</span></span><span class=line><span class=cl>                <span class=o>}</span>
</span></span><span class=line><span class=cl>            <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>singleton</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h4 id=静态内部类>静态内部类</h4><p>外部类加载时，不会直接加载内部类，当第一次使用内部类时才会进行加载。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Singleton</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=nf>Singleton</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=kd>class</span> <span class=nc>SingletonHolder</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>static</span> <span class=kd>final</span> <span class=n>Singleton</span> <span class=n>singleton</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Singleton</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>static</span> <span class=n>Singleton</span> <span class=nf>getInstance</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>SingletonHolder</span><span class=o>.</span><span class=na>singleton</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h3 id=枚举类单例>枚举类单例</h3><p>使用反射和序列化等方法可以破坏单例模式，推荐使用枚举类实现单例模式。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>enum</span> <span class=n>Singleton</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>SINGLETON</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>f</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=工厂模式>工厂模式</h2><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。工厂方法的目的是使得创建对象和使用对象是分离的。</p><p>创建对象可能会导致大量的重复代码，可能会需要复合对象访问不到的信息，也可能提供不了足够级别的抽象，还可能并不是复合对象概念的一部分。工厂方法模式通过定义一个单独的创建对象的方法来解决这些问题。由子类实现这个方法来创建具体类别的对象。</p><p>有一个Button类别表示按钮，另有它的两个子类 WinButton 和 MacButton 分别代表 Windows 和 Mac 风格的按钮，那么这几个类别和用于创建它们的工厂类别在 Java 中可以如下实现。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=c1>// Button
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=kd>class</span> <span class=nc>Button</span><span class=o>{</span><span class=cm>/* ...*/</span><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>WinButton</span> <span class=kd>extends</span> <span class=n>Button</span><span class=o>{</span><span class=cm>/* ...*/</span><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>MacButton</span> <span class=kd>extends</span> <span class=n>Button</span><span class=o>{</span><span class=cm>/* ...*/</span><span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 工厂类
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>ButtonFactory</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Button</span> <span class=nf>createButton</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>WinButtonFactory</span> <span class=kd>implements</span> <span class=n>ButtonFactory</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Button</span> <span class=nf>createButton</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>new</span> <span class=n>WinButton</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>MacButtonFactory</span> <span class=kd>implements</span> <span class=n>ButtonFactory</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Button</span> <span class=nf>createButton</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=k>new</span> <span class=n>MacButton</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=静态工厂方法>静态工厂方法</h2><p>JDK 中的 <code>List.of(1, 2, 3);</code> 和 <code>Integer.valueOf(10);</code> 都属于静态工厂方法。</p><p>使用者调用 <code>List.of</code> 方法后总是返回 <code>List</code> 接口，使用者无需关心返回的实际类型，隐藏了细节。此思想也是里氏替换原则的体现，返回实现接口的任意子类都可以满足该方法的要求，且不影响调用方。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=c1>// List.of 有很多重载方法，此处省略其它实现
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>static</span> <span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=nf>of</span><span class=o>(</span><span class=n>E</span><span class=o>...</span> <span class=n>elements</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span> <span class=o>(</span><span class=n>elements</span><span class=o>.</span><span class=na>length</span><span class=o>)</span> <span class=o>{</span> <span class=c1>// implicit null check of elements
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>case</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=nd>@SuppressWarnings</span><span class=o>(</span><span class=s>&#34;unchecked&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=n>var</span> <span class=n>list</span> <span class=o>=</span> <span class=o>(</span><span class=n>List</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;)</span> <span class=n>ImmutableCollections</span><span class=o>.</span><span class=na>EMPTY_LIST</span><span class=o>;</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>list</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=mi>1</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=k>new</span> <span class=n>ImmutableCollections</span><span class=o>.</span><span class=na>List12</span><span class=o>&lt;&gt;(</span><span class=n>elements</span><span class=o>[</span><span class=mi>0</span><span class=o>]);</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=mi>2</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=k>new</span> <span class=n>ImmutableCollections</span><span class=o>.</span><span class=na>List12</span><span class=o>&lt;&gt;(</span><span class=n>elements</span><span class=o>[</span><span class=mi>0</span><span class=o>],</span> <span class=n>elements</span><span class=o>[</span><span class=mi>1</span><span class=o>]);</span>
</span></span><span class=line><span class=cl>        <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=n>ImmutableCollections</span><span class=o>.</span><span class=na>listFromArray</span><span class=o>(</span><span class=n>elements</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><code>Integer.valueOf</code> 采用了缓存机制，可以提升性能，但调用者无需关心创建的具体细节，向用户隐藏具体细节，减少调用者的负担。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>static</span> <span class=n>Integer</span> <span class=nf>valueOf</span><span class=o>(</span><span class=kt>int</span> <span class=n>i</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=o>(</span><span class=n>i</span> <span class=o>&gt;=</span> <span class=n>IntegerCache</span><span class=o>.</span><span class=na>low</span> <span class=o>&amp;&amp;</span> <span class=n>i</span> <span class=o>&lt;=</span> <span class=n>IntegerCache</span><span class=o>.</span><span class=na>high</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>IntegerCache</span><span class=o>.</span><span class=na>cache</span><span class=o>[</span><span class=n>i</span> <span class=o>+</span> <span class=o>(-</span><span class=n>IntegerCache</span><span class=o>.</span><span class=na>low</span><span class=o>)];</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>new</span> <span class=n>Integer</span><span class=o>(</span><span class=n>i</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><h2 id=抽象工厂模式>抽象工厂模式</h2><p>抽象方法表明工厂也是抽象的，可能会有多个不同的工厂。</p><p>当我们需要使用 JSON 或 XML 格式化对象时，我们抽象出 <code>Formatter</code> 接口，<code>JsonFormatter</code> 和 <code>XmlFormatter</code> 为具体的格式化实现。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>Formatter</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=nf>format</span><span class=o>(</span><span class=n>Object</span> <span class=n>obj</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>JsonFormatter</span> <span class=kd>implements</span> <span class=n>Formatter</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>String</span> <span class=nf>format</span><span class=o>(</span><span class=n>Object</span> <span class=n>obj</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Use Jackson or Fastjson to format obj and return value.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>XmlFormatter</span> <span class=kd>implements</span> <span class=n>Formatter</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>String</span> <span class=nf>format</span><span class=o>(</span><span class=n>Object</span> <span class=n>obj</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Use Jackson to format obj and return value.
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>抽象出 <code>AbstractFormatterFactory</code> 接口，表示不同的工厂类型。接口中的 <code>default</code> 方法会根据用户传入的 <code>type</code> 创建对应的工厂。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>AbstractFormatterFactory</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Formatter</span> <span class=nf>createFormatter</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>default</span> <span class=n>AbstractFormatterFactory</span> <span class=nf>createFactory</span><span class=o>(</span><span class=n>String</span> <span class=n>type</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=s>&#34;JSON&#34;</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>type</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=k>new</span> <span class=n>JsonFormatterFactory</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=s>&#34;XML&#34;</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>type</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=k>new</span> <span class=n>XmlFormatterFactory</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=k>throw</span> <span class=k>new</span> <span class=n>IllegalArgumentException</span><span class=o>(</span><span class=s>&#34;Unknown formatter type&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>具体的工厂实现，由于大部分 <code>Formatter</code> 都可以</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-Java data-lang=Java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>JsonFormatterFactory</span> <span class=kd>implements</span> <span class=n>AbstractFormatterFactory</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=kd>static</span> <span class=n>JsonFormatter</span> <span class=n>FORMATTER</span> <span class=o>=</span> <span class=k>new</span> <span class=n>JsonFormatter</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Formatter</span> <span class=nf>createFormatter</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FORMATTER</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>XmlFormatterFactory</span> <span class=kd>implements</span> <span class=n>AbstractFormatterFactory</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=n>XmlFormatter</span> <span class=n>FORMATTER</span> <span class=o>=</span> <span class=k>new</span> <span class=n>XmlFormatter</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>Formatter</span> <span class=nf>createFormatter</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>FORMATTER</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div></article></main><footer id=footer></footer></body></html>