<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Categories on Leon Li (byteflow777 at gmail dot com)</title><link>https://netholes.github.io/categories/</link><description>Recent content in Categories on Leon Li (byteflow777 at gmail dot com)</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://netholes.github.io/categories/index.xml" rel="self" type="application/rss+xml"/><item><title>设计模式-建造者模式</title><link>https://netholes.github.io/posts/design-pattern/builder-pattern/</link><pubDate>Fri, 14 Jul 2023 00:00:00 +0000</pubDate><guid>https://netholes.github.io/posts/design-pattern/builder-pattern/</guid><description>&lt;p>建造者模式关注如何创建对象，将对象的创建和使用进行分离，使用者不需要关心对象的创建细节。&lt;/p>
&lt;h2 id="单例模式">单例模式&lt;/h2>
&lt;h3 id="饿汉式">饿汉式&lt;/h3>
&lt;p>根据 &lt;a href="https://docs.oracle.com/javase/specs/jls/se17/html/jls-8.html#jls-8.3.1.1">JLS 8.3.1.1&lt;/a> 可知类初始化时就会创建该单例对象。&lt;/p>
&lt;h4 id="静态变量">静态变量&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Singleton&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="n">Singleton&lt;/span> &lt;span class="n">SINGLETON&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Singleton&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="nf">Singleton&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="n">Singleton&lt;/span> &lt;span class="nf">getInstance&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">SINGLETON&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="静态方法块">静态方法块&lt;/h4>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Singleton&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="n">Singleton&lt;/span> &lt;span class="n">singleton&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">static&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">singleton&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Singleton&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="nf">Singleton&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="n">Singleton&lt;/span> &lt;span class="nf">getInstance&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">singleton&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>静态变量会在编译时收集起来，收集到静态方法块中初始化。&lt;/p>
&lt;p>通过 &lt;code>javap -v&lt;/code> 反编译字节码文件，可以发现上边两段代码在字节码层面是一致的。&lt;/p>
&lt;pre tabindex="0">&lt;code>static {};
descriptor: ()V
flags: (0x0008) ACC_STATIC
Code:
stack=2, locals=0, args_size=0
0: new #8 // class org/example/Singleton
3: dup
4: invokespecial #13 // Method &amp;#34;&amp;lt;init&amp;gt;&amp;#34;:()V
7: putstatic #7 // Field SINGLETON:Lorg/example/Singleton;
10: return
LineNumberTable:
line 4: 0
&lt;/code>&lt;/pre>&lt;h3 id="懒汉式">懒汉式&lt;/h3>
&lt;p>类加载时不会创建该单例对象，首次使用的时候才会创建此对象。&lt;/p>
&lt;h4 id="双重检查">双重检查&lt;/h4>
&lt;p>使用 &lt;a href="https://en.wikipedia.org/wiki/Double-checked_locking">Double-checked locking&lt;/a> 实现线程安全的单例模式。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Singleton&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1">// 添加 volatile 防止指令重排序
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span> &lt;span class="kd">private&lt;/span> &lt;span class="kd">volatile&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="n">Singleton&lt;/span> &lt;span class="n">singleton&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="nf">Singleton&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="n">Singleton&lt;/span> &lt;span class="nf">getInstance&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">singleton&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">synchronized&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">singleton&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">singleton&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">singleton&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Singleton&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">singleton&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="静态内部类">静态内部类&lt;/h4>
&lt;p>外部类加载时，不会直接加载内部类，当第一次使用内部类时才会加载类。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Singleton&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="nf">Singleton&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">private&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">SingletonHolder&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">static&lt;/span> &lt;span class="kd">final&lt;/span> &lt;span class="n">Singleton&lt;/span> &lt;span class="n">singleton&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">Singleton&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="n">Singleton&lt;/span> &lt;span class="nf">getInstance&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">SingletonHolder&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">singleton&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="枚举类单例">枚举类单例&lt;/h3>
&lt;p>使用反射和序列化可以破坏单例模式，推荐使用枚举类实现单例模式。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">enum&lt;/span> &lt;span class="n">Singleton&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">SINGLETON&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">f&lt;/span>&lt;span class="o">()&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>设计模式-软件设计原则</title><link>https://netholes.github.io/posts/design-pattern/design-principles/</link><pubDate>Fri, 14 Jul 2023 00:00:00 +0000</pubDate><guid>https://netholes.github.io/posts/design-pattern/design-principles/</guid><description>&lt;h2 id="开闭原则">开闭原则&lt;/h2>
&lt;p>对&lt;strong>扩展&lt;/strong>开放，对&lt;strong>修改&lt;/strong>关闭。在程序需要进行扩展的时候，不用去修改原有的代码。&lt;/p>
&lt;p>我们可以使用&lt;strong>接口&lt;/strong>和&lt;strong>抽象类&lt;/strong>实现这样的效果。当我们实现验证码功能时，可以抽象出一个接口，然后为短信提供商提供具体的实现，当新增短信提供商时，只需新增实现即可。&lt;/p>
&lt;h2 id="里氏代换">里氏代换&lt;/h2>
&lt;p>任何基类可以出现的地方，子类一定可以出现。子类可以扩展父类的功能，但不要改变父类原有的功能。&lt;/p>
&lt;p>里氏代换是继承复用的基石，只有当子类可以替换掉基类且软件的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。&lt;/p>
&lt;p>当我们创建鸟类的时候，由于鸟有可以飞、不可以飞和可以飞和可以走三大类。我们应该更进一步细化，分为：FlyingBirds 和 NonflyingBirds 两种。不同的鸟实现不同的接口，细化功能。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">Bird&lt;/span> &lt;span class="o">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">FlyingBirds&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">Bird&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">fly&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">NonflyingBirds&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">Bird&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">walk&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 鸭子
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Duck&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">FlyingBirds&lt;/span>&lt;span class="err">，&lt;/span> &lt;span class="n">NonflyingBirds&lt;/span> &lt;span class="o">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">// 鸵鸟
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Ostrich&lt;/span> &lt;span class="kd">implements&lt;/span> &lt;span class="n">NonflyingBirds&lt;/span> &lt;span class="o">{}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">FlyingBirds&lt;/span> &lt;span class="n">fb&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="n">fb&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">fly&lt;/span>&lt;span class="o">();&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">run&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">NonflyingBirds&lt;/span> &lt;span class="n">nb&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span> &lt;span class="n">nb&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">walk&lt;/span>&lt;span class="o">();&lt;/span> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="依赖倒转">依赖倒转&lt;/h2>
&lt;p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。&lt;/p>
&lt;p>当我们需要计算列表的和时，参数使用 List 父接口，子类可以传入不同的实现，如：ArrayList 和 LinkedList 等。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">sum&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">List&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">Integer&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">int&lt;/span> &lt;span class="n">sum&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">Integer&lt;/span> &lt;span class="n">n&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">list&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">sum&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">sum&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="接口隔离">接口隔离&lt;/h2>
&lt;p>客户端不应该被强迫使用不应该被使用的方法，一个类多另一个类的依赖应该建立在最小的接口上。&lt;/p>
&lt;p>当我们需要实现安全门类的时候，不同的安全门有不同的功能，应该细化接口。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">SafetyDoor&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">open&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">close&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>带有密码锁的安全门应该只包含与密码锁功能相关的接口，不应该包含其它的功能，具有其它功能的安全门，我们应该单独设置新的接口。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">PasswordSafetyDoor&lt;/span> &lt;span class="kd">extends&lt;/span> &lt;span class="n">SafetyDoor&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">inputPassword&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">setPassword&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span> &lt;span class="n">oldPassword&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">public&lt;/span> &lt;span class="kd">interface&lt;/span> &lt;span class="nc">FireproofSafetyDoor&lt;/span> &lt;span class="o">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kt">void&lt;/span> &lt;span class="nf">protect&lt;/span>&lt;span class="o">();&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="o">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="迪米特法则">迪米特法则&lt;/h2>
&lt;p>也称为最少知识原则，一个类对于其他类知道的越少越好，用于降低类之间的耦合。&lt;/p>
&lt;p>软件之间的通信通过第三方转发调用。&lt;/p>
&lt;h2 id="合成复用">合成复用&lt;/h2>
&lt;p>优先使用组合或聚合等关联关系来实现，其次才考虑使用继承关系来实现。&lt;/p>
&lt;p>继承破环了类的封装性，导致子类和父类之间的耦合度高，限制了灵活性。&lt;/p></description></item><item><title>Unix 系统下的调试：gdb 教程【翻译】</title><link>https://netholes.github.io/posts/gdb/debugging-under-unix-gdb-tutorial/</link><pubDate>Tue, 09 May 2023 00:00:00 +0000</pubDate><guid>https://netholes.github.io/posts/gdb/debugging-under-unix-gdb-tutorial/</guid><description>&lt;blockquote>
&lt;p>原文地址：https://www.cs.cmu.edu/~gilpin/tutorial/&lt;/p>
&lt;/blockquote>
&lt;h2 id="介绍">介绍&lt;/h2>
&lt;p>这个教程来自于&lt;a href="http://www.wustl.edu/">华盛顿大学&lt;/a>的 CS 342 课程，目前仍由 &lt;a href="http://www.cs.cmu.edu/~gilpin/">Andrew Gilpin&lt;/a> 维护。&lt;/p>
&lt;h2 id="谁需要此篇教程">谁需要此篇教程？&lt;/h2>
&lt;p>这篇教程是帮助新接触 Unix 环境的程序员使用 gdb 进行调试的。我们假设你已经知道如何使用 C++ 编程，并且可以编译和执行程序。同样假设你知道什么是调试（debug）并且你曾经在其它系统上使用过调试器（debugger）。&lt;/p>
&lt;h2 id="源代码">源代码&lt;/h2>
&lt;p>为了展示一些调试原则（principles），我将使用一个含有 bug 的程序作为例子。当你跟着本教程，你将使用调试器找到并修复代码中的错误。你可以从&lt;a href="https://www.cs.cmu.edu/~gilpin/tutorial/main.cc">此处&lt;/a>下载 C++ 代码（&lt;a href="https://netholes.github.io/file/gdb/main.cc">本站备份&lt;/a>），从&lt;a href="https://www.cs.cmu.edu/~gilpin/tutorial/Makefile">此处&lt;/a>下载 Makefile 文件（&lt;a href="https://netholes.github.io/file/gdb/Makefile">本站备份&lt;/a>）。&lt;/p>
&lt;p>这是一段非常简单的代码，此代码包含两个类定义，分别是：Node 和 LinkedList。还有一个简单的代码测试用于此链表。所有的代码都放在一个文件中，以便更容易的展示调试过程。&lt;/p>
&lt;h2 id="准备工作">准备工作&lt;/h2>
&lt;h3 id="环境配置">环境配置&lt;/h3>
&lt;p>原文中提到的机器大概率已不再使用，故不再翻译。可以通过 Google 搜索安装方式。&lt;/p>
&lt;h3 id="调试符号">调试符号&lt;/h3>
&lt;p>gdb 只能使用 g++ 生成的调试符号（debugging symbols）。对于使用 Sun CC 的用户，可以使用与 gdb 非常相似的 dbx 调试器。&lt;/p>
&lt;p>但调试链接有调试符号的程序时，gdb 是最有效的（effective）。使用 g++ 编译器时，可以使用 &lt;a href="https://man7.org/linux/man-pages/man1/gcc.1.html#:~:text=%2Dg%20%20Produce%20debugging,(see%20below).">-g&lt;/a> 或 &lt;a href="https://man7.org/linux/man-pages/man1/gcc.1.html#:~:text=%2Dggdb%0A%20%20%20%20%20%20%20%20%20%20%20Produce%20debugging%20information%20for%20use%20by%20GDB.%20%20This%20means%20to%0A%20%20%20%20%20%20%20%20%20%20%20use%20the%20most%20expressive%20format%20available%20(DWARF%2C%20stabs%2C%20or%0A%20%20%20%20%20%20%20%20%20%20%20the%20native%20format%20if%20neither%20of%20those%20are%20supported)%2C%0A%20%20%20%20%20%20%20%20%20%20%20including%20GDB%20extensions%20if%20at%20all%20possible.">-ggdb&lt;/a> 生成调试符号。使用 -ggdb 可以生成更多信息，此教程提供的 Makefile 使用了 -ggdb 参数。&lt;/p>
&lt;h2 id="调试">调试&lt;/h2>
&lt;h3 id="何时使用调试器">何时使用调试器&lt;/h3>
&lt;p>调试是不可避免的事情，所有程序员在他们的职业生涯中都会至少调试一段代码。调试的方法有很多，从向屏幕中打印信息，使用调试器，或者思考程序在做什么并对问题是什么作出有根据的猜测。&lt;/p>
&lt;h3 id="加载程序">加载程序&lt;/h3>
&lt;p>当你有一个可执行文件（在我们例子中是 main）并且你想调试时。首先，你必须启动一个调试器。这个调试器叫做 gdb，你可以通过 shell 命令提示符输入调试的文件。输入 &lt;code>$ gdb main&lt;/code> 用于调试 main 程序，输出如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">(gdb) run
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Copyright (C) 2023 Free Software Foundation, Inc.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">This is free software: you are free to change and redistribute it.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">There is NO WARRANTY, to the extent permitted by law.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Type &amp;#34;show copying&amp;#34; and &amp;#34;show warranty&amp;#34; for details.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">This GDB was configured as &amp;#34;x86_64-redhat-linux-gnu&amp;#34;.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Type &amp;#34;show configuration&amp;#34; for configuration details.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">For bug reporting instructions, please see:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&amp;lt;https://www.gnu.org/software/gdb/bugs/&amp;gt;.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Find the GDB manual and other documentation resources online at:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &amp;lt;http://www.gnu.org/software/gdb/documentation/&amp;gt;.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">For help, type &amp;#34;help&amp;#34;.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Type &amp;#34;apropos word&amp;#34; to search for commands related to &amp;#34;word&amp;#34;...
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Reading symbols from main...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>gdb 当前正在等待用户输入的命令。我们需要运行程序后，以便调试器帮助我们查看程序崩溃时发生了什么。在命令提示符中输入 &lt;code>$ run&lt;/code> 后，输出如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">(gdb) run
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Starting program: /home/user/main
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Creating Node, 1 are in existence right now
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Creating Node, 2 are in existence right now
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Creating Node, 3 are in existence right now
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Creating Node, 4 are in existence right now
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">The fully created list is:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Now removing elements:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Creating Node, 5 are in existence right now
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Destroying Node, 4 are in existence right now
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Program received signal SIGSEGV, Segmentation fault.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0x00000000004016cc in Node&amp;lt;int&amp;gt;::next (this=0x0) at main.cc:30
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30 Node&amp;lt;T&amp;gt;* next () const { return next_; }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>程序崩溃了，让我们看看能收集到什么信息。&lt;/p>
&lt;h3 id="检查崩溃">检查崩溃&lt;/h3>
&lt;p>我们可以看到程序的 main.cc 文件中的 30 行，this 指针指向了 0x0。但我们想知道谁调用了这个方法并且检查调用方法中的值。在命令提示符中输入 &lt;code>$ backtrace&lt;/code> 后，输出如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">(gdb) backtrace
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#0 0x00000000004016cc in Node&amp;lt;int&amp;gt;::next (this=0x0) at main.cc:30
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#1 0x00000000004015db in LinkedList&amp;lt;int&amp;gt;::remove (this=0x4172b0, item_to_remove=@0x7fffffffddac: 1) at main.cc:79
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">#2 0x00000000004012c7 in main (argc=1, argv=0x7fffffffdef8) at main.cc:122
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>除了知道的当前方法和本地变量，现在还可以看到那个方法调用了我们，以及此次调用的参数。例如：我们可以看到我们被 &lt;code>LinkedList&amp;lt;int&amp;gt;::remove&lt;/code> 方法调用， item_to_remove 参数为地址 0x7fffffffddac 所指向的位置。如果我们知道 item_to_remove 的值，会帮助我们理解程序的 bug。可以使用 &lt;code>$ x 0x7fffffffddac&lt;/code> 命令查看值（&amp;ldquo;x&amp;rdquo; 可以被理解为 &amp;ldquo;examine&amp;rdquo; 的缩写）。以下为运行命令后的输入：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">(gdb) x 0x7fffffffddac
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0x7fffffffddac: 0x00000001
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当运行 &lt;code>LinkedList&amp;lt;int&amp;gt;::remove&lt;/code> 方法且参数为 1 时，程序会发生崩溃。现在我们已经将问题缩小到具体的函数和参数值。&lt;/p>
&lt;h3 id="条件断点">条件断点&lt;/h3>
&lt;p>现在我们已经知道段错误（segmentation fault）在何时何处发生，但我们现在想知道程序崩溃前发生了什么。一种方式是逐步执行程序的每条语句，执行到我们想观察的语句。这行没有任何问题，但有时候你可能想运行程序代码中的一段区域，并且在此处停止执行并查看数据。&lt;/p>
&lt;p>如果你曾经使用过调试器，你可能非常熟悉断点的概念。断点是源码中的一行，调试器执行时会停在此处。在我们的例子中，我们想查看 &lt;code>LinkedList&amp;lt;int&amp;gt;::remove&lt;/code> 的代码，因此我们可以在 main.cc 文件的 54 行设置断点。由于你不知道具体的行号，你可以告诉调试器在具体的函数处设置断点。这时我们例子中输入的信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">(gdb) break LinkedList&amp;lt;int&amp;gt;::remove
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Breakpoint 1 at 0x401477: file main.cc, line 54.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>根据需要，断点 1 被设置在了 main.cc 中 54 行（设置断点后会得到一个数字，后续可以通过此数字引用该断点，比如：删除此断点）。当程序每次运行到 54 行时，它会将控制转移给调试器。当方法被调用许多次，但只有当传来某一具体参数（如：1）才会发生问题时，这是不可取的。条件断点将帮我们处理此类问题。在我们的例子中，我们已经知道程序会在调用 &lt;code>LinkedList&amp;lt;int&amp;gt;::remove&lt;/code> 方法且参数 为 1 时发生崩溃。如果我们想让调试器仅在 &lt;code>item_to_remove&lt;/code> 等于 1 时在 54 行中断（break），可以通过以下命令执行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">(gdb) condition 1 item_to_remove == 1
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以简单理解为：“仅在 &lt;code>item_to_remove&lt;/code> 等于 1时，才在断点 1 处中断“。现在我们可以运行程序并且知道调试器仅当设定的条件为 true 时才会发生中断。&lt;/p>
&lt;h3 id="stepping">Stepping&lt;/h3>
&lt;p>继续上面的例子，我们已经设置了一个条件断点，现在想一行一行地浏览这个方法，看看我们是否能找到错误的源头。我们可以通过 step 命令。gdb 有一个很好的特点，当没有输入命令就按下回车键时，会自动执行上一次执行的一条命令。这样，我们就可以在输入 step 后，简单地按下回车键，就可以执行上一次执行的命令 step。下面是这种情况的样子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">(gdb) run
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Using host libthread_db library &amp;#34;/home/user/main&amp;#34;.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Creating Node, 1 are in existence right now
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Creating Node, 2 are in existence right now
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Creating Node, 3 are in existence right now
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Creating Node, 4 are in existence right now
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">The fully created list is:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Now removing elements:
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Creating Node, 5 are in existence right now
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Destroying Node, 4 are in existence right now
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">4
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">3
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">2
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">1
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Breakpoint 1, LinkedList&amp;lt;int&amp;gt;::remove (this=0x4172b0, item_to_remove=@0x7fffffffddac: 1) at main.cc:54
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">54 Node&amp;lt;T&amp;gt; *marker = head_;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(gdb) step
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">55 Node&amp;lt;T&amp;gt; *temp = 0; // temp points to one behind as we iterate
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(gdb)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">57 while (marker != 0) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(gdb)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">58 if (marker-&amp;gt;value() == item_to_remove) {
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(gdb)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Node&amp;lt;int&amp;gt;::value (this=0x417760) at main.cc:32
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">32 const T&amp;amp; value () const { return value_; }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(gdb)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">LinkedList&amp;lt;int&amp;gt;::remove (this=0x4172b0, item_to_remove=@0x7fffffffddac: 1) at main.cc:77
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">77 marker = 0; // reset the marker
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(gdb)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">78 temp = marker;
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(gdb)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">79 marker = marker-&amp;gt;next();
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(gdb)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Node&amp;lt;int&amp;gt;::next (this=0x0) at main.cc:30
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30 Node&amp;lt;T&amp;gt;* next () const { return next_; }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(gdb)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Program received signal SIGSEGV, Segmentation fault.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">0x00000000004016cc in Node&amp;lt;int&amp;gt;::next (this=0x0) at main.cc:30
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">30 Node&amp;lt;T&amp;gt;* next () const { return next_; }
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">(gdb)
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">Program terminated with signal SIGSEGV, Segmentation fault.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">The program no longer exists.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当输入 &lt;code>$ run&lt;/code> 命令后，gdb 会询问我们是否想重新运行此程序，我们选择”是“。程序会继续运行并中断在指定的位置。然后我们输入 &lt;code>$ step&lt;/code> 并继续按回车键浏览程序。使用 step 命令时，调试器会进入调用的函数内部。如果你不想进入函数内部，可以使用 next 替代 step，这俩命令其它行为则是一致的。&lt;/p>
&lt;p>程序中的错误是非常明显的，在 77 行 marker 被设置为了 0，但在 79 行通过 marker 指针访问了 next 方法。因为程序不能访问内存为 0 的位置，因此发生了段错误。在我们的代码中，移除 main.cc 文件中 77 行设置 marker 的代码既可以避免错误。&lt;/p>
&lt;p>如果你看一下运行程序的输出，首先你会看到程序运行时没有崩溃，但是在程序的某个地方存在内存泄漏（提示：是在 &lt;code>LinkedList&amp;lt;T&amp;gt;::remove()&lt;/code> 函数中,remove 的其中一个情况不能正常工作）。读者可以利用调试器来定位和修复这个错误，这是一个练习。(我一直想这么说。;)&lt;/p>
&lt;p>可以输入 &lt;code>$ quit&lt;/code> 退出 gdb 调试器。&lt;/p>
&lt;h2 id="更多信息">更多信息&lt;/h2>
&lt;p>本文件只包括开始使用 gdb 所需的基本命令。关于 gdb 的更多信息见 gdb man 页，或者在&lt;a href="https://www.sourceware.org/gdb/">此处&lt;/a>查看关于 gdb 的更详细的描述。在线帮助可以在运行 gdb 时输入 &lt;code>$ help&lt;/code> 来访问。另外，像往常一样，欢迎在新闻组上提问，或者你可以在实验室时间问我。&lt;/p>
&lt;h2 id="提示">提示&lt;/h2>
&lt;ol>
&lt;li>在本文给出的源代码中还有一个错误，在上述代码中没有提到。对于所提供的测试代码中的插入和删除序列，该错误没有显示出来，但对于其他序列，该错误会显示出来。例如，插入 1、2、3 和 4，然后试图删除 2，就会出现错误。特别感谢 Linda Gu 和 Xiaofeng Chen 找到了这个错误。这个错误的修复是非常简单的，我们把它作为一个练习。&lt;/li>
&lt;li>特别感谢 Ximmbo da Jazz 为一些错别字和错误的输出提供了宝贵的修正。&lt;/li>
&lt;li>特别感谢 Raghuprasad Govindarao 发现了一个无效的链接。&lt;/li>
&lt;/ol></description></item><item><title>tmux 快速简单的实践指南【翻译】</title><link>https://netholes.github.io/posts/tmux/a-quick-and-easy-guide-to-tmux/</link><pubDate>Thu, 04 May 2023 00:00:00 +0000</pubDate><guid>https://netholes.github.io/posts/tmux/a-quick-and-easy-guide-to-tmux/</guid><description>&lt;blockquote>
&lt;p>原文地址：https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/&lt;/p>
&lt;/blockquote>
&lt;p>我喜欢使用命令行进行工作。我认为对于软件开发人员来说，没有比终端更高效、更通用的工具了。当你使用终端时，通常感觉是自由的（free），为什么不喜欢呢？&lt;/p>
&lt;p>过去的这些年里，我一直在尝试精简和自定义我的命令行，使其变得更易于使用、更有趣或仅仅看起来不错。tmux 是让我日常使用命令行时，有良好体验的最重要工具之一。&lt;/p>
&lt;p>&lt;img src="https://netholes.github.io/img/tmux/tmux-1.png" alt="">&lt;/p>
&lt;p>这张截图展示的东西简直是自面包切片以来最好的事情（译者注：&lt;a href="https://www.plansponsor.com/tuesday-trivia-origin-phrase-best-thing-since-sliced-bread/">面包切片&lt;/a>表示对某事或物的赞许）。这就是被叫做终端复用器（terminal multiplexer）的 &lt;a href="https://github.com/tmux/tmux/wiki">tmux&lt;/a>。简单来说，tmux 就是终端中的窗口管理器（脚注 1），该管理器允许你在一个终端窗口中创建多个窗口（windows）和面板（panes）。&lt;/p>
&lt;p>这篇文章将告诉你一些关于 tmux 的介绍和它的潜力，随后是大约 10 分钟的手把手教程，用于设置和了解 tmux。如果你有 10 分钟的空闲时间，并想与你的“书呆子”朋友们赚取街头信誉（译者注：使用 tmux 可以用于&lt;del>装逼&lt;/del>）&lt;/p>
&lt;h2 id="关于-tmux">关于 tmux&lt;/h2>
&lt;p>tmux 的作者将其描述为终端复用器，在这个华丽的词语下隐藏着一个简单的概念：在一个终端中你可以打开多个窗口和分屏视图（split-views），分屏视图在 tmux 中也被叫做面板（panes）。每个面板都有其独立运行的 shell 实例（bash, zhs, 或其它）。这可以让你在一个终端中运行多个终端命令和应用程序，而不需要打开其它终端。&lt;/p>
&lt;p>更重要的是，tmux 会把所有的窗口和面板都会被保存到一个会话中（session）。你可以在任何时间退出一个会话，这被叫做分离（detaching）。tmux 会使所有的会话一直存活，除非主动结束 tmux 服务，比如：重启电脑（脚注 2）。此功能非常有用，因为在后续的任何时间点，你都可以附加（attaching）到离开的对话中。&lt;/p>
&lt;p>如果你曾经通过 ssh 连接到远程服务器或者树莓派（Raspberry Pi）中，你就会知道保留会话的功能非常有用。当 ssh 连接断开后（lose ssh connection），此 tmux 会话将会被分离，但会话仍会在服务其中运行，包括在会话中运行的进程。要继续此会话，只需再次 ssh 到服务器并附加到正在运行的会话。&lt;/p>
&lt;p>当在远程机器上工作时，tmux 将非常有用。当然，在本地工作时，它也非常有用。不仅仅是窗口管理功能，还以为其会话处理功能。就我个人而言，当我切换上下文时，发现自己会脱离会话。当我想继续运行旧任务时，我仅为我的新任务启动一个新会话，并附加到旧会话。&lt;/p>
&lt;p>你可以看到 tmux 基本上提供了两个基本功能：&lt;/p>
&lt;ol>
&lt;li>终端中的管理窗口&lt;/li>
&lt;li>会话管理&lt;/li>
&lt;/ol>
&lt;p>如果你熟悉 &lt;a href="https://www.gnu.org/software/screen/">GNU Screen&lt;/a>，会发现功能很相似。可以把 tmux 看作是 Screen 的一个更容易使用和更强大的替代品（显然我在这里有些固执己见）。&lt;/p>
&lt;p>概念足够了，让我们开始动手实践！&lt;/p>
&lt;h2 id="入门">入门&lt;/h2>
&lt;p>这个实践指南将帮助你很快上手使用 tmux。它将只涵盖基本的功能，这些功能应该足以让您入门并使用 tmux 提高工作效率。只需打开您的终端并按照说明操作即可。&lt;/p>
&lt;h2 id="安装">安装&lt;/h2>
&lt;p>幸运的是，在大多数操作系统中安装 tmux 是非常简单的。一个简单的 &lt;code>sudo apt-get install tmux&lt;/code>（Ubuntu, WSL 和其衍生版本） 或 &lt;code>brew install tmux&lt;/code>（Mac） 就可以了。&lt;/p>
&lt;h2 id="创建第一个会话">创建第一个会话&lt;/h2>
&lt;p>对于你的第一个会话，简单的使用 &lt;code>tmux&lt;/code> 命令即可创建新会话。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ tmux
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这将创建一个新的 tmux 会话，会话底部会有一个绿色的状态栏。&lt;/p>
&lt;p>&lt;img src="https://netholes.github.io/img/tmux/tmux-2.png" alt="">&lt;/p>
&lt;p>状态栏是 tmux 非常重要的一部分，除了当前打开的窗口信息（左边），它还展示了一些系统信息，如：日期和时间（右边）。状态栏也可以定制，我看过一些非常漂亮（即将到来的日历事件、电池状态等），但这些是我们后续需要做的。&lt;/p>
&lt;h2 id="分离面板">分离面板&lt;/h2>
&lt;p>我们已经创建了第一个对话，可以了解一下面板的使用感觉。当你创建了一个新对话后，tmux 默认打开包含一个面板的窗口。但我们想要一个漂亮的分屏，让我们把它分开吧！&lt;/p>
&lt;p>在 tmux 中的所有命令都前缀键（prefix key）和命令键（command key）组成（emacs 使用者会比较熟悉）。默认情况，tmux 使用 &lt;code>C-b&lt;/code> 作为前缀键。如果你不习惯，这个符号读起来会很奇怪。在 emacs 中， &lt;code>C-&lt;/code> 符号表示长按 ctrl 键（脚注 3）。因此，&lt;code>C-b&lt;/code> 表示同时按下 ctrl 和 b 键。&lt;/p>
&lt;p>将面板分离为左右面板的快捷键是 &lt;code>C-b %&lt;/code>。此快捷键的意思是：同时按下 ctrl 和 b 键，然后松手，随后按下 % 键。你刚刚使用第一个 tmux 命令把你的面板分离为两个。&lt;/p>
&lt;p>&lt;img src="https://netholes.github.io/img/tmux/tmux-3.png" alt="">&lt;/p>
&lt;p>有左右分割，也有上下分割。要将窗格分割为顶部窗格和底部窗格，请使用 &lt;code>C-b &amp;quot;&lt;/code> 快捷键。&lt;/p>
&lt;h2 id="切换面板">切换面板&lt;/h2>
&lt;p>现在我们被困在新创建的窗口中，但我们很想回到左边面板。十分简单，切换到不同面板可以使用 &lt;code>C-b &amp;lt;方向键&amp;gt;&lt;/code> 快捷键， &lt;code>&amp;lt;方向键&amp;gt;&lt;/code> 表示想要切换到的窗口的方向。在我们的例子中，我们想要切换到左边的面板所以留给我们的是 &lt;code>C-b left&lt;/code>。再重复一遍，以便我们完全理解: 这意味着你按 ctrl 和 b 键（前缀命令），然后按左箭头键以到达左侧的面板。&lt;/p>
&lt;p>现在，你可以继续并进一步拆分每个新面板。你可以自由地尝试，像疯子一样分裂你的窗格来感受它。&lt;/p>
&lt;h2 id="关闭面板">关闭面板&lt;/h2>
&lt;p>关闭窗格就像关闭常规终端会话一样简单。键入 &lt;code>$ exit&lt;/code> 或按 &lt;code>ctrl-d&lt;/code>，它就消失了。&lt;/p>
&lt;h2 id="创建窗口">创建窗口&lt;/h2>
&lt;p>tmux 中的窗口可以被比作创建新的虚拟桌面。如果你曾经使用过一个主要的 Linux 桌面环境（KDE，Gnome）或 Mac，希望你会发现这个比喻很有帮助。&lt;/p>
&lt;p>创建新窗口就像输入 &lt;code>C-b c&lt;/code>（最后一次：就是 ctrl 和 b 一次，然后是 c）一样简单。新的窗口将在 tmux 的状态栏中呈现给你。&lt;/p>
&lt;p>&lt;img src="https://netholes.github.io/img/tmux/tmux-4.png" alt="">&lt;/p>
&lt;p>现在你可以在你的新窗口中随意划分窗格，或者不做。这由你决定。&lt;/p>
&lt;p>要切换到上一个窗口（根据你状态栏中的顺序），使用 &lt;code>C-b p&lt;/code>，要切换到下一个窗口，使用 &lt;code>C-b n&lt;/code>。
如果你已经创建了许多窗口，你会发现直接输入一个窗口的编号（状态栏会告诉你哪个窗口有哪个编号）是很有用的，只要使用 &lt;code>C-b &amp;lt;编号&amp;gt;&lt;/code>，其中 &lt;code>&amp;lt;编号&amp;gt;&lt;/code> 是状态栏中窗口名称前面的数字。&lt;/p>
&lt;h2 id="会话处理">会话处理&lt;/h2>
&lt;p>如果你完成了你的会话，你可以通过简单地退出里面的所有面板来摆脱它，或者你可以将会话保留在后台以便以后再使用。&lt;/p>
&lt;p>可以使用 &lt;code>C-b d&lt;/code> 分离当前对话。你也可以用 &lt;code>C-b D&lt;/code> 来让 tmux 给你选择，选择从哪个会话中分离出来。脱离一个会话将使你在该会话中所做的一切在后台运行。你可以在以后的某个时间点回到这个会话中。&lt;/p>
&lt;p>要重新连接到一个会话并继续你离开的地方，你需要弄清楚你想先连接到哪个会话，通过使用以下方法列出当前正在运行的会话：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">tmux ls
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这将给你一个所有正在运行的会话的列表，在我们的例子中，它应该是这样的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">0: 2 windows (created Mon May 8 19:41:37 2023)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>要连接到这个会话，你需要再次启动 tmux，但这次要告诉它要连接到哪个会话：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">tmux attach -t &lt;span class="m">0&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>-t 0&lt;/code> 是告诉 tmux 要附加到哪个会话的参数。&lt;code>0&lt;/code> 是你的 &lt;code>tmux ls&lt;/code> 输出的第一部分。&lt;/p>
&lt;p>如果你喜欢给你的会话起一个更有意义的名字（而不是以 0 开头的数字），你可以用以下方式创建你的下一个会话：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">tmux new -s database
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这将创建一个名称为 &amp;ldquo;database&amp;rdquo; 新的会话。&lt;/p>
&lt;p>你也可以重新命名你现有的会话：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">tmux rename-session -t &lt;span class="m">0&lt;/span> database
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>下次你附加到该会话时，只需使用 &lt;code>tmux attach -t database&lt;/code> 。如果你同时使用多个会话，这可能是一个很重要的功能。&lt;/p>
&lt;p>就这样了! 恭喜你，你刚刚完成了你的第一个 tmux 会话，并且亲自使用了它的窗口和会话管理功能呢个。tmux 还有更多功能，但你刚刚学到的东西应该是未来开始使用 tmux 的一切。&lt;/p>
&lt;h2 id="为什么使用">为什么使用&lt;/h2>
&lt;p>我经常得到的一个答复是：&amp;ldquo;很好，我明白了。但我为什么要使用 tmux 和它奇怪的组合键，而不是直接使用 iTerm2 呢？&amp;rdquo;&lt;/p>
&lt;p>你是对的，当它只是基本的窗口管理时，Mac 的 &lt;a href="https://iterm2.com/">iTerm&lt;/a> 也支持标签和窗格。对于 Linux 来说，有 &lt;a href="https://gnome-terminator.org/">Terminator&lt;/a>。那么，在这个时代，为什么会有人觉得有必要去学习一些古老的技术呢？&lt;/p>
&lt;p>好吧，很明显，这是一种吹牛的权利。如果这还不能说服你，还有一些实际的理由，我为什么喜欢 tmux 而不是 iTerm 等：&lt;/p>
&lt;ol>
&lt;li>会话处理：脱离和附加到会话有助于我进行上下文切换和远程工作。&lt;/li>
&lt;li>平台独立性： 我可以在我的 Macbook、我的 Linux 笔记本、服务器、Raspberry Pi 上使用 tmux，你说了算。&lt;/li>
&lt;li>可定制：我有很多方法可以定制我的 tmux 环境的外观和行为。而且我可以用一个简单的 dotfile 在不同的平台上进行同步。&lt;/li>
&lt;/ol>
&lt;h2 id="后续">后续&lt;/h2>
&lt;p>如果你好奇地想了解 tmux 还能做什么，这是一件好事。幸运的是，大部分的东西都很容易发现。只要键入 &lt;code>C-b ?&lt;/code> 就可以看到所有可用命令的列表，并开始实验。&lt;/p>
&lt;p>我自己经常使用的一些命令是：&lt;/p>
&lt;ol>
&lt;li>&lt;code>C-b z&lt;/code>：使一个面板变成全屏。再按一次 &lt;code>C-b z&lt;/code>，就可以把它缩回到以前的大小。&lt;/li>
&lt;li>&lt;code>C-b C-&amp;lt;方向键&amp;gt;&lt;/code>:按&amp;lt;箭头键&amp;gt;的方向调整窗格大小（脚注 4）。&lt;/li>
&lt;li>&lt;code>C-b ,&lt;/code>:给当前窗口重命名。&lt;/li>
&lt;/ol>
&lt;p>除此之外，还有很多资源可以帮助你进一步了解 tmux。像我这样的人在博客上写他们的 tmux 经验，并分享他们的发现。你可以在 Github 上的 dotfiles 资源库中找到人们分享他们的 tmux 配置。甚至还有 Brian Hogan 写的一本 &lt;a href="https://pragprog.com/search/?q=tmux">专门介绍 tmux 的书&lt;/a>。&lt;/p>
&lt;p>现在，最好是自己去发现一些东西。实验一下，糊弄一下，也许试着用 tmux 来做你的日常工作。它需要一段时间来适应，当你开始的时候，你可能会觉得很慢。我鼓励你继续使用它。感受一下它的功能，很快你就会发现，你使用终端的工作将是纯粹的快乐和令人耳目一新的快速。&lt;/p>
&lt;p>如果你对定制你的 tmux 体验感兴趣，我建议你阅读我的&lt;a href="https://www.hamvocke.com/blog/a-guide-to-customizing-your-tmux-conf/">定制 tmux.conf 指南&lt;/a>。&lt;/p>
&lt;h2 id="脚注">脚注&lt;/h2>
&lt;ol>
&lt;li>如果你是 Linux 背景的人，你可能对窗口管理器的概念很熟悉，比如 &lt;a href="http://openbox.org/wiki/Main_Page">Openbox&lt;/a>、或 &lt;a href="https://i3wm.org/">i3&lt;/a> &lt;a href="https://awesomewm.org/apidoc/?redirected_from_wiki=1">awesome&lt;/a>。&lt;/li>
&lt;li>tmux 是基于客户端-服务器架构的。虽然这很少有关系，但对了解东西的工作原理有帮助。tmux 服务器会跟踪所有正在运行的会话。你将只在 tmux 客户端工作，创建新的会话或连接到现有的会话。&lt;/li>
&lt;li>也可以是 &lt;code>M-&lt;/code>，这只对 &lt;code>Meta&lt;/code> 键（即大多数键盘上的 Alt）来说是一样的。&lt;/li>
&lt;li>这是个有趣的问题。你的前缀需要 ctrl，也需要你的命令键。我发现最简单的方法是在前缀键之后只释放 b 键，并在反复敲击方向键时一直按着 ctrl。实验一下，找点感觉。&lt;/li>
&lt;/ol></description></item></channel></rss>