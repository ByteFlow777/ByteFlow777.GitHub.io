<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Leon Li's blog</title><link>https://ileonli.github.io/post/</link><description>Recent content in Posts on Leon Li's blog</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Thu, 05 Dec 2024 21:28:06 +0800</lastBuildDate><atom:link href="https://ileonli.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>网络字节序</title><link>https://ileonli.github.io/post/system-programming/network-byte-order/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/post/system-programming/network-byte-order/</guid><description>&lt;h1 id="网络字节序">网络字节序&lt;/h1>
&lt;h2 id="大小端">大小端&lt;/h2>
&lt;p>不同架构的 CPU 中，4 字节整数 1 在内存中存储的方式是不同的。&lt;/p>
&lt;ul>
&lt;li>大端序（big endian）：&lt;strong>最高位&lt;/strong>有效字节存储在&lt;strong>低内存地址&lt;/strong>，而&lt;strong>最低位&lt;/strong>有效字节存储在&lt;strong>高内存地址&lt;/strong>。&lt;/li>
&lt;li>小端序（little endian）：&lt;strong>最高位&lt;/strong>有效字节存储在&lt;strong>高内存地址&lt;/strong>，而&lt;strong>最低位&lt;/strong>有效字节存储在&lt;strong>低内存地址&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>对于一个 4 字节整数 &lt;code>0x01020304&lt;/code>，大小端序存储方式分别如下：&lt;/p>
&lt;pre tabindex="0">&lt;code>地址: 0 1 2 3 （大端序保存）
 01 02 03 04
&lt;/code>&lt;/pre>&lt;pre tabindex="0">&lt;code>地址: 0 1 2 3 （小端序保存）
 04 03 02 01
&lt;/code>&lt;/pre>&lt;hr>
&lt;p>可以使用下边的方法判断机器的字节序：&lt;/p>
&lt;ol>
&lt;li>通过 &lt;code>endian.h&lt;/code> 提供的 &lt;code>BYTE_ORDER&lt;/code> 宏。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;endian.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">big_endian&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> BYTE_ORDER &lt;span style="color:#f92672">==&lt;/span> BIG_ENDIAN;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">little_endian&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> BYTE_ORDER &lt;span style="color:#f92672">==&lt;/span> LITTLE_ENDIAN;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>将 &lt;code>uint16_t&lt;/code> 类型的数字转为 &lt;code>char *&lt;/code>，通过高字节和低字节进行判断。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">big_endian&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint16_t&lt;/span> val &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0102&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ((&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>) (&lt;span style="color:#f92672">&amp;amp;&lt;/span>val))[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0x01&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">little_endian&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint16_t&lt;/span> val &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0102&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ((&lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>) (&lt;span style="color:#f92672">&amp;amp;&lt;/span>val))[&lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0x01&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>和方法 2 类似，利用的是 &lt;code>union&lt;/code> 相同的内存位置存储不同的数据类型。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">union&lt;/span> endian {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint16_t&lt;/span> val;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">char&lt;/span> bytes[&lt;span style="color:#ae81ff">2&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">big_endian&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">union&lt;/span> endian en{};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> en.val &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0102&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> en.bytes[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0x01&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">little_endian&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">union&lt;/span> endian en{};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> en.val &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0x0102&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> en.bytes[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0x02&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;p>为什么有两种不同的字节序？&lt;/p></description></item><item><title>I/O 多路复用</title><link>https://ileonli.github.io/post/system-programming/multiplexing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/post/system-programming/multiplexing/</guid><description>&lt;h1 id="io-多路复用">I/O 多路复用&lt;/h1>
&lt;p>I/O 复用可以使程序同时监听多个文件描述符。&lt;/p>
&lt;h2 id="select">select&lt;/h2>
&lt;p>&lt;code>select&lt;/code> 函数允许程序监视多个文件描述符，直到一个或多个文件描述符“准备好”进行某类 I/O 操作。&lt;/p>
&lt;p>&lt;code>select&lt;/code> 成功时返回就绪文件描述符的总数，如果超时时间内没有任何文件描述符就绪，则返回 0。失败时返回 -1 并设置 &lt;code>errno&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/select.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">select&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> nfds, fd_set&lt;span style="color:#f92672">*&lt;/span> readfds,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fd_set&lt;span style="color:#f92672">*&lt;/span> writefds,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fd_set&lt;span style="color:#f92672">*&lt;/span> exceptfds,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> timeval &lt;span style="color:#f92672">*&lt;/span> timeout);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="函数参数">函数参数&lt;/h3>
&lt;p>&lt;code>nfds&lt;/code>：指定被监听的文件描述符的总数。这个参数应该被设置为三个集合中编号最高的文件描述符，再加 1，因为文件描述符是从 0 开始的。&lt;/p>
&lt;hr>
&lt;p>&lt;code>readfds&lt;/code>、&lt;code>writefds&lt;/code> 和 &lt;code>exceptfds&lt;/code>：分别指向可读、可写和异常事件对应的文件描述符集合。如果没有文件描述符要监听，则可以将对应的 &lt;code>fd_set&lt;/code> 参数设为 &lt;code>NULL&lt;/code>。&lt;/p>
&lt;p>&lt;code>fd_set&lt;/code> 结构体仅包含一个数组，数组每一位标记一个文件描述符，最大容纳长度由 &lt;code>FD_SETSIZE&lt;/code> 指定。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* fd_set for select and pselect. */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* XPG4.2 requires this member name. Otherwise avoid the name
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> from the global namespace. */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#ifdef __USE_XOPEN
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> __fd_mask fds_bits[__FD_SETSIZE &lt;span style="color:#f92672">/&lt;/span> __NFDBITS];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># define __FDS_BITS(set) ((set)-&amp;gt;fds_bits)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#else
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> __fd_mask __fds_bits[__FD_SETSIZE &lt;span style="color:#f92672">/&lt;/span> __NFDBITS];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># define __FDS_BITS(set) ((set)-&amp;gt;__fds_bits)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> } fd_set;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为方便对此结构体进行操作，提供了以下几个宏函数对其进行操作，宏函数如下：&lt;/p></description></item><item><title>Reactor 模型</title><link>https://ileonli.github.io/post/system-programming/reactor-pattern/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/post/system-programming/reactor-pattern/</guid><description>&lt;h1 id="reactor-模型">Reactor 模型&lt;/h1>
&lt;p>Reactor 模型中定义的三种角色：&lt;/p>
&lt;ul>
&lt;li>Reactor：负责监听和分配事件，将I/O事件分派给对应的 Handler。新的事件包含连接建立就绪、读就绪、写就绪等。&lt;/li>
&lt;li>Acceptor：处理客户端新连接，并分派请求到处理器链中。&lt;/li>
&lt;li>Handler：将自身与事件绑定，执行非阻塞读/写任务，完成channel的读入，完成处理业务逻辑后，负责将结果写出channel。可用资源池来管理。&lt;/li>
&lt;/ul>
&lt;h2 id="one-loop-per-thread">One Loop Per Thread&lt;/h2>
&lt;h2 id="参考文献">参考文献&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf" target="_blank" rel="noopener noreferrer">https://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener noreferrer">https://gee.cs.oswego.edu/dl/cpjslides/nio.pdf&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>套接字（socket）</title><link>https://ileonli.github.io/post/system-programming/sockets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/post/system-programming/sockets/</guid><description>&lt;h1 id="套接字socket">套接字（socket）&lt;/h1>
&lt;p>&lt;strong>网络编程&lt;/strong>即编写程序使两台联网的计算机相互交换数据。计算机之间会通过网线、路由器和交换机等设备连接在一起，我们无需直接操控硬件，而使用操作系统提供的&lt;strong>套接字（socket）&lt;/strong>。&lt;/p>
&lt;h2 id="基本函数">基本函数&lt;/h2>
&lt;h3 id="socket">socket&lt;/h3>
&lt;p>为了使用套接字，可以使用 &lt;code>socket&lt;/code> 函数，创建用于通信的端点（endpoint）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/socket.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">socket&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> domain, &lt;span style="color:#66d9ef">int&lt;/span> type, &lt;span style="color:#66d9ef">int&lt;/span> protocol);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>成功时&lt;/strong>会返回文件描述符，&lt;strong>失败时&lt;/strong>会返回 -1。&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://man7.org/linux/man-pages/man2/socket.2.html" target="_blank" rel="noopener noreferrer">https://man7.org/linux/man-pages/man2/socket.2.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h3 id="bind">bind&lt;/h3>
&lt;p>当使用 &lt;code>socket&lt;/code> 函数创建套接字后，会存在于名称空间（地址族）中，但没有为其分配地址。&lt;code>bind&lt;/code> 函数将 &lt;code>addr&lt;/code> 指定的地址分配给文件描述符 &lt;code>sockfd&lt;/code> 引用的套接字。&lt;/p>
&lt;p>服务器可以不先调用 &lt;code>bind()&lt;/code> 而直接调用 &lt;code>listen()&lt;/code>，此时会为该 &lt;code>socket&lt;/code> 分配一个 &lt;strong>&lt;code>INADDR_ANY&lt;/code> IP 地址&lt;/strong>（0.0.0.0）和&lt;strong>临时端口&lt;/strong>（可通过 &lt;code>getsockname()&lt;/code> 获取 &lt;code>socket&lt;/code> 的地址）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/socket.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">bind&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> sockfd, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> sockaddr &lt;span style="color:#f92672">*&lt;/span>addr,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">socklen_t&lt;/span> addrlen);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>成功时&lt;/strong>返回 0，&lt;strong>失败时&lt;/strong>返回 -1。&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://man7.org/linux/man-pages/man2/bind.2.html" target="_blank" rel="noopener noreferrer">https://man7.org/linux/man-pages/man2/bind.2.html&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h3 id="listen">listen&lt;/h3>
&lt;p>&lt;code>listen&lt;/code> 函数将文件描述符引用的 &lt;code>socket&lt;/code> 标记为被动，该 &lt;code>socket&lt;/code> 会被用来接受来自其它主动 &lt;code>socket&lt;/code> 的连接。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/socket.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">listen&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> sockfd, &lt;span style="color:#66d9ef">int&lt;/span> backlog);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>成功时&lt;/strong>返回 0，&lt;strong>失败时&lt;/strong>返回 -1。&lt;/p>
&lt;blockquote>
&lt;p>&lt;a href="https://man7.org/linux/man-pages/man2/listen.2.html" target="_blank" rel="noopener noreferrer">https://man7.org/linux/man-pages/man2/listen.2.html&lt;/a>&lt;/p></description></item><item><title>echo 服务器</title><link>https://ileonli.github.io/post/system-programming/echo-server/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/post/system-programming/echo-server/</guid><description>&lt;h1 id="echo-服务器">echo 服务器&lt;/h1>
&lt;h2 id="辅助函数">辅助函数&lt;/h2>
&lt;p>&lt;code>panic&lt;/code> 函数用于错误处理，当发生错误时，调用 &lt;code>exit&lt;/code> 函数直接退出程序。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">panic&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> &lt;span style="color:#f92672">*&lt;/span>format, ...) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> va_list args;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">va_start&lt;/span>(args, format);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">vfprintf&lt;/span>(stderr, format, args);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">va_end&lt;/span>(args);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">exit&lt;/span>(EXIT_FAILURE);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>readn&lt;/code> 和 &lt;code>writen&lt;/code> 函数分别用于从 &lt;code>fd&lt;/code> 处读和写 &lt;code>n&lt;/code> 个字节。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">ssize_t&lt;/span> &lt;span style="color:#a6e22e">readn&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> fd, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buf, &lt;span style="color:#66d9ef">size_t&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">ssize_t&lt;/span> nread;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (nleft &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ((nread &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">read&lt;/span>(fd, buf, nleft)) &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (nleft &lt;span style="color:#f92672">==&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">// error, return -1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>; &lt;span style="color:#75715e">// error, return amount read so far
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (nleft &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ((nread &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">read&lt;/span>(fd, buf, nleft)) &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (nleft &lt;span style="color:#f92672">==&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">// error, return -1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nleft &lt;span style="color:#f92672">-=&lt;/span> nread;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buf &lt;span style="color:#f92672">+=&lt;/span> nread;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> n &lt;span style="color:#f92672">-&lt;/span> nleft;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">ssize_t&lt;/span> &lt;span style="color:#a6e22e">writen&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> fd, &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>buf, &lt;span style="color:#66d9ef">size_t&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">size_t&lt;/span> nleft &lt;span style="color:#f92672">=&lt;/span> n;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">ssize_t&lt;/span> nwritten;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (nleft &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> ((nwritten &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">write&lt;/span>(fd, buf, nleft)) &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (nleft &lt;span style="color:#f92672">==&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (nwritten &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nleft &lt;span style="color:#f92672">-=&lt;/span> nwritten;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> buf &lt;span style="color:#f92672">+=&lt;/span> nwritten;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> n &lt;span style="color:#f92672">-&lt;/span> nleft;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>read_line&lt;/code> 函数用于从用户处读取一行输入。&lt;/p></description></item><item><title>Java 动态代理</title><link>https://ileonli.github.io/post/java/dynamic-proxy/</link><pubDate>Thu, 05 Dec 2024 21:28:06 +0800</pubDate><guid>https://ileonli.github.io/post/java/dynamic-proxy/</guid><description>&lt;h1 id="java-动态代理">Java 动态代理&lt;/h1>
&lt;p>在 Java 动态代理机制中，&lt;code>InvocationHandler&lt;/code> 接口和 &lt;code>Proxy&lt;/code> 类是核心。&lt;/p>
&lt;h2 id="proxy">Proxy&lt;/h2>
&lt;p>&lt;code>Proxy&lt;/code> 类主要使用 &lt;code>newProxyInstance()&lt;/code> 静态方法生成代理对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> Object &lt;span style="color:#a6e22e">newProxyInstance&lt;/span>(ClassLoader loader,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;[]&lt;/span> interfaces,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InvocationHandler h) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该方法主要有三个参数：&lt;/p>
&lt;ol>
&lt;li>&lt;code>loader&lt;/code>：定义代理类的类加载器。&lt;/li>
&lt;li>&lt;code>interfaces&lt;/code>：代理类要实现的接口列表。&lt;/li>
&lt;li>&lt;code>h&lt;/code>：用于分发方法调用的调用处理器。&lt;/li>
&lt;/ol>
&lt;h2 id="invocationhandler">InvocationHandler&lt;/h2>
&lt;p>当动态代理对象调用一个方法时，此方法的调用就会被转发到实现 &lt;code>InvocationHandler&lt;/code> 接口类的 &lt;code>invoke&lt;/code> 方法来调用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">InvocationHandler&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Object &lt;span style="color:#a6e22e">invoke&lt;/span>(Object proxy, Method method, Object&lt;span style="color:#f92672">[]&lt;/span> args)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throws&lt;/span> Throwable;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该方法主要有三个参数：&lt;/p>
&lt;ol>
&lt;li>&lt;code>proxy&lt;/code>：动态生成的代理类的实例。&lt;/li>
&lt;li>&lt;code>method&lt;/code>：代理类对象调用的方法。&lt;/li>
&lt;li>&lt;code>args&lt;/code>：调用 &lt;code>method&lt;/code> 方法的参数。&lt;/li>
&lt;/ol>
&lt;p>通过 &lt;code>Proxy&lt;/code> 类的 &lt;code>newProxyInstance()&lt;/code> 创建的代理对象在调用方法的时候，实际会调用到实现 &lt;code>InvocationHandler&lt;/code> 接口的类的 &lt;code>invoke()&lt;/code> 方法。&lt;/p>
&lt;h2 id="具体步骤">具体步骤&lt;/h2>
&lt;p>&lt;code>TargetClass&lt;/code> 类继承自 &lt;code>InterfaceA&lt;/code> 和 &lt;code>InterfaceB&lt;/code> 接口。&lt;/p></description></item><item><title>Skip List</title><link>https://ileonli.github.io/post/skiplist/</link><pubDate>Wed, 18 Sep 2024 21:09:06 +0800</pubDate><guid>https://ileonli.github.io/post/skiplist/</guid><description>&lt;h1 id="skip-list">Skip List&lt;/h1>
&lt;p>在讨论跳表前，我们先回顾一下链表（LinkedList），链表有以下优点和缺点：&lt;/p>
&lt;ul>
&lt;li>链表插入和删除给定的节点，只需要更改指针的指向位置即可，因此空间复杂度为 O(1)。&lt;/li>
&lt;li>对于搜索操作，由于链表是无序的（无法使用二分查找），只能从头部搜索到尾部，空间复杂度为 O(n)。&lt;/li>
&lt;/ul>
&lt;p>为了加快链表查找过程，设计了跳表，跳表可以看作&lt;strong>可二分查找的链表&lt;/strong>。&lt;/p>
&lt;hr>
&lt;p>跳表是一种可以替代平衡树的数据结构。跳表使用概率平衡，而不是严格的平衡维护，因此，跳表中插入和删除的算法比平衡树中的等价算法要简单得多，速度也显著更快。通过在链表上添加索引，达到优化查询的目的。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>概率算法（Probabilistic Algorithm）&lt;/strong>：算法的执行过程中使用随机数来影响决策或流程的算法。这意味着即使对于相同的输入，算法每次运行的结果或执行路径也可能不同。&lt;/p>
&lt;/blockquote>
&lt;p>每个元素在跳表中由一个节点表示（如下图所示），节点是以 &lt;code>key&lt;/code> 的顺序有序排列的。且每个节点都有一个高度（height）或级别（level），表示该节点拥有的前向指针的数量。&lt;/p>
&lt;p>当插入节点时，会随机生成节点的高度，而不需要考虑当前跳表中的元素数量。&lt;/p>
&lt;p>&lt;img src="https://ileonli.github.io/images/skiplist/skiplist.png" alt="">&lt;/p>
&lt;p>对于上图中的链表，我们可以发现下边的规律：&lt;/p>
&lt;ul>
&lt;li>第 0 层：这是完整的链表，包含所有按顺序排列的元素。&lt;/li>
&lt;li>第 1 层：这一层包含第 0 层中大约一半的元素。通过从第 0 层中随机选择大约一半的节点，并将它们链接到第 1 层。&lt;/li>
&lt;li>第 2 层：这一层包含第 1 层中大约一半的元素，意味着它包含第 0 层总元素数的 1/4 左右。&lt;/li>
&lt;li>第 3 层：这一层包含第 2 层中大约一半的元素，大约是第 0 层总元素数的 1/8，以此类推。&lt;/li>
&lt;/ul>
&lt;h2 id="search">Search&lt;/h2>
&lt;blockquote>
&lt;p>在跳表上插入的元素需要使用比较算法比较 &lt;code>key&lt;/code> 的大小。为了处理尾部节点，设定 &lt;code>null&lt;/code> 比任何 &lt;code>key&lt;/code> 都大&lt;/p>
&lt;/blockquote>
&lt;p>在跳表上进行&lt;strong>查找操作&lt;/strong>时，我们可以利用上述的规律，每次将数据分为两个区间，在数据所在的区级上继续向下层进行查询，直到查找到第 0 层：&lt;/p>
&lt;p>&lt;img src="https://ileonli.github.io/images/skiplist/search.jpg" alt="">&lt;/p>
&lt;p>&lt;img src="https://ileonli.github.io/images/skiplist/search-code.png" alt="">&lt;/p>
&lt;h2 id="insert">Insert&lt;/h2>
&lt;p>&lt;strong>插入操作&lt;/strong>需要想找到要插入位置的前一个节点，把新节点放入在后边即可。使用 &lt;code>update&lt;/code> 数组记录存储了每一层中小于待插入键的最后一个节点。&lt;/p>
&lt;p>我们使用 &lt;code>height = randomLevel()&lt;/code> 生成该节点的高度：&lt;/p>
&lt;ul>
&lt;li>如果 &lt;code>height&lt;/code> 高于当前跳表，我们需要把高于的部分的指向尾节点（null）。为方便操作，先把 &lt;code>update[i]&lt;/code> 指向 &lt;code>header&lt;/code>，后续使用 &lt;code>update[i].forward[i]&lt;/code> 获取尾节点。&lt;/li>
&lt;li>如果 &lt;code>height&lt;/code> 低于当前跳表，我们把 &lt;code>update&lt;/code> 中高度小与等于 &lt;code>height&lt;/code> 的节点的 &lt;code>forward&lt;/code> 进行更新。左边索引指向当前插入的节点，当前节点指向右边索引。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://ileonli.github.io/images/skiplist/insert.jpg" alt="">&lt;/p></description></item><item><title>Java JDBC</title><link>https://ileonli.github.io/post/java/jdbc/</link><pubDate>Thu, 08 Aug 2024 20:32:01 +0800</pubDate><guid>https://ileonli.github.io/post/java/jdbc/</guid><description>&lt;h1 id="java-jdbc">Java JDBC&lt;/h1>
&lt;blockquote>
&lt;p>本教程使用 MySQL 数据库。&lt;/p>
&lt;p>主要参考：https://docs.oracle.com/javase/tutorial/jdbc/basics/index.html&lt;/p>
&lt;/blockquote>
&lt;h2 id="建立连接">建立连接&lt;/h2>
&lt;p>数据源可以是数据库管理系统 (DBMS)、传统文件系统或其他带有相应 JDBC 驱动的数据源。通常，JDBC 使用以下两种类之一来连接目标数据源：&lt;/p>
&lt;ul>
&lt;li>&lt;code>DriverManager&lt;/code>：用于将应用程序连接到通过数据库 URL 指定的数据源。当此类首次尝试建立连接时，它会自动加载类路径中找到的任何 JDBC 4.0 驱动程序。必须手动加载任何 4.0 版本之前的 JDBC 驱动程序。&lt;/li>
&lt;li>&lt;code>DataSource&lt;/code>：相比于 &lt;code>DriverManager&lt;/code>，更推荐使用此接口，因为它允许应用程序对底层数据源的细节保持透明。&lt;code>DataSource&lt;/code> 对象的属性被设置为表示特定的数据源。&lt;/li>
&lt;/ul>
&lt;h3 id="使用-drivermanager-类">使用 &lt;code>DriverManager&lt;/code> 类&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>String url &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;jdbc:mysql://localhost:3306/db&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String username &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;root&amp;#34;&lt;/span>, password &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;0987654321&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Connection conn &lt;span style="color:#f92672">=&lt;/span> DriverManager.&lt;span style="color:#a6e22e">getConnection&lt;/span>(url, username, password);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="使用-jdbc-处理-sql-语句">使用 JDBC 处理 SQL 语句&lt;/h2>
&lt;p>新建一个 &lt;code>user&lt;/code> 表，如下图所示：&lt;/p>
&lt;p>&lt;img src="https://ileonli.github.io/images/JDBC/User.png" alt="">&lt;/p>
&lt;p>使用 &lt;code>conn&lt;/code> 对象创建 &lt;code>Statement&lt;/code>，使用 &lt;code>stmt&lt;/code> 执行 SQL 语句。&lt;/p>
&lt;p>&lt;code>ResultSet&lt;/code> 保存了执行 SQL 语句的结果，可以遍历保存的结果。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>String query &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;SELECT * FROM `user`;&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> (Statement stmt &lt;span style="color:#f92672">=&lt;/span> conn.&lt;span style="color:#a6e22e">createStatement&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ResultSet rs &lt;span style="color:#f92672">=&lt;/span> stmt.&lt;span style="color:#a6e22e">executeQuery&lt;/span>(query);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (rs.&lt;span style="color:#a6e22e">next&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> id &lt;span style="color:#f92672">=&lt;/span> rs.&lt;span style="color:#a6e22e">getInt&lt;/span>(1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String name &lt;span style="color:#f92672">=&lt;/span> rs.&lt;span style="color:#a6e22e">getString&lt;/span>(2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> age &lt;span style="color:#f92672">=&lt;/span> rs.&lt;span style="color:#a6e22e">getInt&lt;/span>(3);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String email &lt;span style="color:#f92672">=&lt;/span> rs.&lt;span style="color:#a6e22e">getString&lt;/span>(4);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;id: %d, name: %s, age: %d, email: %s.\n&amp;#34;&lt;/span>, id, name, age, email);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="使用-preparedstatements">使用 PreparedStatements&lt;/h2>
&lt;p>如果需要多次执行一个 &lt;code>Statement&lt;/code> 对象，使用 &lt;code>PreparedStatement&lt;/code> 对象可以减少执行时间。&lt;/p></description></item><item><title>Java 方法句柄（翻译）</title><link>https://ileonli.github.io/post/java/method-handles/</link><pubDate>Thu, 08 Aug 2024 20:32:01 +0800</pubDate><guid>https://ileonli.github.io/post/java/method-handles/</guid><description>&lt;h1 id="java-方法句柄翻译">Java 方法句柄（翻译）&lt;/h1>
&lt;blockquote>
&lt;p>翻译自：&lt;a href="https://dev.java/learn/introduction_to_method_handles/" target="_blank" rel="noopener noreferrer">https://dev.java/learn/introduction_to_method_handles/&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;h2 id="什么是方法句柄what-are-method-handles">什么是方法句柄（What are method handles）&lt;/h2>
&lt;p>方法句柄是一种用于查找和调用方法的低级机制。与反射一样，方法句柄也提供了调用方法、调用构造函数以及访问字段的手段。&lt;/p>
&lt;p>那么，方法句柄究竟什么是呢？它是对底层方法、构造函数或字段的可调用引用。方法句柄允许在一个简单的指向方法的引用之上进行一系列操作，这些操作包括插入或重新排列参数、转换返回值等。&lt;/p>
&lt;p>让我们深入探讨一下方法句柄能够提供什么功能以及我们如何有效地使用它们。&lt;/p>
&lt;h2 id="访问检查access-checking">访问检查（Access checking）&lt;/h2>
&lt;p>方法句柄的访问检查与反射的执行方式是不同的。&lt;strong>使用反射时&lt;/strong>，每次调用都会对调用者进行访问检查。&lt;strong>而对于方法句柄&lt;/strong>，访问检查只在方法句柄创建时进行。&lt;/p>
&lt;p>需要注意的是，如果在能够访问非公共成员的上下文中创建了方法句柄，那么当该方法句柄被传递到外部时，可以通过方法句柄访问非公共成员。&lt;/p>
&lt;p>因此，非公共成员可能会被不应有访问权限的代码访问。开发者有责任将此类方法句柄限制在其创建的上下文内。另外，可以直接使用合适的查找对象来创建具有访问限制的方法句柄。&lt;/p>
&lt;h2 id="方法句柄查找method-handle-lookup">方法句柄查找（Method handle lookup）&lt;/h2>
&lt;p>要创建方法句柄，我们首先需要创建一个 &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html" target="_blank" rel="noopener noreferrer">&lt;code>LookUp&lt;/code>&lt;/a> 对象，此为创建方法句柄的工厂。根据 &lt;code>Lookup&lt;/code> 对象本身或方法句柄的使用方式，我们可以决定是否需要限制其访问级别。&lt;/p>
&lt;p>例如，如果我们创建了一个指向私有方法的方法句柄，并且该方法句柄可以从外部访问，那么该私有方法也就可以被外部访问（译者注：现在，外部代码可以直接调用原本受保护的私有方法，从而破坏了方法的私有性）。&lt;/p>
&lt;p>通常我们希望避免这种情况。&lt;strong>一种办法&lt;/strong>是将 &lt;code>Lookup&lt;/code> 对象和方法句柄设为私有。&lt;strong>另一种方法&lt;/strong>是使用 &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.html#publicLookup%28%29" target="_blank" rel="noopener noreferrer">&lt;code>MethodHandles.publicLookup&lt;/code>&lt;/a> 方法创建 &lt;code>Lookup&lt;/code> 对象，这样它只能查找公共类的公共成员（译者注：未导出的包，或受保护或私有的类和成员不会被搜索到）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>MethodHandles.&lt;span style="color:#a6e22e">Lookup&lt;/span> publicLookup &lt;span style="color:#f92672">=&lt;/span> MethodHandles.&lt;span style="color:#a6e22e">publicLookup&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果我们打算将 &lt;code>Lookup&lt;/code> 对象和方法句柄设为私有，那么访问私有和受保护的成员是安全的（外部无法访问私有的方法句柄）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>MethodHandles.&lt;span style="color:#a6e22e">Lookup&lt;/span> lookup &lt;span style="color:#f92672">=&lt;/span> MethodHandles.&lt;span style="color:#a6e22e">lookup&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="方法类型method-type">方法类型（Method type）&lt;/h2>
&lt;p>要查找方法句柄，我们还需要提供方法或字段的类型信息。方法的类型信息通过 &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodType.html" target="_blank" rel="noopener noreferrer">&lt;code>MethodType&lt;/code>&lt;/a> 类表示。为了实例化一个 &lt;code>MethodType&lt;/code> 对象，需要提供函数返回类型作为第一个形参，后跟函数所有实参类型:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>MethodType methodType &lt;span style="color:#f92672">=&lt;/span> MethodType.&lt;span style="color:#a6e22e">methodType&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>.&lt;span style="color:#a6e22e">class&lt;/span> &lt;span style="color:#75715e">/* the method returns integer */&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String.&lt;span style="color:#a6e22e">class&lt;/span> &lt;span style="color:#75715e">/* and accepts a single String argument*/&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有了 &lt;code>Lookup&lt;/code> 和 &lt;code>MethodType&lt;/code> 实例后，我们就可以查找方法句柄了。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>对于&lt;strong>实例方法&lt;/strong>，我们应该使用 &lt;a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#findVirtual%28java.lang.Class,java.lang.String,java.lang.invoke.MethodType%29" target="_blank" rel="noopener noreferrer">&lt;code>Lookup.findVirtual&lt;/code>&lt;/a>。&lt;/p></description></item><item><title>网络地址族</title><link>https://ileonli.github.io/post/system-programming/address-families/</link><pubDate>Thu, 25 Jul 2024 22:59:06 +0800</pubDate><guid>https://ileonli.github.io/post/system-programming/address-families/</guid><description>&lt;h1 id="网络地址族">网络地址族&lt;/h1>
&lt;h2 id="网络地址">网络地址&lt;/h2>
&lt;p>网络地址分为 IPv4 和 IPv6，分别使用 &lt;code>sockaddr_in&lt;/code> 和 &lt;code>sockaddr_in6&lt;/code> 结构体表示。&lt;/p>
&lt;h3 id="sockaddr_in">sockaddr_in&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> sockaddr_in {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">sa_family_t&lt;/span> sin_family; &lt;span style="color:#75715e">/* address family: AF_INET */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">in_port_t&lt;/span> sin_port; &lt;span style="color:#75715e">/* port in network byte order */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> in_addr sin_addr; &lt;span style="color:#75715e">/* internet address */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* Pad to size of `struct sockaddr&amp;#39;. */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span> sin_zero[&lt;span style="color:#ae81ff">8&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* Internet address */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> in_addr {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint32_t&lt;/span> s_addr; &lt;span style="color:#75715e">/* address in network byte order */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>sin_family&lt;/code>：在 IPv4 中设为 &lt;code>AF_INET&lt;/code>。&lt;/li>
&lt;li>&lt;code>sin_port&lt;/code>：&lt;strong>网络字节序&lt;/strong>保存的端口（0～65535）。&lt;/li>
&lt;li>&lt;code>sin_addr&lt;/code>：&lt;strong>网络字节序&lt;/strong>保存的 32 位 IP 地址信息。&lt;/li>
&lt;li>&lt;code>sin_zero&lt;/code>：使 &lt;code>sockaddr_in&lt;/code> 和 &lt;code>sockaddr&lt;/code> 结构体大小保持一致而插入的填充位，需手动设为 0。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;a href="https://man7.org/linux/man-pages/man7/ip.7.html" target="_blank" rel="noopener noreferrer">https://man7.org/linux/man-pages/man7/ip.7.html&lt;/a>&lt;/p></description></item><item><title>阻塞与非阻塞 I/O 和 epoll（翻译）</title><link>https://ileonli.github.io/post/system-programming/block-and-nonblock-io/</link><pubDate>Thu, 25 Jul 2024 22:59:06 +0800</pubDate><guid>https://ileonli.github.io/post/system-programming/block-and-nonblock-io/</guid><description>&lt;h1 id="阻塞与非阻塞-io-和-epoll翻译">阻塞与非阻塞 I/O 和 epoll（翻译）&lt;/h1>
&lt;blockquote>
&lt;p>原文：https://eklitzke.org/blocking-io-nonblocking-io-and-epoll&lt;/p>
&lt;/blockquote>
&lt;p>在这篇文章中，我想解释使用非阻塞 I/O 时会发生什么。我特别想说明的是:&lt;/p>
&lt;ol>
&lt;li>使用 &lt;code>fcntl&lt;/code> 函数设置文件描述符的 &lt;code>O_NONBLOCK&lt;/code> 时的语义。&lt;/li>
&lt;li>非阻塞（nonblocking） I/O 与异步（asynchronous） I/O 的区别。&lt;/li>
&lt;li>为什么非阻塞 I/O 经常与诸如 &lt;code>select&lt;/code>、&lt;code>epoll&lt;/code> 和 &lt;code>kqueue&lt;/code> 等 I/O 多路复用器一起使用。&lt;/li>
&lt;li>非阻塞模式如何与 &lt;code>epoll&lt;/code> 中的边缘触发轮询交互。&lt;/li>
&lt;/ol>
&lt;h2 id="阻塞模式">阻塞模式&lt;/h2>
&lt;p>默认情况下，Unix 系统所有的文件描述符都以“阻塞模式”启动。这意味着像 &lt;code>read&lt;/code>、&lt;code>write&lt;/code> 或 &lt;code>connect&lt;/code> 这样的 I/O 系统调用可能会阻塞。一个很容易理解的方法是当你从一个普通的基于 TTY 的程序中的 &lt;code>stdin&lt;/code> 读取数据时会发生什么。如果你在 &lt;code>stdin&lt;/code>上调用 &lt;code>read&lt;/code>，那么你的程序将会阻塞，直到数据实际上可用，比如当用户实际上在键盘上键入字符时。具体来说，内核会将进程置于“睡眠”状态，直到 &lt;code>stdin&lt;/code> 上的数据可用。其他类型的文件描述符也是如此。例如，如果你尝试从 TCP 套接字中读取数据，那么 &lt;code>read&lt;/code> 调用将会阻塞，直到连接的另一端实际上发送数据。&lt;/p>
&lt;p>阻塞对于应该并发运行的程序来说是一个问题，因为被阻塞的进程会被挂起。解决这个问题有两种不同但互补的方式：&lt;/p>
&lt;ol>
&lt;li>非阻塞模式。&lt;/li>
&lt;li>I/O 多路复用系统调用，例如 &lt;code>select&lt;/code> 和 &lt;code>epoll&lt;/code>。&lt;/li>
&lt;/ol>
&lt;p>这两种解决方案经常一起使用，但它们是解决这个问题的独立策略，通常两者都会被使用。接下来我们将会看到它们之间的区别以及为什么它们通常都会被同时使用。&lt;/p>
&lt;h2 id="非阻塞模式">非阻塞模式&lt;/h2>
&lt;p>通过 &lt;code>fcntl&lt;/code> 函数在文件描述符的标志集中添加 &lt;code>O_NONBLOCK&lt;/code>，可以将文件描述符设置为“非阻塞模式”：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-C" data-lang="C">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* set O_NONBLOCK on fd */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> flags &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">fcntl&lt;/span>(fd, F_GETFL, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">fcntl&lt;/span>(fd, F_SETFL, flags &lt;span style="color:#f92672">|&lt;/span> O_NONBLOCK);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从这一点开始，文件描述符被视为非阻塞的。当发生这种情况时，像 &lt;code>read&lt;/code> 和 &lt;code>write&lt;/code> 这样的 I/O 系统调用将返回 -1，并且 &lt;code>errno&lt;/code> 将被设置为 &lt;code>EWOULDBLOCK&lt;/code>。&lt;/p></description></item><item><title>JVM Class 文件结构</title><link>https://ileonli.github.io/post/jvm/class-file/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/post/jvm/class-file/</guid><description>&lt;h1 id="class-文件结构">Class 文件结构&lt;/h1>
&lt;h2 id="前言">前言&lt;/h2>
&lt;p>任何一个 &lt;code>class&lt;/code> 文件都会对应一个类或接口，但并不是所有的类和接口都有对应的 &lt;code>class&lt;/code> 文件（如：动态生成的类）。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Main.java&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Main&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">InnerClass&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当执行 &lt;code>$javac Main.java&lt;/code> 命令后，会生成 &lt;strong>Main.class&lt;/strong> 和 &lt;strong>Main$InnerClass.class&lt;/strong> 两个 &lt;code>class&lt;/code> 文件。&lt;/p>
&lt;hr>
&lt;p>&lt;code>class&lt;/code> 文件由 8-bit 字节流组成。16-bit 和 32-bit 分别由 2 个和 4 个连续的 8-bit 组成。多字节数据使用大端（bit-endian）序保存。&lt;/p>
&lt;p>使用 &lt;code>u1&lt;/code>、&lt;code>u2&lt;/code> 和 &lt;code>u4&lt;/code> 分别表示 &lt;strong>1 字节&lt;/strong>、&lt;strong>2 字节&lt;/strong>和 &lt;strong>4 字节&lt;/strong>。&lt;/p>
&lt;h2 id="names">Names&lt;/h2>
&lt;h3 id="二进制类和接口名称">二进制类和接口名称&lt;/h3>
&lt;p>在 Java 虚拟机中，类和接口的名称使用&lt;strong>二进制名称&lt;/strong>格式表示。此格式与源代码中的类名表示略有不同。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>类名和接口名&lt;/strong>：二进制名称使用斜杠（&lt;code>/&lt;/code>）而不是点（&lt;code>.&lt;/code>）来分隔包和类的名称。例如，&lt;code>java.lang.Object&lt;/code> 的二进制名称是 &lt;code>java/lang/Object&lt;/code>。&lt;/li>
&lt;li>&lt;strong>内部类&lt;/strong>：对于内部类，二进制名称中使用美元符号（&lt;code>$&lt;/code>）来分隔外部类和内部类的名称。例如，&lt;code>OuterClass.InnerClass&lt;/code> 的二进制名称是 &lt;code>OuterClass$InnerClass&lt;/code>。&lt;/li>
&lt;/ul>
&lt;h3 id="二进制名称的使用场景">二进制名称的使用场景&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>字节码指令&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>在字节码指令中，类和接口的引用通常使用二进制名称。例如，&lt;code>L&lt;/code> 类型签名前缀后跟随二进制名称，如 &lt;code>Ljava/lang/Object;&lt;/code> 表示 &lt;code>java.lang.Object&lt;/code>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>类文件格式&lt;/strong>：&lt;/p></description></item><item><title>JVM 加载-链接-初始化</title><link>https://ileonli.github.io/post/jvm/loading-linking-initializing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/post/jvm/loading-linking-initializing/</guid><description>&lt;h1 id="jvm-加载-链接-初始化">JVM 加载-链接-初始化&lt;/h1>
&lt;h2 id="类加载过程">类加载过程&lt;/h2>
&lt;h3 id="加载loads">加载（loads）&lt;/h3>
&lt;p>加载（loads）是查找具有特定名称的类或接口类型的二进制表示，并从该二进制表示创建类或接口的过程。加载过程如下：&lt;/p>
&lt;ol>
&lt;li>通过一个类的全限定名来获取定义此类的二进制字节流。&lt;/li>
&lt;li>将这个字节流所代表的静态存储结构转化为方法区（Method Area）的运行时数据结构。&lt;/li>
&lt;li>在内存中生成一个代表这个类的 &lt;code>java.lang.Class&lt;/code> 对象，作为方法区这个类的各种数据的访问入口。&lt;/li>
&lt;/ol>
&lt;p>类加载链接的目的就是在 JVM 中创建相应的类结构&lt;/p>
&lt;p>启动类加载器之外，其他的类加载器都是 &lt;code>java.lang.ClassLoader&lt;/code> 的子类&lt;/p>
&lt;p>&lt;code>-verbose:class&lt;/code> 参数可用于打印类加载的先后顺序&lt;/p>
&lt;h3 id="链接links">链接（links）&lt;/h3>
&lt;p>链接（links）是获取类或接口，并将其组合到 Java 虚拟机的运行时状态以便执行的过程。&lt;/p>
&lt;h3 id="初始化initializes">初始化（initializes）&lt;/h3>
&lt;p>类或接口的初始化（initializes）包括执行类或接口初始化方法 &lt;code>&amp;lt;clinit&amp;gt;&lt;/code>。&lt;/p>
&lt;h2 id="类加载器class-loader">类加载器（class loader）&lt;/h2>
&lt;p>启动类加载器（bootstrap class loader）由 C++ 实现，&lt;/p>
&lt;p>除了启动类加载器之外，其它的类加载器都是 &lt;code>java.lang.ClassLoader&lt;/code> 的子类，因此有对应的 Java 对象。这些类加载器需要先由另一个类加载器，比如说启动类加载器，加载至 Java 虚拟机中，方能执行类加载。&lt;/p>
&lt;h2 id="双亲委派模型">双亲委派模型&lt;/h2>
&lt;h3 id="jdk-9-前">JDK 9 前&lt;/h3>
&lt;ul>
&lt;li>启动类加载器（Bootstrap Class Loader）：用于加载&lt;/li>
&lt;li>扩展类加载器（Extension Class Loader）:&lt;/li>
&lt;li>应用程序类加载器（Application Class Loader）:&lt;/li>
&lt;/ul>
&lt;p>可输出 &lt;code>BootstrapClassLoader&lt;/code> 可加载的类。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>URLClassPath bootstrapClassPath &lt;span style="color:#f92672">=&lt;/span> Launcher.&lt;span style="color:#a6e22e">getBootstrapClassPath&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (URL url : bootstrapClassPath.&lt;span style="color:#a6e22e">getURLs&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(url.&lt;span style="color:#a6e22e">getFile&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>${JAVA_HOME}/lib/resources.jar
${JAVA_HOME}/lib/rt.jar
${JAVA_HOME}/lib/sunrsasign.jar
${JAVA_HOME}/lib/jsse.jar
${JAVA_HOME}/lib/jce.jar
${JAVA_HOME}/lib/charsets.jar
${JAVA_HOME}/lib/jfr.jar
${JAVA_HOME}/classes
&lt;/code>&lt;/pre>&lt;h3 id="jdk-9-后">JDK 9 后&lt;/h3></description></item><item><title>JVM 常量池</title><link>https://ileonli.github.io/post/jvm/constant-pool/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/post/jvm/constant-pool/</guid><description>&lt;h1 id="jvm-常量池">JVM 常量池&lt;/h1>
&lt;p>常量池是一个表，所有的表项都有以下的格式。&lt;code>tag&lt;/code> 表示表项的类型，&lt;code>info&lt;/code> 用于表示 &lt;code>tag&lt;/code> 类型所需要存储的信息。&lt;/p>
&lt;pre tabindex="0">&lt;code>cp_info {
 u1 tag;
 u1 info[];
}
&lt;/code>&lt;/pre>&lt;p>常量池索引是从 1 开始的，不是直接从 0 开始。如果需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为 0 来表示。&lt;/p>
&lt;h2 id="为什么设计常量池">为什么设计常量池？&lt;/h2>
&lt;h3 id="复用">复用&lt;/h3>
&lt;p>常量池允许在类文件中共享常量数据。例如，字符串常量、类名、方法名和字段名等。可以避免了在类文件中多次存储相同的常量，从而减少类文件的大小。&lt;/p>
&lt;hr>
&lt;p>下边的代码，通过 &lt;code>$javac Main.java&lt;/code> 编译后，使用 &lt;code>$javap -v Main.class&lt;/code> 进行反编译。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Main&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(String&lt;span style="color:#f92672">[]&lt;/span> args) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> String str &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello World!&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(str);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;Hello World!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>public class io.github.ileonli.Main
 minor version: 0
 major version: 65
 flags: (0x0021) ACC_PUBLIC, ACC_SUPER
 this_class: #21 // io/github/ileonli/Main
 super_class: #2 // java/lang/Object
 interfaces: 0, fields: 0, methods: 2, attributes: 1
Constant pool:
 #1 = Methodref #2.#3 // java/lang/Object.&amp;#34;&amp;lt;init&amp;gt;&amp;#34;:()V
 #2 = Class #4 // java/lang/Object
 #3 = NameAndType #5:#6 // &amp;#34;&amp;lt;init&amp;gt;&amp;#34;:()V
 #4 = Utf8 java/lang/Object
 #5 = Utf8 &amp;lt;init&amp;gt;
 #6 = Utf8 ()V
 #7 = String #8 // Hello World!
 #8 = Utf8 Hello World!
 #9 = Fieldref #10.#11 // java/lang/System.out:Ljava/io/PrintStream;
 #10 = Class #12 // java/lang/System
 #11 = NameAndType #13:#14 // out:Ljava/io/PrintStream;
 #12 = Utf8 java/lang/System
 #13 = Utf8 out
 #14 = Utf8 Ljava/io/PrintStream;
 #15 = Methodref #16.#17 // java/io/PrintStream.println:(Ljava/lang/String;)V
 #16 = Class #18 // java/io/PrintStream
 #17 = NameAndType #19:#20 // println:(Ljava/lang/String;)V
 #18 = Utf8 java/io/PrintStream
 #19 = Utf8 println
 #20 = Utf8 (Ljava/lang/String;)V
 #21 = Class #22 // io/github/ileonli/Main
 #22 = Utf8 io/github/ileonli/Main
 #23 = Utf8 Code
 #24 = Utf8 LineNumberTable
 #25 = Utf8 main
 #26 = Utf8 ([Ljava/lang/String;)V
 #27 = Utf8 SourceFile
 #28 = Utf8 Main.java
{
 public io.github.ileonli.Main();
 descriptor: ()V
 flags: (0x0001) ACC_PUBLIC
 Code:
 stack=1, locals=1, args_size=1
 0: aload_0
 1: invokespecial #1 // Method java/lang/Object.&amp;#34;&amp;lt;init&amp;gt;&amp;#34;:()V
 4: return
 LineNumberTable:
 line 3: 0

 public static void main(java.lang.String[]);
 descriptor: ([Ljava/lang/String;)V
 flags: (0x0009) ACC_PUBLIC, ACC_STATIC
 Code:
 stack=2, locals=2, args_size=1
 0: ldc #7 // String Hello World!
 2: astore_1
 3: getstatic #9 // Field java/lang/System.out:Ljava/io/PrintStream;
 6: aload_1
 7: invokevirtual #15 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
 10: getstatic #9 // Field java/lang/System.out:Ljava/io/PrintStream;
 13: ldc #7 // String Hello World!
 15: invokevirtual #15 // Method java/io/PrintStream.println:(Ljava/lang/String;)V
 18: return
 LineNumberTable:
 line 5: 0
 line 6: 3
 line 7: 10
 line 8: 18
}
&lt;/code>&lt;/pre>&lt;p>从 class 文件的反编译结果可以看出 &lt;code>main&lt;/code> 方法中有大量的复用：&lt;/p></description></item><item><title>MyBatis Cache</title><link>https://ileonli.github.io/post/mybatis/cache/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/post/mybatis/cache/</guid><description>&lt;h1 id="一级缓存和二级缓存">一级缓存和二级缓存&lt;/h1>
&lt;p>MyBatis 提供了二层缓存架构，分别为：&lt;strong>一级缓存&lt;/strong>和&lt;strong>二级缓存&lt;/strong>。&lt;/p>
&lt;h2 id="一级缓存">一级缓存&lt;/h2>
&lt;p>一级缓存是会话级别的，MyBatis 每创建一个 &lt;code>SqlSession&lt;/code>，就表示开启了一次数据库会话。在一次会话内，可能会在短时间内反复执行完全相同的查询语句。&lt;/p>
&lt;p>&lt;code>Executor&lt;/code> 对象内会建立一个简单的缓存，在执行查询操作时，会先查询一级缓存，如果其中存在完全一样的查询语句，则直接从一级缓存中取出结果。&lt;/p>
&lt;p>一级缓存的生命周期与 &lt;code>SqlSession&lt;/code> 相同，&lt;code>SqlSession&lt;/code> 内部有 &lt;code>Executor&lt;/code> 对象，当调用 &lt;code>SqlSession&lt;/code> 的 &lt;code>close()&lt;/code> 方法时，会调用 &lt;code>Executor&lt;/code> 的 &lt;code>close()&lt;/code> 方法。&lt;/p>
&lt;h3 id="具体流程">具体流程&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">query&lt;/span>(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throws&lt;/span> SQLException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BoundSql boundSql &lt;span style="color:#f92672">=&lt;/span> ms.&lt;span style="color:#a6e22e">getBoundSql&lt;/span>(parameter);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CacheKey key &lt;span style="color:#f92672">=&lt;/span> createCacheKey(ms, parameter, rowBounds, boundSql);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> query(ms, parameter, rowBounds, resultHandler, key, boundSql);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@SuppressWarnings&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;unchecked&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">query&lt;/span>(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CacheKey key, BoundSql boundSql) &lt;span style="color:#66d9ef">throws&lt;/span> SQLException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ErrorContext.&lt;span style="color:#a6e22e">instance&lt;/span>().&lt;span style="color:#a6e22e">resource&lt;/span>(ms.&lt;span style="color:#a6e22e">getResource&lt;/span>()).&lt;span style="color:#a6e22e">activity&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;executing a query&amp;#34;&lt;/span>).&lt;span style="color:#a6e22e">object&lt;/span>(ms.&lt;span style="color:#a6e22e">getId&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (closed) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ExecutorException(&lt;span style="color:#e6db74">&amp;#34;Executor was closed.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (queryStack &lt;span style="color:#f92672">==&lt;/span> 0 &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> ms.&lt;span style="color:#a6e22e">isFlushCacheRequired&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clearLocalCache();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> list;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queryStack&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> list &lt;span style="color:#f92672">=&lt;/span> resultHandler &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#f92672">?&lt;/span> (List&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span>) localCache.&lt;span style="color:#a6e22e">getObject&lt;/span>(key) : &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (list &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> list &lt;span style="color:#f92672">=&lt;/span> queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queryStack&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (queryStack &lt;span style="color:#f92672">==&lt;/span> 0) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (DeferredLoad deferredLoad : deferredLoads) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> deferredLoad.&lt;span style="color:#a6e22e">load&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// issue #601&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> deferredLoads.&lt;span style="color:#a6e22e">clear&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (configuration.&lt;span style="color:#a6e22e">getLocalCacheScope&lt;/span>() &lt;span style="color:#f92672">==&lt;/span> LocalCacheScope.&lt;span style="color:#a6e22e">STATEMENT&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// issue #482&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clearLocalCache();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> list;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="cachekey">CacheKey&lt;/h3>
&lt;p>&lt;code>CacheKey&lt;/code> 由 &lt;code>MappedStatement&lt;/code> 的 &lt;code>id&lt;/code>、对应的 &lt;code>offset&lt;/code> 和 &lt;code>limit&lt;/code>、SQL 语句（包含 ? 占位符）、用户传入的参数和 &lt;code>Environment&lt;/code> 的 &lt;code>id&lt;/code> 组成。&lt;/p></description></item><item><title>MyBatis Executor</title><link>https://ileonli.github.io/post/mybatis/executor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/post/mybatis/executor/</guid><description>&lt;h1 id="executor">Executor&lt;/h1>
&lt;p>&lt;code>SqlSession&lt;/code> 中的具体操作都会通过 &lt;code>Executor&lt;/code> 接口进行实现。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DefaultSqlSession&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> SqlSession {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Executor executor;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ileonli.github.io/img/MyBatis/Executor.png" alt="">&lt;/p>
&lt;h2 id="executortype">ExecutorType&lt;/h2>
&lt;p>&lt;code>Executor&lt;/code> 一共有三种类型：&lt;/p>
&lt;ul>
&lt;li>&lt;code>SIMPLE&lt;/code>：&lt;/li>
&lt;li>&lt;code>REUSE&lt;/code>：&lt;/li>
&lt;li>&lt;code>BATCH&lt;/code>：&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">enum&lt;/span> ExecutorType {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SIMPLE,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> REUSE,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BATCH
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="baseexecutor">BaseExecutor&lt;/h2>
&lt;p>&lt;code>BaseExecutor&lt;/code> 是继承自 &lt;code>Executor&lt;/code> 接口的抽象类。该类实现了 &lt;code>Executor&lt;/code> 中的大部分方法。&lt;/p>
&lt;p>该类使用了模板方法模式，继承 &lt;code>BaseExecutor&lt;/code> 的子类只需要实现下边的四个基本方法即可完成数据库的相关操作。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">abstract&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">BaseExecutor&lt;/span> &lt;span style="color:#66d9ef">implements&lt;/span> Executor {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">abstract&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">doUpdate&lt;/span>(MappedStatement ms, Object parameter) &lt;span style="color:#66d9ef">throws&lt;/span> SQLException;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">abstract&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>BatchResult&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">doFlushStatements&lt;/span>(&lt;span style="color:#66d9ef">boolean&lt;/span> isRollback) &lt;span style="color:#66d9ef">throws&lt;/span> SQLException;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">abstract&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">doQuery&lt;/span>(MappedStatement ms, Object parameter, RowBounds rowBounds,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ResultHandler resultHandler, BoundSql boundSql) &lt;span style="color:#66d9ef">throws&lt;/span> SQLException;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#66d9ef">abstract&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> Cursor&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">doQueryCursor&lt;/span>(MappedStatement ms, Object parameter, RowBounds rowBounds,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BoundSql boundSql) &lt;span style="color:#66d9ef">throws&lt;/span> SQLException;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="simpleexecutor">SimpleExecutor&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">doUpdate&lt;/span>(MappedStatement ms, Object parameter) &lt;span style="color:#66d9ef">throws&lt;/span> SQLException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Statement stmt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Configuration configuration &lt;span style="color:#f92672">=&lt;/span> ms.&lt;span style="color:#a6e22e">getConfiguration&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StatementHandler handler &lt;span style="color:#f92672">=&lt;/span> configuration.&lt;span style="color:#a6e22e">newStatementHandler&lt;/span>(&lt;span style="color:#66d9ef">this&lt;/span>, ms, parameter, RowBounds.&lt;span style="color:#a6e22e">DEFAULT&lt;/span>, &lt;span style="color:#66d9ef">null&lt;/span>, &lt;span style="color:#66d9ef">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stmt &lt;span style="color:#f92672">=&lt;/span> prepareStatement(handler, ms.&lt;span style="color:#a6e22e">getStatementLog&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> handler.&lt;span style="color:#a6e22e">update&lt;/span>(stmt);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> closeStatement(stmt);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">doQuery&lt;/span>(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BoundSql boundSql) &lt;span style="color:#66d9ef">throws&lt;/span> SQLException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Statement stmt &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Configuration configuration &lt;span style="color:#f92672">=&lt;/span> ms.&lt;span style="color:#a6e22e">getConfiguration&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StatementHandler handler &lt;span style="color:#f92672">=&lt;/span> configuration.&lt;span style="color:#a6e22e">newStatementHandler&lt;/span>(wrapper, ms, parameter, rowBounds, resultHandler,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> boundSql);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stmt &lt;span style="color:#f92672">=&lt;/span> prepareStatement(handler, ms.&lt;span style="color:#a6e22e">getStatementLog&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> handler.&lt;span style="color:#a6e22e">query&lt;/span>(stmt, resultHandler);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> closeStatement(stmt);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">protected&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> Cursor&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">doQueryCursor&lt;/span>(MappedStatement ms, Object parameter, RowBounds rowBounds, BoundSql boundSql)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throws&lt;/span> SQLException {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Configuration configuration &lt;span style="color:#f92672">=&lt;/span> ms.&lt;span style="color:#a6e22e">getConfiguration&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> StatementHandler handler &lt;span style="color:#f92672">=&lt;/span> configuration.&lt;span style="color:#a6e22e">newStatementHandler&lt;/span>(wrapper, ms, parameter, rowBounds, &lt;span style="color:#66d9ef">null&lt;/span>, boundSql);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Statement stmt &lt;span style="color:#f92672">=&lt;/span> prepareStatement(handler, ms.&lt;span style="color:#a6e22e">getStatementLog&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Cursor&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> cursor &lt;span style="color:#f92672">=&lt;/span> handler.&lt;span style="color:#a6e22e">queryCursor&lt;/span>(stmt);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stmt.&lt;span style="color:#a6e22e">closeOnCompletion&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> cursor;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@Override&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>BatchResult&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">doFlushStatements&lt;/span>(&lt;span style="color:#66d9ef">boolean&lt;/span> isRollback) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> Collections.&lt;span style="color:#a6e22e">emptyList&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>MyBatis Mapper</title><link>https://ileonli.github.io/post/mybatis/mapper/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/post/mybatis/mapper/</guid><description>&lt;h1 id="mapper">Mapper&lt;/h1>
&lt;h2 id="mapperregistry">MapperRegistry&lt;/h2>
&lt;p>&lt;code>MapperRegistry&lt;/code> 是 Mapper 接口及其对应的代理对象工厂的注册中心。&lt;/p>
&lt;p>&lt;code>Configuration&lt;/code> 是 MyBatis 全局性的配置对象，在 MyBatis 初始化的过程中，所有配置信息会被解析成相应的对象并记录到 &lt;code>Configuration&lt;/code> 对象中。&lt;/p>
&lt;h3 id="knownmappers">knownMappers&lt;/h3>
&lt;p>&lt;code>MapperRegistry&lt;/code> 类中的 &lt;code>knownMappers&lt;/code> 用做具体保存。&lt;/p>
&lt;p>&lt;code>key&lt;/code> 是 &lt;code>Mapper&lt;/code> 接口对应的 &lt;code>Class&lt;/code> 对象，&lt;code>value&lt;/code> 为 &lt;code>MapperProxyFactory&lt;/code> 工厂对象。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">final&lt;/span> Map&lt;span style="color:#f92672">&amp;lt;&lt;/span>Class&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&lt;/span>, MapperProxyFactory&lt;span style="color:#f92672">&amp;lt;?&amp;gt;&amp;gt;&lt;/span> knownMappers &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> ConcurrentHashMap&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="addmapper">addMapper&lt;/h3>
&lt;p>&lt;code>addMapper&lt;/code> 会将接口类和包装后的对象放入到 &lt;code>knownMappers&lt;/code> 对象中。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">addMapper&lt;/span>(Class&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> type) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (type.&lt;span style="color:#a6e22e">isInterface&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (hasMapper(type)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> BindingException(&lt;span style="color:#e6db74">&amp;#34;Type &amp;#34;&lt;/span> &lt;span style="color:#f92672">+&lt;/span> type &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#34; is already known to the MapperRegistry.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">boolean&lt;/span> loadCompleted &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">false&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> knownMappers.&lt;span style="color:#a6e22e">put&lt;/span>(type, &lt;span style="color:#66d9ef">new&lt;/span> MapperProxyFactory&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(type));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// It&amp;#39;s important that the type is added before the parser is run&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// otherwise the binding may automatically be attempted by the&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// mapper parser. If the type is already known, it won&amp;#39;t try.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MapperAnnotationBuilder parser &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> MapperAnnotationBuilder(config, type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parser.&lt;span style="color:#a6e22e">parse&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadCompleted &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">true&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">finally&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>loadCompleted) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> knownMappers.&lt;span style="color:#a6e22e">remove&lt;/span>(type);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="getmapper">getMapper&lt;/h3>
&lt;p>当使用 &lt;code>SqlSession&lt;/code> 类中的 &lt;code>&amp;lt;T&amp;gt; T getMapper(Class&amp;lt;T&amp;gt; type);&lt;/code> 方法获取 Mapper 时，会转发到 &lt;code>MapperRegistry&lt;/code> 的 &lt;code>getMapper&lt;/code> 方法进行具体处理。&lt;/p></description></item><item><title>MyBatis ResultSetHandler</title><link>https://ileonli.github.io/post/mybatis/resultsethandler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/post/mybatis/resultsethandler/</guid><description>&lt;h1 id="resultsethandler">ResultSetHandler&lt;/h1>
&lt;p>MyBatis 会将 &lt;code>ResultSet&lt;/code> 按照映射配置文件中定义的映射规则（例如 &lt;code>&amp;lt;resultMap&amp;gt;&lt;/code> 节点和 &lt;code>resultType&lt;/code> 属性等）映射成相应的对象。&lt;/p>
&lt;p>在 &lt;code>StatementHandler&lt;/code> 接口执行完指定的 select 语句之后，会将查询得到的 &lt;code>ResultSet&lt;/code> 交给 &lt;code>ResultSetHandler&lt;/code> 完成映射处理。&lt;/p>
&lt;p>&lt;code>ResultSetHandler&lt;/code> 除了负责映射 select 语句查询得到的结果集，还会处理存储过程执行后的输出参数。&lt;/p>
&lt;h2 id="defaultresultsethandler">DefaultResultSetHandler&lt;/h2>
&lt;p>&lt;code>ResultSetHandler&lt;/code> 只有一个实现类 &lt;code>DefaultResultSetHandler&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">ResultSetHandler&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">handleResultSets&lt;/span>(Statement stmt) &lt;span style="color:#66d9ef">throws&lt;/span> SQLException;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> Cursor&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">handleCursorResultSets&lt;/span>(Statement stmt) &lt;span style="color:#66d9ef">throws&lt;/span> SQLException;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">handleOutputParameters&lt;/span>(CallableStatement cs) &lt;span style="color:#66d9ef">throws&lt;/span> SQLException;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="multiqueries">MultiQueries&lt;/h2>
&lt;h3 id="jdbc">JDBC&lt;/h3>
&lt;p>为了同时执行多条查询语句，需要设置 &lt;code>allowMultiQueries=true&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>Connection conn &lt;span style="color:#f92672">=&lt;/span> DriverManager.&lt;span style="color:#a6e22e">getConnection&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;jdbc:mysql://localhost/db?allowMultiQueries=true&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;root&amp;#34;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;0987654321&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>String sql &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">SELECT * FROM `user`;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">SELECT * FROM `blog`;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">try&lt;/span> (Statement stmt &lt;span style="color:#f92672">=&lt;/span> conn.&lt;span style="color:#a6e22e">createStatement&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stmt.&lt;span style="color:#a6e22e">execute&lt;/span>(sql);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> cnt &lt;span style="color:#f92672">=&lt;/span> 0;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ResultSet rs &lt;span style="color:#f92672">=&lt;/span> stmt.&lt;span style="color:#a6e22e">getResultSet&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (rs &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (stmt.&lt;span style="color:#a6e22e">getMoreResults&lt;/span>()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rs &lt;span style="color:#f92672">=&lt;/span> stmt.&lt;span style="color:#a6e22e">getResultSet&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rs &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cnt&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> System.&lt;span style="color:#a6e22e">out&lt;/span>.&lt;span style="color:#a6e22e">println&lt;/span>(cnt);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每一个查询语句会返回一个 &lt;code>ResultSet&lt;/code>。上边的代码执行后，会返回两个 &lt;code>ResultSet&lt;/code>。因此，&lt;code>cnt&lt;/code> 的结果为 2（一共有两个 &lt;code>SELECT&lt;/code> 查询）。&lt;/p></description></item><item><title>MyBatis SqlSession</title><link>https://ileonli.github.io/post/mybatis/sqlsession/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/post/mybatis/sqlsession/</guid><description>&lt;h1 id="sqlsession">SqlSession&lt;/h1>
&lt;p>&lt;code>SalSession&lt;/code> 是用于操作数据库的接口，具体的操作都通过此接口。&lt;/p>
&lt;p>&lt;img src="https://ileonli.github.io/img/MyBatis/SqlSession.png" alt="">&lt;/p>
&lt;h2 id="sqlsessionfactorybuilder">SqlSessionFactoryBuilder&lt;/h2>
&lt;p>此类可以被实例化、使用和丢弃，一旦使用此类创建了 &lt;code>SqlSessionFactory&lt;/code>，后续就不需要使用此类了。因此 &lt;code>SqlSessionFactoryBuilder&lt;/code> 实例的最佳作用域是方法作用域（也就是局部方法变量）。&lt;/p>
&lt;p>可以重用 &lt;code>SqlSessionFactoryBuilder&lt;/code> 来创建多个 &lt;code>SqlSessionFactory&lt;/code> 实例，但最好还是不要一直保留着它，以保证 XML 资源可以被释放。&lt;/p>
&lt;h2 id="sqlsessionfactory">SqlSessionFactory&lt;/h2>
&lt;p>&lt;code>SqlSessionFactory&lt;/code> 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。使用 &lt;code>SqlSessionFactory&lt;/code> 的最佳实践是在应用运行期间只创建一次。&lt;/p>
&lt;hr>
&lt;p>&lt;code>SqlSessionFactory&lt;/code> 的作用是为了创建 &lt;code>SqlSession&lt;/code> 实例。&lt;code>SqlSession&lt;/code> 是 MyBatis 执行 SQL 命令的核心接口，通过此实例可以对数据库进行查询、插入、更新和删除操作。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> java.sql.Connection;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Creates an {@link SqlSession} out of a connection or a DataSource
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @author Clinton Begin
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">SqlSessionFactory&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SqlSession &lt;span style="color:#a6e22e">openSession&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SqlSession &lt;span style="color:#a6e22e">openSession&lt;/span>(&lt;span style="color:#66d9ef">boolean&lt;/span> autoCommit);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SqlSession &lt;span style="color:#a6e22e">openSession&lt;/span>(Connection connection);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SqlSession &lt;span style="color:#a6e22e">openSession&lt;/span>(TransactionIsolationLevel level);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SqlSession &lt;span style="color:#a6e22e">openSession&lt;/span>(ExecutorType execType);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SqlSession &lt;span style="color:#a6e22e">openSession&lt;/span>(ExecutorType execType, &lt;span style="color:#66d9ef">boolean&lt;/span> autoCommit);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SqlSession &lt;span style="color:#a6e22e">openSession&lt;/span>(ExecutorType execType, TransactionIsolationLevel level);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> SqlSession &lt;span style="color:#a6e22e">openSession&lt;/span>(ExecutorType execType, Connection connection);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Configuration &lt;span style="color:#a6e22e">getConfiguration&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;p>&lt;code>SqlSessionFactory&lt;/code> 主要有两个具体的实现：&lt;/p></description></item><item><title>MyBatis StatementHandler</title><link>https://ileonli.github.io/post/mybatis/statementhandler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/post/mybatis/statementhandler/</guid><description>&lt;h1 id="statementhandler">StatementHandler&lt;/h1>
&lt;p>&lt;code>StatementHandler&lt;/code> 接口中的功能很多，例如创建 &lt;code>Statement&lt;/code> 对象，为 SQL 语句绑定实参，执行 select、insert、update、delete 等多种类型的 SQL 语句，批量执行 SQL 语句，将结果集映射成结果对象。&lt;/p>
&lt;p>&lt;img src="https://ileonli.github.io/img/MyBatis/StatementHandler.png" alt="">&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Java" data-lang="Java">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> &lt;span style="color:#a6e22e">StatementHandler&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Statement &lt;span style="color:#a6e22e">prepare&lt;/span>(Connection connection, Integer transactionTimeout) &lt;span style="color:#66d9ef">throws&lt;/span> SQLException;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">parameterize&lt;/span>(Statement statement) &lt;span style="color:#66d9ef">throws&lt;/span> SQLException;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">batch&lt;/span>(Statement statement) &lt;span style="color:#66d9ef">throws&lt;/span> SQLException;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">update&lt;/span>(Statement statement) &lt;span style="color:#66d9ef">throws&lt;/span> SQLException;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> List&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">query&lt;/span>(Statement statement, ResultHandler resultHandler) &lt;span style="color:#66d9ef">throws&lt;/span> SQLException;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> Cursor&lt;span style="color:#f92672">&amp;lt;&lt;/span>E&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#a6e22e">queryCursor&lt;/span>(Statement statement) &lt;span style="color:#66d9ef">throws&lt;/span> SQLException;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BoundSql &lt;span style="color:#a6e22e">getBoundSql&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ParameterHandler &lt;span style="color:#a6e22e">getParameterHandler&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>prepare&lt;/code>：从 &lt;code>Connection&lt;/code> 中创建 &lt;code>Statement&lt;/code> 对象。&lt;/li>
&lt;li>&lt;code>parameterize&lt;/code>：绑定 &lt;code>statement&lt;/code> 执行时需要的参数。&lt;/li>
&lt;li>&lt;code>batch&lt;/code>：批量执行 SQL 语句。&lt;/li>
&lt;li>&lt;code>update&lt;/code>：执行 insert、update 和 delete 操作。&lt;/li>
&lt;li>&lt;code>query&lt;/code> 和 &lt;code>queryCursor&lt;/code>：用于执行 select 操作。&lt;/li>
&lt;li>&lt;code>getBoundSql&lt;/code>：获取绑定的 SQL。&lt;/li>
&lt;li>&lt;code>getParameterHandler&lt;/code>：负责处理 SQL 语句中的参数的处理器。&lt;/li>
&lt;/ul>
&lt;h2 id="basestatementhandler">BaseStatementHandler&lt;/h2>
&lt;h3 id="prepare">prepare&lt;/h3>
&lt;p>&lt;code>BaseStatementHandler&lt;/code> 中设计了模板方法 &lt;code>prepare&lt;/code>，通过该方法可以获取 &lt;code>Statement&lt;/code> 对象。&lt;/p></description></item></channel></rss>