<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>网络字节序</title>
<link href=https://unpkg.com/@master/normal.css rel=stylesheet><link href=fonts/LXGWWenKaiGB-Regular.ttf rel=stylesheet><script src=https://unpkg.com/@master/style@1.5.0></script><script src=https://unpkg.com/@master/styles@1.13.0></script><script src=https://unpkg.com/master-styles-group></script><style>:root{--font-sans:"LXGW WenKai GB", "Hiragino Sans GB", "冬青黑", "Microsoft YaHei", "微软雅黑", SimSun, "宋体", Helvetica, Tahoma, Arial, sans-serif}</style></head><body class="bg:fade-84@dark font:fade-16@dark font:sans"><div class="d:flex flex:column@<=sm pt:60 px:24 jc:center gap:44 word-break:break-word"><div class="max-w:800 w:full box:content-box"><article class="box:border-box pt:32"><div class="_:where(a):hover{text-decoration-color:fade}
_:where(a){text-decoration:2;underline;fade-30;_text-decoration-color:fade-70@dark}
_:where(blockquote){bl:5;solid;fade-76/.1;_bl:5;solid;fade-34/.1@dark}
_:where(code){font:90%;_v:middle}
_:where(code:not(.highlight_*,pre_*)){p:2}
_:where(del){text-decoration:1;line-through;fade-68;_text-decoration-color:red-64@dark}
_:where(figcaption){text:14;_p:10;20;0;_width:fit;_mx:auto;_font:fade-56;_font:fade-57@dark}
_:where(h1,h2,h3,h4,h5,h6){mt:1em}
_:where(h1){font:40;_font:extrabold}
_:where(h1){my:1em}
_:where(h2){font:32}
_:where(h3){font:24}
_:where(h4){font:20}
_:where(h5){font:16}
_:where(h6){font:14}
_:where(li)::marker{font:fade-44;_font:fade-68@dark}
_:where(li){pl:.375em}
_:where(mark){text-decoration:1;underline;#fce016;_bg:transparent;_text-decoration-color:rgb(252;224;22/.5)@dark}
_:where(p,li){font:fade-76;_font:16;_line-height:1.65;_font:fade-34@dark}
_:where(p,pre,blockquote,figure,ul,ol,table){my:1em}
>:first-child{mt:0!}
_:where(pre){p:20;_r:8;_overflow:auto}
_:where(pre,code:not(.highlight_*)){bg:fade-2;_bg:fade-92!@dark}
_:where(strong,b,a,code:not(.highlight_*),mark,del){font:fade-92;_font:fade-12@dark}
_:where(table){width:full;_border-spacing:0}
_:where(td){v:baseline}
_:where(td,th):first-child{pl:0}
_:where(td,th):last-child{pr:0}
_:where(td,th){bb:1;solid;fade-92/.06;_p:6;_b:fade-4/.04@dark}
_:where(th){font:fade-78;_font:14;_text:left;_font:fade-12@dark}
_:where(th,p_code,li_code,a,mark){font:semibold;_font:medium@dark}
_:where(ul){list-style-type:disc}
_:where(ul,ol,blockquote){pl:1em}
_:where(video,img){max-width:full}
_:where(video){mx:auto}
_:where(img){mx:auto}
_:where(a,mark){text-underline-offset:3}
_:where(hr){h:2;_bg:fade-10;_bg:fade-70@dark;_my:1em}"><h1 id=网络字节序>网络字节序</h1><h2 id=大小端>大小端</h2><p>不同架构的 CPU 中，4 字节整数 1 在内存中存储的方式是不同的。</p><ul><li>大端序（big endian）：<strong>最高位</strong>有效字节存储在<strong>低内存地址</strong>，而<strong>最低位</strong>有效字节存储在<strong>高内存地址</strong>。</li><li>小端序（little endian）：<strong>最高位</strong>有效字节存储在<strong>高内存地址</strong>，而<strong>最低位</strong>有效字节存储在<strong>低内存地址</strong>。</li></ul><hr><p>对于一个 4 字节整数 <code>0x01020304</code>，大小端序存储方式分别如下：</p><pre tabindex=0><code>地址:  0   1   2   3  （大端序保存）
      01  02  03  04
</code></pre><pre tabindex=0><code>地址:  0   1   2   3  （小端序保存）
      04  03  02  01
</code></pre><hr><p>可以使用下边的方法判断机器的字节序：</p><ol><li>通过 <code>endian.h</code> 提供的 <code>BYTE_ORDER</code> 宏。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;endian.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>big_endian</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> BYTE_ORDER <span style=color:#f92672>==</span> BIG_ENDIAN;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>little_endian</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> BYTE_ORDER <span style=color:#f92672>==</span> LITTLE_ENDIAN;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=2><li>将 <code>uint16_t</code> 类型的数字转为 <code>char *</code>，通过高字节和低字节进行判断。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>big_endian</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> val <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0102</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ((<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>) (<span style=color:#f92672>&amp;</span>val))[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x01</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>little_endian</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> val <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0102</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ((<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>) (<span style=color:#f92672>&amp;</span>val))[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x01</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ol start=3><li>和方法 2 类似，利用的是 <code>union</code> 相同的内存位置存储不同的数据类型。</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>union</span> endian {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint16_t</span> val;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> bytes[<span style=color:#ae81ff>2</span>];
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>big_endian</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>union</span> endian en{};
</span></span><span style=display:flex><span>    en.val <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0102</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> en.bytes[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x01</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>little_endian</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>union</span> endian en{};
</span></span><span style=display:flex><span>    en.val <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x0102</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> en.bytes[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0x02</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><p>为什么有两种不同的字节序？</p><blockquote><p><strong>大端序</strong>是人类最熟悉的读写方法，从左向右处理。</p><p><strong>小端序</strong>更利于计算机处理，因为计算都是从低位开始的，先处理低位字节，效率比较高。</p></blockquote><h2 id=网络字节序-1>网络字节序</h2><p>如果通信双方采用不同的架构，收发数据后进行解析时会发生问题。如：大端序机器 A 发送 <code>0x01020304</code> 到小端序机器 B 时，B 以小端序方式解析该数字为 <code>0x04030201</code>。</p><p>为解决上边问题，网络传输数据时，通信双方需要约定统一方式，把此约定叫做<strong>网络字节序</strong>（network byte order）。</p><blockquote><p>网络字节序规定使用<strong>大端序</strong>，大多数网络协议（例如 TCP/IP 协议族）规定了网络字节序采用<strong>大端序</strong>。</p></blockquote><p>因此，小端序发送数据时，需要先转为大端序。</p><h2 id=字节序转换>字节序转换</h2><p>下边函数用于字节序的相互转换：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;arpa/inet.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint32_t</span> <span style=color:#a6e22e>htonl</span>(<span style=color:#66d9ef>uint32_t</span> hostlong);
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint16_t</span> <span style=color:#a6e22e>htons</span>(<span style=color:#66d9ef>uint16_t</span> hostshort);
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint32_t</span> <span style=color:#a6e22e>ntohl</span>(<span style=color:#66d9ef>uint32_t</span> netlong);
</span></span><span style=display:flex><span><span style=color:#66d9ef>uint16_t</span> <span style=color:#a6e22e>ntohs</span>(<span style=color:#66d9ef>uint16_t</span> netshort);
</span></span></code></pre></div><p>函数名中的 <code>h</code> 表示主机（host）字节序，<code>n</code> 表示网络（network）字节序；<code>s</code> 表示 <code>short</code> 类型，<code>l</code> 表示 <code>long</code> 类型。</p></div></article></div></div></body><footer class="flex jc:center my:24"><div>Copyright © 2024, Leon Li.</div></footer></html>