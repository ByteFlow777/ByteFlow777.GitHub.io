<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>I/O 多路复用</title>
<link href=https://unpkg.com/@master/normal.css rel=stylesheet><script src=https://unpkg.com/@master/style@1.5.0></script><script src=https://unpkg.com/@master/styles@1.13.0></script><script src=https://unpkg.com/master-styles-group></script><style>:root{--font-sans:"LXGW WenKai GB", "Hiragino Sans GB", "冬青黑", "Microsoft YaHei", "微软雅黑", SimSun, "宋体", Helvetica, Tahoma, Arial, sans-serif}</style></head><body class="bg:fade-84@dark font:fade-16@dark font:sans"><div class="d:flex flex:column@<=sm pt:60 px:24 jc:center gap:44 word-break:break-word"><div class="max-w:800 w:full box:content-box"><article class="box:border-box pt:32"><div class="_:where(a):hover{text-decoration-color:fade}
_:where(a){text-decoration:2;underline;fade-30;_text-decoration-color:fade-70@dark}
_:where(blockquote){bl:5;solid;fade-76/.1;_bl:5;solid;fade-34/.1@dark}
_:where(code){font:90%;_v:middle}
_:where(code:not(.highlight_*,pre_*)){p:2}
_:where(del){text-decoration:1;line-through;fade-68;_text-decoration-color:red-64@dark}
_:where(figcaption){text:14;_p:10;20;0;_width:fit;_mx:auto;_font:fade-56;_font:fade-57@dark}
_:where(h1,h2,h3,h4,h5,h6){mt:1em}
_:where(h1){font:40;_font:extrabold}
_:where(h1){my:1em}
_:where(h2){font:32}
_:where(h3){font:24}
_:where(h4){font:20}
_:where(h5){font:16}
_:where(h6){font:14}
_:where(li)::marker{font:fade-44;_font:fade-68@dark}
_:where(li){pl:.375em}
_:where(mark){text-decoration:1;underline;#fce016;_bg:transparent;_text-decoration-color:rgb(252;224;22/.5)@dark}
_:where(p,li){font:fade-76;_font:16;_line-height:1.65;_font:fade-34@dark}
_:where(p,pre,blockquote,figure,ul,ol,table){my:1em}
>:first-child{mt:0!}
_:where(pre){p:20;_r:8;_overflow:auto}
_:where(pre,code:not(.highlight_*)){bg:fade-2;_bg:fade-92!@dark}
_:where(strong,b,a,code:not(.highlight_*),mark,del){font:fade-92;_font:fade-12@dark}
_:where(table){width:full;_border-spacing:0}
_:where(td){v:baseline}
_:where(td,th):first-child{pl:0}
_:where(td,th):last-child{pr:0}
_:where(td,th){bb:1;solid;fade-92/.06;_p:6;_b:fade-4/.04@dark}
_:where(th){font:fade-78;_font:14;_text:left;_font:fade-12@dark}
_:where(th,p_code,li_code,a,mark){font:semibold;_font:medium@dark}
_:where(ul){list-style-type:disc}
_:where(ul,ol,blockquote){pl:1em}
_:where(video,img){max-width:full}
_:where(video){mx:auto}
_:where(img){mx:auto}
_:where(a,mark){text-underline-offset:3}
_:where(hr){h:2;_bg:fade-10;_bg:fade-70@dark;_my:1em}"><h1 id=io-多路复用>I/O 多路复用</h1><p>I/O 复用可以使程序同时监听多个文件描述符。</p><h2 id=select>select</h2><p><code>select</code> 函数允许程序监视多个文件描述符，直到一个或多个文件描述符“准备好”进行某类 I/O 操作。</p><p><code>select</code> 成功时返回就绪文件描述符的总数，如果超时时间内没有任何文件描述符就绪，则返回 0。失败时返回 -1 并设置 <code>errno</code>。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/select.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>select</span>(<span style=color:#66d9ef>int</span> nfds, fd_set<span style=color:#f92672>*</span> readfds,
</span></span><span style=display:flex><span>            fd_set<span style=color:#f92672>*</span> writefds,
</span></span><span style=display:flex><span>            fd_set<span style=color:#f92672>*</span> exceptfds,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>struct</span> timeval <span style=color:#f92672>*</span> timeout);
</span></span></code></pre></div><h3 id=函数参数>函数参数</h3><p><code>nfds</code>：指定被监听的文件描述符的总数。这个参数应该被设置为三个集合中编号最高的文件描述符，再加 1，因为文件描述符是从 0 开始的。</p><hr><p><code>readfds</code>、<code>writefds</code> 和 <code>exceptfds</code>：分别指向可读、可写和异常事件对应的文件描述符集合。如果没有文件描述符要监听，则可以将对应的 <code>fd_set</code> 参数设为 <code>NULL</code>。</p><p><code>fd_set</code> 结构体仅包含一个数组，数组每一位标记一个文件描述符，最大容纳长度由 <code>FD_SETSIZE</code> 指定。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>/* fd_set for select and pselect.  */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span>
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* XPG4.2 requires this member name.  Otherwise avoid the name
</span></span></span><span style=display:flex><span><span style=color:#75715e>       from the global namespace.  */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef __USE_XOPEN
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    __fd_mask fds_bits[__FD_SETSIZE <span style=color:#f92672>/</span> __NFDBITS];
</span></span><span style=display:flex><span><span style=color:#75715e># define __FDS_BITS(set) ((set)-&gt;fds_bits)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#else
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    __fd_mask __fds_bits[__FD_SETSIZE <span style=color:#f92672>/</span> __NFDBITS];
</span></span><span style=display:flex><span><span style=color:#75715e># define __FDS_BITS(set) ((set)-&gt;__fds_bits)
</span></span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  } fd_set;
</span></span></code></pre></div><p>为方便对此结构体进行操作，提供了以下几个宏函数对其进行操作，宏函数如下：</p><blockquote><p>为方便展示，对宏函数中的所有参数加上了类型</p></blockquote><ul><li><code>FD_SET(fd, fdsetp)</code>：将文件描述符 <code>fd</code> 添加到 <code>fdset</code> 指向的集合中。</li><li><code>FD_CLR(fd, fdsetp)</code>：将文件描述符 <code>fd</code> 从 <code>fdset</code> 指向的集合中移除。</li><li><code>FD_ISSET(fd, fdsetp)</code>：如果文件描述符 <code>fd</code> 是 <code>fdset</code> 指向的集合中的成员，则返回 <code>true</code>。</li><li><code>FD_ZERO(fdsetp)</code>：将 <code>fdset</code> 指向的集合初始化为空。</li></ul><hr><p><code>timeval</code>：用来设置 <code>select</code> 函数的超时时间，采用指针作为参数是因为内核将修改以告诉应用程序 select 等待了多久。</p><p>如果 <code>timeval</code> 结构体中的 <code>tv_sec</code> 和 <code>tv_usec</code> 成员都传递 0，则 <code>select</code> 函数立即返回。如果传递 <code>NULL</code>，则一直阻塞，直到某个文件描述符就绪。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>/* A time value that is accurate to the nearest
</span></span></span><span style=display:flex><span><span style=color:#75715e>   microsecond but also has a range of years.  */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> timeval
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#75715e>#ifdef __USE_TIME_BITS64
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  __time64_t tv_sec;		<span style=color:#75715e>/* Seconds.  */</span>
</span></span><span style=display:flex><span>  __suseconds64_t tv_usec;	<span style=color:#75715e>/* Microseconds.  */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#else
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  __time_t tv_sec;		<span style=color:#75715e>/* Seconds.  */</span>
</span></span><span style=display:flex><span>  __suseconds_t tv_usec;	<span style=color:#75715e>/* Microseconds.  */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><h3 id=就绪条件>就绪条件</h3><p>在网络编程中，下边情况下 <code>socket</code> 可读：</p><p>在网络编程中，下边情况下 <code>socket</code> 可写：</p><p><code>select</code> 函数能处理的异常情况只有一种：<code>socket</code> 上接收到带外数据。</p><h3 id=循环中使用>循环中使用</h3><p>由于这些结构体会在调用中被修改，如果要在循环中重复调用 <code>select</code> 函数，我们必须保证每次都要重新初始化它们。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C></code></pre></div><h2 id=poll>poll</h2><p><code>poll</code> 函数和 <code>select</code> 函数调用返回值一致。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;poll.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>poll</span>(<span style=color:#66d9ef>struct</span> pollfd <span style=color:#f92672>*</span>fds, <span style=color:#66d9ef>nfds_t</span> nfds, <span style=color:#66d9ef>int</span> timeout);
</span></span></code></pre></div><h3 id=函数参数-1>函数参数</h3><p><code>fds</code>：需要 <code>poll</code> 函数检查的文件描述符，该参数为 <code>pollfd</code> 结构体数组。</p><p><code>pollfd</code> 结构体中 <code>fd</code> 指定文件描述符；<code>events</code> 告诉 <code>poll</code> 函数需要监听哪些事件；<code>revents</code> 由内核对其进行修改，以通知应用程序 <code>fd</code> 上实际发生了哪些事件。</p><table><thead><tr><th>位掩码</th><th>events</th><th>返回到revents</th><th>描述</th></tr></thead><tbody><tr><td>POLLIN</td><td>●</td><td>●</td><td>可读取非高优先级的数据</td></tr><tr><td>POLLRDNORM</td><td>●</td><td>●</td><td>等同于POLLIN</td></tr><tr><td>POLLRDBAND</td><td>●</td><td>●</td><td>可读取优先级数据（Linux 中不使用）</td></tr><tr><td>POLLPRI</td><td>●</td><td>●</td><td>可读取高优先级数据</td></tr><tr><td>POLLRDHUP</td><td>●</td><td>●</td><td>对端套接字关闭</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>POLLOUT</td><td>●</td><td>●</td><td>普通数据可写</td></tr><tr><td>POLLWRNORM</td><td>●</td><td>●</td><td>等同于POLLOUT</td></tr><tr><td>POLLWRBAND</td><td>●</td><td>●</td><td>优先级数据可写入</td></tr><tr><td></td><td></td><td></td><td></td></tr><tr><td>POLLERR</td><td></td><td>●</td><td>有错误发生</td></tr><tr><td>POLLHUP</td><td></td><td>●</td><td>出现挂断</td></tr><tr><td>POLLNVAL</td><td></td><td>●</td><td>文件描述符未打开</td></tr><tr><td>POLLMSG</td><td></td><td></td><td>Linux 中不使用</td></tr></tbody></table><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>struct</span> pollfd {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span>   fd;         <span style=color:#75715e>/* file descriptor */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>short</span> events;     <span style=color:#75715e>/* requested events */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>short</span> revents;    <span style=color:#75715e>/* returned events */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><hr><p><code>nfds</code>：用于指定数组 <code>fds</code> 中元素的个数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>/* Type used for the number of file descriptors.  */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span> <span style=color:#66d9ef>nfds_t</span>;
</span></span></code></pre></div><hr><p><code>timeout</code>：指定 <code>poll</code> 的超时值，单位为毫秒。</p><ul><li>当 <code>timeout</code> 为 -1 时，<code>poll</code> 调用将一直阻塞，直到某个事件发生；</li><li>当 <code>timeout</code> 为 0 时，<code>poll</code> 调用将立即返回。</li></ul><h2 id=epoll>epoll</h2><p><code>epoll</code> 是 Linux 特有的 I/O 复用函数。<code>epoll</code> 需要使用额外的文件描述符，标识内核中的这个事件表，需要使用 <code>epoll_create</code> 函数创建，返回文件描述符。</p><p><code>size</code> 是想要通过 <code>epoll</code> 来检查的文件描述符个数。该参数并不是一个上限，而是告诉内核应该如何为内部数据结构划分初始大小（从 Linux 2.6.8 版以来，<code>size</code> 参数被忽略不用，因为内核实现做了修改意味着该参数提供的信息已经不再需要了）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/epoll.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_create</span> (<span style=color:#66d9ef>int</span> size);
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_create1</span> (<span style=color:#66d9ef>int</span> flags);
</span></span></code></pre></div><h3 id=epoll_ctl>epoll_ctl</h3><p><code>epoll_ctl</code> 函数能够修改由文件描述符 <code>epfd</code> 所代表的兴趣列表。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_ctl</span> (<span style=color:#66d9ef>int</span> epfd, <span style=color:#66d9ef>int</span> op, <span style=color:#66d9ef>int</span> fd,
</span></span><span style=display:flex><span>		      <span style=color:#66d9ef>struct</span> epoll_event <span style=color:#f92672>*</span>event);
</span></span></code></pre></div><hr><p><code>epfd</code> 是调用 <code>epoll_create</code> 函数的返回值。</p><hr><p><code>op</code> 用于操作操作类型。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#75715e>/* Valid opcodes ( &#34;op&#34; parameter ) to issue to epoll_ctl().  */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define EPOLL_CTL_ADD 1	</span><span style=color:#75715e>/* Add a file descriptor to the interface.  */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define EPOLL_CTL_DEL 2	</span><span style=color:#75715e>/* Remove a file descriptor from the interface.  */</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define EPOLL_CTL_MOD 3	</span><span style=color:#75715e>/* Change file descriptor epoll_event structure.  */</span><span style=color:#75715e>
</span></span></span></code></pre></div><hr><p><code>events</code> 是一个位掩码，指定了待检查描述符 <code>fd</code> 上感兴趣的事件集合。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>struct</span> epoll_event
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint32_t</span> events;	 <span style=color:#75715e>/* Epoll events */</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>epoll_data_t</span> data; <span style=color:#75715e>/* User data variable */</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><code>data</code> 当描述符 <code>fd</code> 就绪时，传递给调用者的信息。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>union</span> epoll_data
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>ptr;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> fd;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint32_t</span> u32;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>uint64_t</span> u64;
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>epoll_data_t</span>;
</span></span></code></pre></div><h3 id=epoll_wait>epoll_wait</h3><p>返回 <code>epoll</code> 实例中处于就绪态的文件描述符信息。单个 <code>epoll_wait</code> 函数调用能返回多个就绪态文件描述符的信息。</p><p>调用成功后，<code>epoll_wait</code> 函数返回数组 <code>events</code> 元素个数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>epoll_wait</span> (<span style=color:#66d9ef>int</span> epfd, <span style=color:#66d9ef>struct</span> epoll_event <span style=color:#f92672>*</span>events,
</span></span><span style=display:flex><span>		       <span style=color:#66d9ef>int</span> maxevents, <span style=color:#66d9ef>int</span> timeout);
</span></span></code></pre></div><hr><p><code>events</code> 所指向的结构体数组中返回的是有关就绪态文件描述符的信息。</p><p>数组 <code>events</code> 的空间由调用者负责申请，所包含的元素个数由参数 <code>maxevents</code> 指定。</p><hr><p><code>timeout</code>：指定 <code>epoll</code> 的超时值，单位为毫秒。</p><ul><li>当 <code>timeout</code> 为 -1 时，<code>epoll</code> 调用将一直阻塞，直到某个事件发生；</li><li>当 <code>timeout</code> 为 0 时，<code>epoll</code> 执行一次非阻塞式的检查，看兴趣列表中的文件描述符上产生了哪个事件。</li><li>当 <code>timeout</code> 大于 0 时，<code>epoll</code> 阻塞至多 <code>timeout</code> 毫秒，直到文件描述符上有事件发生，或者直到捕获到一个信号为止。</li></ul><h3 id=水平触发和边缘触发>水平触发和边缘触发</h3><p><code>epoll</code> 默认工作模式为<strong>水平触发</strong>，当往 <code>epoll</code> 内核事件表中注册一个文件描述符上的 <code>EPOLLET</code> 事件时，将以<strong>边缘触发</strong>模式工作。</p><ul><li><p>LT 模式（水平）：缓冲区剩余未读尽的数据<strong>会</strong>导致 <code>epoll_wait</code> 返回。直到新的事件满足才会触发。支持阻塞和非阻塞。</p></li><li><p>ET 模式（边缘）：缓冲区剩余未读尽的数据<strong>不会</strong>导致 <code>epoll_wait</code> 返回。必须设置为非阻塞。</p></li></ul></div></article></div></div></body><footer class="flex jc:center my:24"><div>Copyright © 2024, Leon Li.</div></footer></html>