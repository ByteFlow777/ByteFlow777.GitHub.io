<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>关于我 on Leon' Blog</title><link>https://ileonli.github.io/</link><description>Recent content in 关于我 on Leon' Blog</description><generator>Hugo -- gohugo.io</generator><language>en</language><atom:link href="https://ileonli.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>网络字节序</title><link>https://ileonli.github.io/docs/network-programming/network-byte-order/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/network-programming/network-byte-order/</guid><description>网络字节序 # 大小端 # 不同架构的 CPU 中，4 字节整数 1 在内存中存储的方式是不同的。
大端序（big endian）：最高位有效字节存储在低内存地址，而最低位有效字节存储在高内存地址。 小端序（little endian）：最高位有效字节存储在高内存地址，而最低位有效字节存储在低内存地址。 对于一个 4 字节整数 0x01020304，大小端序存储方式分别如下：
地址: 0 1 2 3 （大端序保存） 01 02 03 04 地址: 0 1 2 3 （小端序保存） 04 03 02 01 可以使用下边的方法判断机器的字节序：
通过 endian.h 提供的 BYTE_ORDER 宏。 #include &amp;lt;endian.h&amp;gt; bool big_endian() { return BYTE_ORDER == BIG_ENDIAN; } bool little_endian() { return BYTE_ORDER == LITTLE_ENDIAN; } 将 uint16_t 类型的数字转为 char *，通过高字节和低字节进行判断。 bool big_endian() { uint16_t val = 0x0102; return ((char *) (&amp;amp;val))[0] == 0x01; } bool little_endian() { uint16_t val = 0x0102; return ((char *) (&amp;amp;val))[1] == 0x01; } 和方法 2 类似，利用的是 union 相同的内存位置存储不同的数据类型。 union endian { uint16_t val; char bytes[2]; }; bool big_endian() { union endian en{}; en.</description></item><item><title>网络地址族</title><link>https://ileonli.github.io/docs/network-programming/address-families/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/network-programming/address-families/</guid><description>网络地址族 # 网络地址 # 网络地址分为 IPv4 和 IPv6，分别使用 sockaddr_in 和 sockaddr_in6 结构体表示。
sockaddr_in # struct sockaddr_in { sa_family_t sin_family; /* address family: AF_INET */ in_port_t sin_port; /* port in network byte order */ struct in_addr sin_addr; /* internet address */ /* Pad to size of `struct sockaddr&amp;#39;. */ unsigned char sin_zero[8]; }; /* Internet address */ struct in_addr { uint32_t s_addr; /* address in network byte order */ }; sin_family：在 IPv4 中设为 AF_INET。 sin_port：网络字节序保存的端口（0～65535）。 sin_addr：网络字节序保存的 32 位 IP 地址信息。 sin_zero：使 sockaddr_in 和 sockaddr 结构体大小保持一致而插入的填充位，需手动设为 0。 https://man7.</description></item><item><title>listen 中的 backlog 参数</title><link>https://ileonli.github.io/docs/network-programming/backlog/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/network-programming/backlog/</guid><description/></item><item><title>套接字（socket）</title><link>https://ileonli.github.io/docs/network-programming/sockets/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/network-programming/sockets/</guid><description>套接字（socket） # 网络编程即编写程序使两台联网的计算机相互交换数据。计算机之间会通过网线、路由器和交换机等设备连接在一起，我们无需直接操控硬件，而使用操作系统提供的套接字（socket）。
基本函数 # socket # 为了使用套接字，可以使用 socket 函数，创建用于通信的端点（endpoint）。
#include &amp;lt;sys/socket.h&amp;gt; int socket(int domain, int type, int protocol); 成功时会返回文件描述符，失败时会返回 -1。
https://man7.org/linux/man-pages/man2/socket.2.html
bind # 当使用 socket 函数创建套接字后，会存在于名称空间（地址族）中，但没有为其分配地址。bind 函数将 addr 指定的地址分配给文件描述符 sockfd 引用的套接字。
服务器可以不先调用 bind() 而直接调用 listen()，此时会为该 socket 分配一个 INADDR_ANY IP 地址（0.0.0.0）和临时端口（可通过 getsockname() 获取 socket 的地址）。
#include &amp;lt;sys/socket.h&amp;gt; int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); 成功时返回 0，失败时返回 -1。
https://man7.org/linux/man-pages/man2/bind.2.html
listen # listen 函数将文件描述符引用的 socket 标记为被动，该 socket 会被用来接受来自其它主动 socket 的连接。</description></item><item><title>echo 服务器</title><link>https://ileonli.github.io/docs/network-programming/echo-server/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ileonli.github.io/docs/network-programming/echo-server/</guid><description>echo 服务器 # 服务端代码 # 服务端（被动）接受连接请求的套接字创建过程如下：
调用 socket 函数创建套接字。 调用 bind 函数分配 IP 地址和端口号。 调用 listen 函数转为可接受请求状态。 调用 accept 函数处理连接请求。 调用 read 和 write 函数进行数据交换。 调用 close 函数断开连接。 #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;arpa/inet.h&amp;gt; #include &amp;lt;sys/socket.h&amp;gt; void panic(char *err_message) { fputs(err_message, stderr); fputc(&amp;#39;\n&amp;#39;, stderr); exit(EXIT_FAILURE); } int main(int argc, char *argv[]) { if (argc != 2) { panic(&amp;#34;Usage: &amp;lt;program_name&amp;gt; &amp;lt;port&amp;gt;&amp;#34;); } // server port int port = atoi(argv[1]); // PF_INET: IPv4 Internet protocols // SOCK_STREAM: TCP // 0: automatically choose int server_sock_fd = socket(PF_INET, SOCK_STREAM, 0); if (server_sock_fd == -1) { panic(&amp;#34;socket() error&amp;#34;); } struct sockaddr_in server_addr; memset(&amp;amp;server_addr, 0, sizeof(server_addr)); server_addr.</description></item></channel></rss>